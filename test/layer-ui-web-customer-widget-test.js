(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.layerUICustomerChat = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * Add this widget to your page if your customer may have multiple conversations with your company's staff.
 *
 * Use cases:
 *
 * 1. Customer's raise tickets/issues, each conversation represents a separate issue.
 * 1. Different staff at your company discuss different topics
 * 1. Each purchase is a separate conversation
 *
 * Usage:
 *
 * ```
 * import LayerUI from 'layer-ui-web';
 * import from 'layer-ui-web-customer-support/lib-es6/layer-customer-multiple-conversation/layer-customer-multiple-conversation';
 *
 * LayerUI.init({
 *     appId: "layer:///apps/staging/UUID"
 * });
 *
 *
 * <layer-customer-multiple-conversation
 *     new-participant='jane-the-support-agent'
 *     new-metadata='{"conversationName": "New Customer", "resolved": "false"}'>
 * </layer-customer-multiple-conversation>
 * ```
 *
 * @class layerUICustomer.MultipleConversationWidget
 * @mixin layerUICustomer.CustomerWidgetMixin
 */
'use strict';

var _layerUiWeb = require('layer-ui-web');

require('../subcomponents/layer-customer-chat-button/layer-customer-chat-button');

require('../subcomponents/layer-customer-welcome/layer-customer-welcome');

require('../subcomponents/layer-customer-chat/layer-customer-chat');

require('../subcomponents/layer-customer-list/layer-customer-list');

var _layerCustomerWidgetMixin = require('../layer-customer-widget-mixin');

var _layerCustomerWidgetMixin2 = _interopRequireDefault(_layerCustomerWidgetMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



(0, _layerUiWeb.registerComponent)('layer-customer-multiple-conversation', {
  mixins: [_layerCustomerWidgetMixin2.default],
  events: [],
  properties: {

    /**
     * Set this property when transitioning to the Chat View; this specifies what conversation the user will chat within.
     *
     * This value is initially null, and will be assigned a value when:
     *
     * 1. The user types in a message and a conversation is created
     * 2. The user selects a Conversation from the Conversation List
     *
     * This value can be set to a Conversation object, but is self populating if you do not set it.
     *
     * @property {layer.Conversation} conversation
     */
    conversation: {
      set: function set(value) {
        this.nodes.chatTab.conversation = value;

        // Mixin handles case where we have a value; each widget handles the case where there is no value
        if (!value) {
          if (this.query && this.query.data.length) {
            this.nodes.listTab.isOpen = true;
          } else {
            this.nodes.welcomeTab.isOpen = true;
          }
        }
      }
    },

    /**
     * A customizable function for testing of a Conversation is resolved or still open.
     *
     * This will enable us to filter out resolved conversations, and to visually flag conversations as resolved.
     *
     * For apps that do not have concepts of resolved, this can be ignored.
     *
     * ```
     * widget.resolvedTest = function(conversation) {
     *    return conversation.metadata.resolved === 'true';
     * };
     * ```
     *
     * @property {Function} resolvedTest
     * @property {layer.Conversation} resolvedTest.conversation
     */
    resolvedTest: {
      type: Function,
      value: function value(conversation) {
        return conversation.metadata.resolved === 'true';
      },
      set: function set() {
        this.nodes.listTab.resolvedTest = this.properties.resolvedTest;
      }
    },

    /**
     * Controls whether user can toggle between resolved/unresolved conversations.
     *
     * ```
     * widget.isNavigateToResolvedEnabled = false;
     * ```
     *
     * @property {Boolean} [isNavigateToResolvedEnabled=true]
     */
    isNavigateToResolvedEnabled: {
      value: true,
      type: Boolean,
      set: function set(value) {
        this.nodes.listTab.isNavigateToResolvedEnabled = value;
      }
    },

    /**
     * Label for button to navigate to view all conversations (resolved and unresolved).
     *
     * ```
     * widget.showAllLabel = "Show All";
     * ```
     *
     * @property {String} [showAllLabel=All]
     */
    showAllLabel: {
      value: 'All',
      set: function set(value) {
        this.nodes.listTab.showAllLabel = value;
      }
    },

    /**
     * Label for button to navigate to view only unresolved conversations
     *
     * ```
     * widget.showCurrentLabel = "Show Current";
     * ```
     *
     * @property {String} [showCurrentLabel=Current]
     */
    showCurrentLabel: {
      value: 'Current',
      set: function set(value) {
        this.nodes.listTab.showCurrentLabel = value;
      }
    },

    /**
     * Set the title for the conversation list.
     *
     * ```
     * widget.listTitle = "Your Tickets";
     * ```
     *
     * @property {String} [listTitle=Your Conversations]
     */
    listTitle: {
      value: 'Your Conversations',
      set: function set(value) {
        this.nodes.listTab.title = value;
      }
    },

    /**
     * Set the title for the Chat View where the user is sending/receiving messages.
     *
     * This uses a callback function so that the title can be changed each time a conversation is selected.
     *
     * Asynchronous behaviors are supported.
     *
     * ```
     * widget.chatTitleCallback = function(conversation, callback) {
     *    callback("Your chat about " + conversation.metadata.topic);
     * };
     * ```
     *
     * @property {Function} chatTitleCallback
     * @property {layer.Conversation} chatTitleCallback.conversation   The conversation being viewed
     * @property {Function} chatTitleCallback.callback                 The callback into which to provide the title string
     * @property {String} chatTitleCallback.callback.title             The title for the Chat View
     */
    chatTitleCallback: {
      type: Function,
      set: function set(value) {
        this.nodes.chatTab.titleCallback = value;
      }
    }
  },
  methods: {
    onCreate: function onCreate() {
      this.addEventListener('layer-conversation-selected', this._selectConversation.bind(this));
      this.addEventListener('layer-back-click', this.showList.bind(this));
    },
    _handleQueryChange: function _handleQueryChange() {
      if (!this.conversation) {
        if (this.query.data.length) {
          this.nodes.listTab.isOpen = true;
        }
      }
    },


    /**
     * Shows the Conversation List... if there are any Conversations.
     *
     * @method showList
     */
    showList: function showList() {
      this.conversation = null;
    },


    /**
     * When a conversation is selected in the list, set the conversation property.
     *
     * @method _selectConversation
     * @private
     */
    _selectConversation: function _selectConversation(evt) {
      evt.preventDefault();
      this.conversation = evt.detail.item;
    }
  }
});

(function () {
  var layerUI = require('layer-ui-web');
  layerUI.buildAndRegisterTemplate("layer-customer-multiple-conversation", "<div class='layer-main-dialog'><layer-customer-welcome layer-id='welcomeTab'></layer-customer-welcome><layer-customer-chat layer-id='chatTab'></layer-customer-chat><layer-customer-list layer-id='listTab'></layer-customer-list></div><layer-customer-chat-button layer-id='floatingButton'></layer-customer-chat-button>", "");
  layerUI.buildStyle("layer-customer-multiple-conversation", "", "");
})();
},{"../layer-customer-widget-mixin":3,"../subcomponents/layer-customer-chat-button/layer-customer-chat-button":4,"../subcomponents/layer-customer-chat/layer-customer-chat":5,"../subcomponents/layer-customer-list/layer-customer-list":6,"../subcomponents/layer-customer-welcome/layer-customer-welcome":7,"layer-ui-web":51}],2:[function(require,module,exports){
/**
     * Add this widget to your page if your customer has a single conversation with your company's staff.
     *
     * Use cases:
     *
     * 1. Customer has a long term relationship with a single person at your company such that they should only ever see
     *    a single conversation, with its ongoing history.
     * 1. All of the customer's history with your company should be available to both your customer and your staff in the form
     *    of one long conversation
     * 1. Your philosophy around conversations is NOT to have them as a single topic, to be closed when resolved,
     *    start a new conversation for a new topic.  If your conversations are support tickets, then this is not the right widget.
     *
     * Usage:
     *
     * ```
     * import LayerUI from 'layer-ui-web';
     * import from 'layer-ui-web-customer-support/lib-es6/layer-customer-single-conversation/layer-customer-single-conversation';
     *
     * LayerUI.init({
     *     appId: "layer:///apps/staging/UUID"
     * });
     *
     *
     * <layer-customer-single-conversation
     *     new-participant='jane-the-support-agent'
     *     new-metadata='{"conversationName": "New Customer"}'>
     * </layer-customer-single-conversation>
     * ```
     *
     * @class layerUICustomer.SingleConversationWidget
     * @mixin layerUICustomer.CustomerWidgetMixin
     */
'use strict';

var _layerUiWeb = require('layer-ui-web');

require('../subcomponents/layer-customer-chat-button/layer-customer-chat-button');

require('../subcomponents/layer-customer-welcome/layer-customer-welcome');

require('../subcomponents/layer-customer-chat/layer-customer-chat');

var _layerCustomerWidgetMixin = require('../layer-customer-widget-mixin');

var _layerCustomerWidgetMixin2 = _interopRequireDefault(_layerCustomerWidgetMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _layerUiWeb.registerComponent)('layer-customer-single-conversation', {
  mixins: [_layerCustomerWidgetMixin2.default],
  events: [],
  properties: {

    /**
     * The single Conversation that the user has with the support agent.
     *
     * This value is initially null, and will be assigned a value when:
     *
     * 1. The user types in a message and a conversation is created
     * 2. The Query to get all Conversations returns with a Conversation (if none found, continues to be null)
     *
     * This value can be set to a Conversation object, but is self populating if you do not set it.
     *
     * @property {layer.Conversation} conversation
     */
    conversation: {
      set: function set(value) {
        // Mixin handles what happens if there is a value; each widget has a different behavior if there is not a conversation
        if (!value) {
          this.nodes.welcomeTab.isOpen = true;
        }
      }
    },

    /**
     * The title for the Chat View.
     *
     * @property {String} title
     */
    title: {
      set: function set(value) {
        if (value) {
          this.nodes.chatTab.titleCallback = null;
        }
        this.nodes.chatTab.title = value;
      }
    }
  },
  methods: {
    /*
     * Documented in CustomerWidgetMixin
     * This method updates the conversation property any time we lack a conversation property and there has been a change in the Query data.
     */
    _handleQueryChange: function _handleQueryChange() {
      if (!this.conversation) {
        if (this.query.data.length) {
          this.conversation = this.query.data[0];
        }
      }
    }
  }
}); 

(function () {
  var layerUI = require('layer-ui-web');
  layerUI.buildAndRegisterTemplate("layer-customer-single-conversation", "<div class='layer-main-dialog'><layer-customer-welcome layer-id='welcomeTab'></layer-customer-welcome><layer-customer-chat layer-id='chatTab'></layer-customer-chat></div><layer-customer-chat-button layer-id='floatingButton'></layer-customer-chat-button>", "");
  layerUI.buildStyle("layer-customer-single-conversation", "", "");
})();
},{"../layer-customer-widget-mixin":3,"../subcomponents/layer-customer-chat-button/layer-customer-chat-button":4,"../subcomponents/layer-customer-chat/layer-customer-chat":5,"../subcomponents/layer-customer-welcome/layer-customer-welcome":7,"layer-ui-web":51}],3:[function(require,module,exports){
/**
 * Main Components of this library all use this mixin to provide a set of standard behaviors.
 *
 * @class layerUICustomer.CustomerWidgetMixin
 * @extends layerUI.components.Component
 */
'use strict';

var _mainComponent = require('layer-ui-web/lib-es5/mixins/main-component');

var _mainComponent2 = _interopRequireDefault(_mainComponent);

var _layerWebsdk = require('layer-websdk');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



module.exports = {
  mixins: [_mainComponent2.default],

  /**
   * This event is triggered before creating a Conversation and sending a message on that Conversation.
   *
   * You can use this event to modify the conversation or message prior to their being sent,
   * and optionally, you can call `evt.preventDefault()` to prevent them from being sent (but you can still
   * send them yourself).
   *
   * ```
   * document.body.addEventListener('layer-create-conversation-and-message', function(evt) {
   *   var conversation = evt.detail.conversation;
   *   var message = evt.detail.message;
   *   var notification = evt.detail.notification;
   *   var text = message.parts[0].body;
   *   conversation.setMetadataProperties({"First Message": text});
   *   if (text.match(/help/)) {
   *     evt.preventDefault():
   *     alert("I'm sorry, we aren't very helpful");
   *   } else {
   *     message.addPart({
   *       body: "Certified as being a message that doesn't ask for help",
   *       mimeType: "text/unhelpful"
   *     });
   *     notification.title = 'Incoming!';
   *   }
   * });
   * ```
   *
   * @event layer-create-conversation-and-message
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Conversation} evt.detail.conversation   The conversation generated for this message
   * @param {layer.Message} evt.detail.message             The message generated for this message
   * @param {Object} evt.detail.notification               The notification that will be sent with this message
   */

  /**
   * This property function is triggered before creating a Conversation and sending a message on that Conversation.
   *
   * You can use this event to modify the conversation or message prior to their being sent,
   * and optionally, you can call `evt.preventDefault()` to prevent them from being sent (but you can still
   * send them yourself).
   *
   * ```
   * widget.onCreateConversationAndMessage = function(evt) {
   *   var conversation = evt.detail.conversation;
   *   var message = evt.detail.message;
   *   var notification = evt.detail.notification;
   *   var text = message.parts[0].body;
   *   conversation.setMetadataProperties({"First Message": text});
   *   if (text.match(/help/)) {
   *     evt.preventDefault():
   *     alert("I'm sorry, we aren't very helpful");
   *   } else {
   *     message.addPart({
   *       body: "Certified as being a message that doesn't ask for help",
   *       mimeType: "text/unhelpful"
   *     });
   *     notification.title = 'Incoming!';
   *   }
   * });
   * ```
   *
   * @property {Function} onCreateConversationAndMessage
   * @property {Event} onCreateConversationAndMessage.evt
   * @property {Object} onCreateConversationAndMessage.evt.detail
   * @property {layer.Conversation} onCreateConversationAndMessage.evt.detail.conversation   The conversation generated for this message
   * @property {layer.Message} onCreateConversationAndMessage.evt.detail.message             The message generated for this message
   */
  events: ['layer-create-conversation-and-message'],
  properties: {

    /*
     * Documented for each widget.
     * Any time the Conversation changes we need to:
     * 1. pass that to the chatTab
     * 2. Open the chatTab if we have a conversation
     */
    conversation: {
      set: function set(value) {
        this.nodes.chatTab.conversation = value;

        // Open the chat tab if/when we have a fully created conversation;
        // else use the welcome tab
        if (value) {
          this.nodes.chatTab.isOpen = true;
        }
      }
    },

    /**
     * The query used to find your Conversation(s)
     *
     * @property {layer.Query} query
     * @readonly
     */
    query: {},

    /**
     * Each customer starts on the welcome tab; put a custom welcome message on the welcome tab.
     *
     * ```
     * var div = document.createElement('div');
     * div.innerHTML = "Howdy; do you like ping pong or foosball? Let us know!";
     * widget.welcomeNodes = div;
     * ```
     *
     * @property {HTMLElement} welcomeNodes
     */
    welcomeNodes: {
      type: HTMLElement,
      set: function set() {
        this.nodes.welcomeTab.welcomeNodes = this.welcomeNodes;
      }
    },

    /**
     * Identity ID for the customer support staff (or bot) that the user will create a conversation with.
     *
     * ```
     * widget.newParticipant = 'layer:///identities/support-beam';
     *
     * // OR
     * <widget
     *     new-participant='layer:///identities/jane-the-support-agent'>
     * </widget>
     * ```
     * ```
     *
     * @property {String} newParticipant
     */
    newParticipant: {},

    /**
     * Metadata to create a Conversation with.  Has no impact on existing Conversations.
     *
     * ```
     * widget.newMetadata = {
     *    "resolved": "false",
     *    "conversationName": "Support Call"
     * };
     *
     * // OR
     * <widget
     *     new-metadata='{"resolved": "false", "conversationName": "Support Call"}'>
     * </widget>
     * ```
     *
     * @property {Object} newMetadata
     */
    newMetadata: {
      set: function set(value) {
        if (typeof value === 'string') {
          try {
            this.properties.newMetadata = JSON.parse(value);
          } catch (e) {}
        }
      }
    },

    /**
     * Is the dialog showing?
     *
     * Set this property to true to show the dialog.  This is done for you when the
     * user clicks the `<layer-customer-chat-button />` widget.
     *
     * ```
     * if (!widget.isDialogShowing) {
     *     widget.isDialogShowing = true;
     * } else {
     *     console.log('Already Showing');
     * }
     * ```
     *
     * This widget gets a `layer-open-dialog` css class when `isDialogShowing` is true.
     *
     * @property {Boolean} isDialogShowing
     */
    isDialogShowing: {
      value: false,
      set: function set(value) {
        this.classList[value ? 'add' : 'remove']('layer-open-dialog');
        this.nodes.floatingButton.isOpen = value;

        this.nodes.chatTab.isDialogShowing = value;
        if (this.nodes.listTab) this.nodes.listTab.isDialogShowing = value;
        this.nodes.welcomeTab.isDialogShowing = value;
      }
    },

    /**
     * Add buttons to the right of the Chat window's composer.
     *
     * The composer is the panel where the user types their message.
     *
     * ```
     * widget.composeButtons = [
     *     document.createElement('button'),
     *     document.createElement('button')
     * ];
     * ```
     *
     * @property {HTMLElement[]} [composeButtons=[]]
     */
    composeButtons: {
      type: HTMLElement,
      set: function set(value) {
        this.nodes.chatTab.composeButtons = value;
      }
    },

    /**
     * Add buttons to the left of the Chat window's composer.
     *
     * ```
     * widget.composeButtonsLeft = [
     *     document.createElement('button'),
     *     document.createElement('button')
     * ];
     * ```
     *
     * @property {HTMLElement[]} [composeButtonsLeft=[]]
     */
    composeButtonsLeft: {
      set: function set(value) {
        this.nodes.chatTab.composeButtonsLeft = value;
      }
    }
  },
  methods: {

    /*
     * Initialize properties that need initial values;
     * Setup event handlers
     */
    onCreate: function onCreate() {
      this.addEventListener('layer-customer-chat-button-click', this.toggleOpen.bind(this));
      this.addEventListener('layer-send-message', this._createConversationAndSendMessage.bind(this));
      if (!this.properties.newMetadata) this.properties.newMetadata = {};
      this.nodes.welcomeTab.isOpen = true;
    },


    /*
     * Initialize any properties that depend upon this widget having received its properties already.
     *
     * That includes setting up a query and its event handlers.
     */
    onAfterCreate: function onAfterCreate() {
      if (!this.query) {
        this.query = this.client.createQuery({
          model: _layerWebsdk.Query.Conversation,
          paginationWindow: 20
        });
      }
      this.query.on('change', this._handleQueryChange, this);

      if (this.nodes.listTab) this.nodes.listTab.query = this.query;
    },


    /**
     * The Conversation Query has had a change in its data.
     *
     * Any time this happens, update the widget's `floatingButton.hasUnread` property.
     *
     * @method _handleQueryChange
     * @private
     */
    _handleQueryChange: function _handleQueryChange() {
      this._updateUnread();
    },


    /**
     * Create the Conversation and send the message.
     *
     * When the user types in a message in the welcome tab and hits send, this
     * method will fire to create the conversations, and then create the user's message
     * on this conversations.
     *
     * Triggers the layer-create-conversation-and-message event allowing clients to override this behavior
     *
     * @method _createConversationAndSendMessage
     * @param {Event} evt
     * @private
     */
    _createConversationAndSendMessage: function _createConversationAndSendMessage(evt) {
      if (!evt.detail.conversation) {
        evt.preventDefault();
        var conversation = this.client.createConversation({
          distinct: false,
          participants: [this.client.user, this.newParticipant],
          metadata: this.newMetadata
        });
        var message = conversation.createMessage({
          parts: evt.detail.parts
        });
        var notification = {
          title: "New Conversation",
          text: message.parts.filter(function (item) {
            return item.mimeType === 'text/plain';
          })[0].body
        };
        if (this.trigger('layer-create-conversation-and-message', { conversation: conversation, message: message, notification: notification })) {
          this.conversation = conversation;
          message.send(notification);
        }
      }
    },


    /**
     * This method is called whenever the user clicks on the Chat Button to toggle display of the dialog.
     *
     * It can be used to directly toggle... but it is suggested that you instead use the `isDialogShowing` property instead.
     *
     * @method toggleOpen
     */
    toggleOpen: function toggleOpen() {
      this.isDialogShowing = !this.isDialogShowing;
    },


    /**
     * Recalculate whether there are any conversations that are unread.
     *
     * Checks all query data to see if any Conversation's last message is unread,
     * and if it is, sets the floating button's `hasUnread` proeprty to `true`.
     *
     * @method _updateUnread
     * @private
     */
    _updateUnread: function _updateUnread() {
      var unreadConversations = this.query.data.filter(function (conversation) {
        return conversation.lastMessage && conversation.lastMessage.isUnread;
      });
      this.nodes.floatingButton.hasUnread = Boolean(unreadConversations.length);
    }
  }
};
},{"layer-ui-web/lib-es5/mixins/main-component":60,"layer-websdk":79}],4:[function(require,module,exports){
/**
     * Floating button for opening up the chat UI.
     *
     * Consists of 3 states:
     *
     * * Dialog is closed, no unread messages
     * * Dialog is closed, there are unread messages
     * * Dialog is open
     *
     * Generates a `layer-customer-chat-button-click` event when the user clicks.
     *
     * TODO: Enable the event to be cancelable.  Currently intercepted by controller before anything can be done.
     *
     * @class layerUICustomer.ChatButton
     * @extends layerUI.components.Component
     */
'use strict';

var _layerUiWeb = require('layer-ui-web');

(0, _layerUiWeb.registerComponent)('layer-customer-chat-button', {
  mixins: [],
  events: [],
  properties: {
    openHTML: {
      value: '\uF00D'
    },
    closedHTML: {
      value: '\uF0E5'
    },
    /**
     * isOpen property inidicates if the dialog is open or closed.
     *
     * Set this property to change the button's state; this won't affect the actual Dialog.
     *
     * Typically set by the controller.
     *
     * @property {Boolean} [isOpen=false]
     */
    isOpen: {
      value: false,
      set: function set(value) {
        this.classList[value ? 'add' : 'remove']('floating-chat-icon-open');
        this.classList[value ? 'remove' : 'add']('floating-chat-icon-closed');
        this.innerHTML = value ? this.openHTML : this.closedHTML;
      }
    },

    /**
     * There are unread converations; render an indicator of this.
     *
     * Typically set by the controller.
     *
     * @property {Boolean} [hasUnread=false]
     */
    hasUnread: {
      set: function set(value) {
        this.classList[value ? 'add' : 'remove']('layer-has-unread-conversations');
      }
    }
  },
  methods: {
    onCreate: function onCreate() {
      this.addEventListener('click', this._handleClick.bind(this));
    },


    /**
     * When the user clicks the button, emit a `layer-customer-chat-button-click` event.
     *
     * @method _handleClick
     * @param {Event} evt
     * @private
     */
    _handleClick: function _handleClick(evt) {
      this.trigger('layer-customer-chat-button-click', { open: !this.isOpen });
    }
  }
}); 

(function () {
  var layerUI = require('layer-ui-web');
  layerUI.buildAndRegisterTemplate("layer-customer-chat-button", "", "");
  layerUI.buildStyle("layer-customer-chat-button", "layer-customer-chat-button {\nposition: absolute;\ndisplay: block;\nbottom: 20px;\nright: 20px;\ncursor: pointer;\n}", "");
})();
},{"layer-ui-web":51}],5:[function(require,module,exports){
/**
     * Adds a View where the user has their conversation
     *
     * This view wraps a LayerUI.components.ConversationPanel.
     *
     * TODO: Implement an elegant mechanism for automatically identifying all ConversationPanel properties and exposing them as properties on this view.
     *
     * @class layerUICustomer.ChatTab
     * @mixin layerUICustomer.mixins.Tab
     * @mixin layerUI.mixins.FocusOnKeydown
     * @extends layerUI.components.Component
     */
'use strict';

var _layerUiWeb = require('layer-ui-web');

var _tab = require('../../../mixins/tab');

var _tab2 = _interopRequireDefault(_tab);

var _focusOnKeydown = require('layer-ui-web/lib-es5/mixins/focus-on-keydown');

var _focusOnKeydown2 = _interopRequireDefault(_focusOnKeydown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _layerUiWeb.registerComponent)('layer-customer-chat', {
  mixins: [_tab2.default, _focusOnKeydown2.default],
  events: [],
  properties: {

    /**
     * Get/set the title for the tab.
     *
     * Note that this property is set by layerUICustomer.ChatTab.titleCallback;
     * which should be set to `null` if you intend on setting `title` directly.
     *
     * ```
     * widget.titleCallback = null;
     * widget.title = "My Frelling Title";
     * ```
     *
     * @property {String} title
     */
    title: {
      set: function set(value) {
        this.nodes.titleText.innerHTML = value;
      }
    },

    /**
     * Get/set the Conversation to be viewed and messaged on.
     *
     * This property can be directly set to any layer.Conversation at any time.
     *
     * ```
     * widget.conversation = myConversation;
     * ```
     *
     * @property {layer.Conversation} conversation
     */
    conversation: {
      set: function set(newConversation, oldConversation) {
        this.nodes.conversationPanel.conversation = newConversation;
        this._updateTitle();

        if (oldConversation) oldConversation.off(null, null, this);
        if (newConversation) newConversation.on('conversations:change', this._updateTitle, this);
      }
    },

    /**
     * Provide a titleCallback to customize how the title for this view is generated from the selected conversation.
     *
     * ```
     * widget.titleCallback = function(conversation, callback) {
     *    callback("Your chat about " + conversation.metadata.topic);
     * };
     * ```
     *
     * @property {Function} titleCallback
     * @property {layer.Conversation} titleCallback.conversation   The conversation being viewed
     * @property {Function} titleCallback.callback                 The callback into which to provide the title string
     * @property {String} titleCallback.callback.title             The title for this View
     */
    titleCallback: {
      // This is the default function to use for titleCallback
      value: function value(conversation, callback) {
        if (!conversation) {
          this.title = '';
        } else {
          var title = conversation.metadata.conversationName;
          if (title) {
            callback(title);
          } else {
            var supportIdentity = conversation.participants.filter(function (identity) {
              return !identity.sessionOwner;
            })[0];
            if (supportIdentity) {
              if (!supportIdentity.isLoading) {
                callback('Talking with ' + supportIdentity.displayName);
              } else {
                supportIdentity.once('identities:loaded', function () {
                  callback('Talking with ' + supportIdentity.displayName);
                });
              }
            }
          }
        }
      },

      // Update the title any time this changes
      set: function set(value) {
        this._updateTitle();
      }
    },

    /**
     * If the dialog is not showing, then it doesn't matter that this view is open; the whole UI should be disabled.
     *
     * We disable the view to insure that read receipts are not sent for messages that are scrolled into view... but not actually viewable.
     *
     * This is set by the controller, and should not be set directly.
     *
     * @property {Boolean} [isDialogShowing=false]
     * @readonly
     */
    isDialogShowing: {
      set: function set(value) {
        var isShowing = this.isDialogShowing && this.isOpen;
        this.nodes.conversationPanel.disable = !isShowing;
      }
    },

    /**
     * If the tab is not open, then disable the view.
     *
     * We disable the view to insure that read receipts are not sent for messages that are scrolled into view... but not actually viewable.
     *
     * You can show a tab by setting this property:
     *
     * ```
     * widget.isOpen = true;
     * ```
     *
     * @property {Boolean} [isDialogShowing=false]
     */
    isOpen: {
      set: function set(value) {
        var isShowing = this.isDialogShowing && this.isOpen;
        this.nodes.conversationPanel.disable = !isShowing;
      }
    },

    /**
     * An array of buttons (dom nodes) to be added to the Compose bar, right side.
     *
     * ```
     * widget.composeButtons = [
     *     document.createElement('button'),
     *     document.createElement('button')
     * ];
     * ```
     *
     * @property {HTMLElement[]} [composeButtons=[]]
     */
    composeButtons: {
      set: function set(value) {
        this.nodes.conversationPanel.composeButtons = value;
      }
    },

    /**
     * An array of buttons (dom nodes) to be added to the Compose bar, left side.
     *
     * ```
     * widget.composeButtonsLeft = [
     *     document.createElement('button'),
     *     document.createElement('button')
     * ];
     * ```
     *
     * @property {HTMLElement[]} [composeButtonsLeft=[]]
     */
    composeButtonsLeft: {
      set: function set(value) {
        this.nodes.conversationPanel.composeButtonsLeft = value;
      }
    }
  },
  methods: {

    // Setup initial values and event handlers
    onCreate: function onCreate() {
      this.nodes.backButton.addEventListener('click', this._handleBackClick.bind(this));
      this.nodes.conversationPanel.getMessageDeleteEnabled = function () {
        return false;
      };
      this.nodes.conversationPanel.disable = true;
    },


    /**
     * User clicked on back button.  Trigger the event and let the controller handle it.
     *
     * @method _handleBackClick
     * @private
     */
    _handleBackClick: function _handleBackClick() {
      this.trigger('layer-back-click');
    },


    /**
     * Use the titleCallback property to set the title from the conversation.
     *
     * @method _updateTitle
     * @private
     */
    _updateTitle: function _updateTitle() {
      var _this = this;

      if (this.titleCallback && this.conversation) {
        this.titleCallback(this.conversation, function (title) {
          _this.title = title;
        });
      } else {
        this.title = "";
      }
    },


    /**
     * Whenever a keypress is detected that isn't received by an input, focus on the conversationPanel's composer.
     *
     * @method onKeyDown
     */
    onKeyDown: function onKeyDown() {
      this.nodes.conversationPanel.focusText();
    }
  }
}); 

(function () {
  var layerUI = require('layer-ui-web');
  layerUI.buildAndRegisterTemplate("layer-customer-chat", "<div class='layer-chat-title layer-dialog-title' layer-id='chatTitle'><div class='layer-title-buttons'><span class=\"layer-title-button layer-back-button\" layer-id='backButton'></span></div><div class='layer-title-text' layer-id='titleText'>Your Conversations</div></div><layer-conversation-panel layer-id='conversationPanel'></layer-conversation-panel>", "");
  layerUI.buildStyle("layer-customer-chat", "layer-customer-chat {\ndisplay: flex;\nflex-direction: column;\n}\nlayer-customer-chat layer-conversation-panel {\nflex-grow: 1;\n}", "");
})();
},{"../../../mixins/tab":9,"layer-ui-web":51,"layer-ui-web/lib-es5/mixins/focus-on-keydown":54}],6:[function(require,module,exports){
/**
     * Adds a View where the user's conversations are listed.
     *
     * This view wraps a layerUI.components.ConversationsListPanel.List.
     *
     * TODO: Implement an elegant mechanism for automatically identifying all ConversationList properties and exposing them as properties on this view.
     *
     * @class layerUICustomer.ListTab
     * @mixin layerUICustomer.mixins.Tab
     * @mixin layerUI.mixins.FocusOnKeydown
     * @extends layerUI.components.Component
     */
'use strict';

var _layerUiWeb = require('layer-ui-web');

var _tab = require('../../../mixins/tab');

var _tab2 = _interopRequireDefault(_tab);

var _focusOnKeydown = require('layer-ui-web/lib-es5/mixins/focus-on-keydown');

var _focusOnKeydown2 = _interopRequireDefault(_focusOnKeydown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _layerUiWeb.registerComponent)('layer-customer-list', {
  mixins: [_tab2.default, _focusOnKeydown2.default],
  events: [],
  properties: {

    /**
     * This widget requires a `query` property; this is generated and passed in by the controller.
     *
     * @property {layer.ConversationQuery} query
     */
    query: {
      set: function set(value) {
        this.nodes.listPanel.query = value;
      }
    },

    /**
     * This property simply exposes the layerUI.components.ConversationsListPanel.List.selectedId property.
     *
     * @property {String} selectedId    This is a Conversation ID
     */
    selectedId: {
      set: function set(value) {
        this.nodes.listPanel.selectedId = value;
      },
      get: function get() {
        return this.nodes.listPanel.selectedId;
      }
    },

    /**
     * A customizable function for testing of a Conversation is resolved or still open.
     *
     * This will enable us to filter out resolved conversations, and to visually flag conversations as resolved.
     *
     * For apps that do not have concepts of resolved, this can be ignored.
     *
     * ```
     * widget.resolvedTest = function(conversation) {
     *    return conversation.metadata.resolved === 'true';
     * };
     * ```
     *
     * @property {Function} resolvedTest
     * @property {layer.Conversation} resolvedTest.conversation
     */
    resolvedTest: {
      set: function set(fn) {
        var _this = this;

        if (fn && this.filterMode === 'open') {
          this.nodes.listPanel.filter = function (conversation) {
            return !_this.properties.resolvedTest(conversation);
          };
        } else {
          this.nodes.listPanel.filter = null;
        }
      }
    },

    /**
     * Enable/disable filtering on the conversation list using the filterMode.
     *
     * * 'open': Only show conversations that fail the layerUICustomer.ListTab.resolvedTest.
     * * 'all': Show all conversations
     *
     * @property {String} [filterMode=open]
     */
    filterMode: {
      value: 'open',
      set: function set(value) {
        var _this2 = this;

        switch (value) {
          case 'open':
            if (this.resolvedTest) {
              this.nodes.listPanel.filter = function (conversation) {
                return !_this2.properties.resolvedTest(conversation);
              };
            } else {
              this.nodes.listPanel.filter = null;
            }
            this.nodes.filterAllButton.classList.remove('layer-toggle-selected');
            this.nodes.filterOpenButton.classList.add('layer-toggle-selected');
            break;
          case 'all':
            this.nodes.listPanel.filter = null;
            this.nodes.filterOpenButton.classList.remove('layer-toggle-selected');
            this.nodes.filterAllButton.classList.add('layer-toggle-selected');
            break;
        }
      }
    },

    /**
     * Controls whether user can toggle between resolved/unresolved conversations.
     *
     * ```
     * widget.isNavigateToResolvedEnabled = false;
     * ```
     *
     * @property {Boolean} [isNavigateToResolvedEnabled=true]
     */
    isNavigateToResolvedEnabled: {
      set: function set(value) {
        this.classList[value ? 'add' : 'remove']('layer-list-filter-toggles-enabled');
      }
    },

    /**
     * Set the label of the 'Show All' button that shows all conversations.
     *
     * ```
     * widget.showAllLabel = 'Show All';
     * ```
     *
     * @property {String} showAllLabel
     */
    showAllLabel: {
      set: function set(value) {
        this.nodes.filterAllButton.innerHTML = value;
      }
    },

    /**
     * Set the label of the 'Show Current' button that shows all unresolved conversations.
     *
     * ```
     * widget.showCurrentLabel = 'Show Current';
     * ```
     *
     * @property {String} showCurrentLabel
     */
    showCurrentLabel: {
      set: function set(value) {
        this.nodes.filterOpenButton.innerHTML = value;
      }
    },

    /**
     * Set the title for this view.
     *
     * ```
     * widget.title = 'So many conversations!';
     * ```
     *
     * @property {string} title
     */
    title: {
      set: function set(value) {
        this.nodes.titleText.innerHTML = value;
      }
    }
  },
  methods: {
    // Setup initial values and event handlers
    onCreate: function onCreate() {
      this.nodes.filterAllButton.addEventListener('click', this._changeFilter.bind(this));
      this.nodes.filterOpenButton.addEventListener('click', this._changeFilter.bind(this));
      this.nodes.listPanel.onRenderListItem = this.onRenderItem.bind(this);
    },


    /**
     * Whenever a conversation-list-item is rendered, call this method to mark them as resolved/unresolved.
     *
     * For use by the Conversation List only.
     *
     * @method onRenderItem
     * @private
     */
    onRenderItem: function onRenderItem(widget) {
      var conversation = widget.item;
      var isResolved = this.resolvedTest ? this.resolvedTest(conversation) : false;
      var resolvedNode = widget.querySelector('.layer-conversation-resolved');
      if (!isResolved && resolvedNode) {
        resolvedNode.parentNode.removeChild(resolvedNode);
      } else if (isResolved && !resolvedNode) {
        var newNode = document.createElement('i');
        newNode.classList.add('layer-conversation-resolved');
        widget.querySelector('.layer-list-item').appendChild(newNode);
      }
    },


    /**
     * Whenever a key press is detected within the widget that is not within an input, focus on the composer.
     *
     * @method onKeyDown
     * @private
     */
    onKeyDown: function onKeyDown() {
      this.nodes.listComposer.focus();
    },


    /**
     * Any time the user clicks to change the list filter, this is called.
     *
     * @method _changeFilter
     * @param {Event} evt
     * @private
     */
    _changeFilter: function _changeFilter(evt) {
      if (evt.target === this.nodes.filterAllButton) {
        this.filterMode = 'all';
      } else {
        this.filterMode = 'open';
      }
    }
  }
}); 

(function () {
  var layerUI = require('layer-ui-web');
  layerUI.buildAndRegisterTemplate("layer-customer-list", "<div class='layer-list-title layer-dialog-title' layer-id='listTitle'><div class='layer-title-text' layer-id='titleText'></div><div class='layer-title-buttons layer-toggle-pannel'><button class='layer-toggle-selected' layer-id='filterOpenButton'></button><button layer-id='filterAllButton'></button></div></div><layer-conversations-list layer-id='listPanel'></layer-conversations-list><layer-composer layer-id='listComposer' placeholder='Start a new conversation'></layer-composer>", "");
  layerUI.buildStyle("layer-customer-list", "layer-customer-list {\ndisplay: flex;\nflex-direction: column;\n}\nlayer-conversations-list {\nflex-grow: 1;\n}\nlayer-customer-list .layer-list-toggles {\ndisplay: none;\n}\nlayer-customer-list.layer-list-filter-toggles-enabled .layer-list-toggles {\ndisplay: block;\n}", "");
})();
},{"../../../mixins/tab":9,"layer-ui-web":51,"layer-ui-web/lib-es5/mixins/focus-on-keydown":54}],7:[function(require,module,exports){
/**
     * The welcome view that welcomes the user to the chat experiences and prompts them to being.
     *
     * @class layerUICustomer.WelcomeTab
     * @mixin layerUICustomer.mixins.Tab
     * @mixin layerUI.mixins.FocusOnKeydown
     * @extends layerUI.components.Component
     */
'use strict';

var _layerUiWeb = require('layer-ui-web');

var _tab = require('../../../mixins/tab');

var _tab2 = _interopRequireDefault(_tab);

var _focusOnKeydown = require('layer-ui-web/lib-es5/mixins/focus-on-keydown');

var _focusOnKeydown2 = _interopRequireDefault(_focusOnKeydown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _layerUiWeb.registerComponent)('layer-customer-welcome', {
  mixins: [_tab2.default, _focusOnKeydown2.default],
  events: [],
  properties: {

    /**
     * Any HTML elements provided here will be rendered on top of the view.
     *
     * This is presumed to be some sort of Welcome message.
     *
     * @property {HTMLElement} welcomeNodes
     */
    welcomeNodes: {
      set: function set() {
        this.nodes.welcomeNote.innerHTML = '';
        this.nodes.welcomeNote.appendChild(this.welcomeNodes);
      }
    }
  },
  methods: {
    onCreate: function onCreate() {},


    /**
     * Any time a key press is detected in this view that isn't received by an input, focus on the Composer.
     *
     * @method onKeyDown
     * @private
     */
    onKeyDown: function onKeyDown() {
      this.nodes.welcomeComposer.focus();
    }
  }
}); 

(function () {
  var layerUI = require('layer-ui-web');
  layerUI.buildAndRegisterTemplate("layer-customer-welcome", "<div class='layer-customer-widget-welecome-message' layer-id='welcomeNote'></div><div class='layer-coustomer-widget-welcome-spacer'></div><layer-composer layer-id='welcomeComposer'></layer-composer>", "");
  layerUI.buildStyle("layer-customer-welcome", "", "");
})();
},{"../../../mixins/tab":9,"layer-ui-web":51,"layer-ui-web/lib-es5/mixins/focus-on-keydown":54}],8:[function(require,module,exports){
'use strict';

var LayerUICustomerChatWidget = {};

require('./components/layer-customer-single-conversation/layer-customer-single-conversation');
require('./components/layer-customer-multiple-conversation/layer-customer-multiple-conversation');

module.exports = LayerUICustomerChatWidget;
},{"./components/layer-customer-multiple-conversation/layer-customer-multiple-conversation":1,"./components/layer-customer-single-conversation/layer-customer-single-conversation":2}],9:[function(require,module,exports){
/**
 * Tab Mixin adds tab-like properties to a panel.
 *
 * @class layerUICustomer.mixins.Tab
 */
'use strict';



module.exports = {
  properties: {
    /**
     * The tab is currently open.
     *
     * Note that this could be true, even though the dialog/parent is hidden.
     *
     * @property {Boolean} [isOpen=false]
     */
    isOpen: {
      value: false,
      set: function set(value) {
        var _this = this;

        this.style.display = value ? '' : 'none';
        if (value) {
          var nodes = this.parentNode.childNodes;
          for (var i = 0; i < nodes.length; i++) {
            if (nodes[i] !== this) nodes[i].isOpen = false;
          }

          // Must wait until rendering is completed in order to call focus.
          setTimeout(function () {
            return _this.focus();
          }, 1);
        }
      }
    }
  },
  methods: {
    onCreate: function onCreate() {
      this.classList.add('layer-tab');
    }
  }
};
},{}],10:[function(require,module,exports){

},{}],11:[function(require,module,exports){
/**
 * Call this function to initialize all of the angular 1.x directives needed to handle the Layer UI for Web widgets.
 *
 * When passing scope values/function into widget properties, prefix the property with `ng-`;
 * for functions, replace `on-` with `ng-`.  If passing in a literal, do NOT prefix with `ng-`:
 *
 * ```
 *    <layer-notifier notify-in-foreground="toast"></layer-notifier>
 *    <layer-conversation-panel ng-query="myscopeProp.query"></layer-conversation-panel>
 *    <layer-conversations-list ng-conversation-selected="myscope.handleSelectionFunc"></layer-conversations-list>
 *    <layer-send-button></layer-send-button>
 *    <layer-file-upload-button></layer-file-upload-button>
 * ```
 *
 * Call this function to initialize angular 1.x Directives which will be part of the "layerUIControllers" controller:
 *
 * ```
 * layerUI.adapters.angular(angular); // Creates the layerUIControllers controller
 * angular.module('MyApp', ['layerUIControllers']);
 * ```
 *
 *   Now you can put `<layer-conversation-panel>` and other widgets into angular templates and expect them to work.
 *   Prefix ALL property names with `ng-` to insure that scope is evaluated prior to passing the value on to the webcomponent.
 *
 * @class layerUI.adapters.angular
 * @singleton
 * @param {Object} angular     Pass in the AngularJS library
 */'use strict';

var _base = require('../base');

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



function initAngular(angular) {

  // Define the layerUIController
  var controllers = angular.module('layerUIControllers', []);

  // Setup the properties for the given widget that is being generated
  function setupProps(scope, elem, attrs, props) {

    /*
     * For each property we are going to do the following:
     *
     * 1. See if there is an initial value
     * 2. Evaluate it against the scope via scope.$eval() so we have a resolved value
     * 3. $observe() for any changes in the property
     * 4. $watch() for any changes in the output of scope.$eval()
     *
     * One complicating factor here: while we do support passing in values such as `query` or `query-id`, these
     * values, if placed within an html template, will be passed directly on to a webcomponent BEFORE
     * this code triggers and corrects those values.  This can cause errors.
     *
     * Instead, if one passes `ng-query` or `ng-query-id` in via the html template, there is no `ng-query` property
     * to pass this value on to until the code below triggers.  The code below will map `ng-query` to `query` AFTER
     * its been evaluated.
     *
     * The above steps are applied once for `query-id`, and a second time for `ng-query-id` so that either one works, but `ng-`
     * works better.
     *
     * Best Practice therefore: Use `ng-` prefix on all properties passed via html template files.
     */
    props.forEach(function (prop) {
      var ngPropertyName = prop.propertyName.indexOf('on') === 0 ? 'ng' + prop.propertyName.substring(2) : 'ng' + prop.propertyName.substring(0, 1).toUpperCase() + prop.propertyName.substring(1);

      // Observe for changes to the attribute value and apply them to the property value
      attrs.$observe(prop.propertyName, function (value) {
        if (elem.properties) {
          elem[prop.propertyName] = value;
        } else {
          if (!elem.properties) elem.properties = {};
          elem.properties[prop.propertyName] = value;
        }
      });

      // Observe for changes to the attribute value prefixed with "ng-" and watch the scoped expression for changes
      // that need to be applied to the property value.
      attrs.$observe(ngPropertyName, function (expression) {
        scope.$watch(expression, function (value) {
          if (!elem.properties) elem.properties = {};
          if (elem.properties._internalState && !elem.properties._internalState.disableSetters) {
            elem[prop.propertyName] = value;
          } else {
            elem.properties[prop.propertyName] = value;
          }
        });
      });
    });
  }

  // Gather all UI Components flagged as Main Components; other components don't require special wrappers that allow properties
  // embedded in Angular's Templates to correctly handle values.
  Object.keys(_base2.default.components).filter(function (componentName) {
    var component = _base2.default.components[componentName];
    return component.properties.filter(function (prop) {
      return prop.propertyName === '_isMainComponent';
    }).length;
  }).forEach(function (componentName) {
    var component = _base2.default.components[componentName];

    // Get the camel case controller name
    var controllerName = componentName.replace(/-(.)/g, function (str, value) {
      return value.toUpperCase();
    });

    controllers.directive(controllerName, function () {
      return {
        retrict: 'E',
        link: function link(scope, elem, attrs) {
          var functionProps = component.properties;
          setupProps(scope, elem[0], attrs, functionProps);
        }
      };
    });
  });
}

module.exports = initAngular;
_base2.default.addAdapter('angular', initAngular);
},{"../base":14}],12:[function(require,module,exports){
/**
 * Call this function to initialize all of the Backbone Views needed to handle the Layer UI for Web widgets.
 *
 * Initialize this adapter using:
 *
 * ```javascript
 * var Backbone = require('backbone');
 * var LayerUIViews = layerUI.adapters.backbone(Backbone);
 * var conversationPanelView = new LayerUIViews.ConversationPanel(client, {conversationId: 'layer:///conversations/UUID'});
 * var conversationsListView = new LayerUIViews.ConversationsList(client);
 * var identitiesListView = new LayerUIViews.UserList(client);
 * var notifierView = new LayerUIViews.Notifier(client, {notifyInForeground: 'toast'});
 * var sendButton = new LayerUIViews.SendButton(client);
 * var fileUploadButton = new LayerUIViews.FileUploadButton(client);
 * ```
 *
* Calling this will expose the following React Components:
 *
 * * ConversationPanelView: A wrapper around a layerUI.components.ConversationPanel
 * * ConversationsListView: A wrapper around a layerUI.components.ConversationsListPanel
 * * IdentitiesListView: A wrapper around a layerUI.components.IdentitiesListPanel
 * * NotifierView: A wrapper around a layerUI.components.misc.Notifier
 * * SendButton: An optional button that can be provided to ConversationPanelView's `composeButtons` property
 *   to add a simple Send button to the Composer
 * * FileUploadButton: An optional button that can be provided to ConversationPanelView's `composeButtons` property
 *   to add a simple Select and Send File button to the Composer
 *
 *
 * Any occurances of a layer widget in your html should be associated with these views:
 *
 * ```html
 * < !-- Associated with the NotifierView -->
 * < layer-notifier notify-in-foreground="toast"></layer-notifier>
 *
 * < !-- Associated with the ConversationView -->
 * < layer-conversation-panel conversation-id="layer:///conversations/UUID"></layer-conversation-panel>
 * ```
 *
 * @class layerUI.adapters.backbone
 * @singleton
 * @param {Object} backbone     Pass in the backbone library
 */'use strict';

var _base = require('../base');

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var libraryResult = void 0;
function initBackbone(backbone) {
  if (libraryResult) return libraryResult;
  libraryResult = {};

  // Gather all UI Components flagged as Main Components; other components don't require special wrappers for direct use by Apps.
  Object.keys(_base2.default.components).filter(function (componentName) {
    var component = _base2.default.components[componentName];
    return component.properties.filter(function (prop) {
      return prop.propertyName === '_isMainComponent';
    }).length;
  }).forEach(function (componentName) {
    var component = _base2.default.components[componentName];

    // Get the camel case Component name
    var className = (componentName.substring(0, 1).toUpperCase() + componentName.substring(1).replace(/-(.)/g, function (str, value) {
      return value.toUpperCase();
    })).replace(/^Layer/, '');

    // Define the Backbone View
    var view = libraryResult[className] = backbone.View.extend({
      el: componentName,
      initialize: function initialize(client, options) {
        var _this = this;

        this.client = client;
        Object.keys(options || {}).forEach(function (propertyName) {
          _this[propertyName] = options[propertyName];
        });
      }
    });

    // Define getters/setters so that the View acts as though it were the WebComponent it wraps
    component.properties.forEach(function (propertyDef) {
      Object.defineProperty(view.prototype, propertyDef.propertyName, {
        set: function set(value) {
          this.$el[0][propertyDef.propertyName] = value;
        },
        get: function get() {
          return this.$el[0][propertyDef.propertyName];
        }
      });
    });
  });
  return libraryResult;
}

module.exports = initBackbone;
_base2.default.addAdapter('backbone', initBackbone);
},{"../base":14}],13:[function(require,module,exports){
/**
 * Call this function to initialize all of the react components needed to handle the Layer UI for Web widgets.
 *
 * Before using this, please note that layerUI.init() must be called prior to calling layerUI.adapters.react().
 *
 * Initialize with:
 *
 * ```
 * import React from 'react';
 * import ReactDom from 'react-dom';
 * const { ConversationPanel, ConversationList, UserList, Notifier } = layerUI.adapters.react(React, ReactDom);
 * ```
 *
 * Calling this will expose the following React Components:
 *
 * * ConversationPanel: A wrapper around a layerUI.components.ConversationPanel
 * * ConversationsList: A wrapper around a layerUI.components.ConversationsListPanel
 * * IdentitiesList: A wrapper around a layerUI.components.IdentitiesListPanel
 * * Notifier: A wrapper around a layerUI.components.misc.Notifier
 * * SendButton: A wrapper around a layerUI.components.subcomponents.SendButton
 * * FileUploadButton: A wrapper around a layerUI.components.subcomponents.FileUploadButton
 *
 * You can then use:
 *
 * ```
 * render() {
 *    return <ConversationList
 *      composeButtons={SendButton, FileUploadButton}
 *      onConversationSelected={this.mySelectHandler}></ConversationList>
 * }
 * ```
 *
 * To insure that LayerUI.init() is called before layerUI.adapters.react(), and each is only called once, we
 * recommend puttings this code in its own module:
 *
 * ```
 * import React, { Component, PropTypes } from 'react';
 * import ReactDom from 'react-dom';
 * import Layer from 'layer-websdk';
 * import * as LayerUI from 'layer-ui-web';
 *
 * LayerUI.init({
 *   appId: 'layer:///apps/staging/my-app-id',
 *   layer: Layer
 * });
 * const LayerUIWidgets = LayerUI.adapters.react(React, ReactDom);
 * module.exports = LayerUIWidgets;
 * ```
 *
 * Now anywhere you need access to the LayerUIWidgets library can import this module and expect everything to
 * evaluate at the correct time, correct order, and only evaluate once.
 *
 * @class layerUI.adapters.react
 * @singleton
 * @param {Object} React - Pass in the reactJS library
 * @param {Object} ReactDom - Pass in the ReactDom library
 */'use strict';

var _base = require('../base');

var _base2 = _interopRequireDefault(_base);

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var libraryResult = void 0;
function initReact(React, ReactDom) {
  if (libraryResult) return libraryResult;
  libraryResult = {};

  // Gather all UI Components flagged as Main Components; other components don't require special React Components for direct use.
  Object.keys(_base2.default.components).filter(function (componentName) {
    var component = _base2.default.components[componentName];
    return component.properties.filter(function (prop) {
      return prop.propertyName === '_isMainComponent';
    }).length;
  }).forEach(function (componentName) {
    var component = _base2.default.components[componentName];

    // Get the camel case Component name
    var className = (componentName.substring(0, 1).toUpperCase() + componentName.substring(1).replace(/-(.)/g, function (str, value) {
      return value.toUpperCase();
    })).replace(/^Layer/, '');

    libraryResult[className] = React.createClass({
      /**
       * On mounting, copy in all properties, and optionally setup a Query.
       *
       * Delay added to prevent Webcomponents property setters from being blown away in safari and firefox
       */
      componentDidMount: function componentDidMount() {
        var _this = this;

        // Get the properties/attributes that match those used in this.props
        var props = component.properties.filter(function (property) {
          return _this.props[property.propertyName] || _this.props[property.attributeName];
        });

        // Set the webcomponent properties
        props.forEach(function (propDef) {
          var value = propDef.propertyName in _this.props ? _this.props[propDef.propertyName] : _this.props[propDef.attributeName];
          if (propDef.type === HTMLElement && value) {
            value = _this.handleReactDom(propDef, value);
          }
          _this.node[propDef.propertyName] = value;
        });

        // Browsers running the polyfil may not yet have initialized the component at this point.
        // Force them to be initialized so that by the time the parent component's didComponentMount
        // is called, this will be an initialized widget.
        if (!this.node._onAfterCreate) {
          var evt = document.createEvent('CustomEvent');
          evt.initCustomEvent('HTMLImportsLoaded', true, true, null);
          document.dispatchEvent(evt);
        }
        this.node._onAfterCreate();
      },


      /**
       * Copy all properties into the dom node, but never let React recreate this widget.
       */
      shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
        var _this2 = this;

        // Get the properties/attributes that match those used in this.props
        var props = component.properties.filter(function (property) {
          return _this2.props[property.propertyName] || _this2.props[property.attributeName];
        });

        // Set the webcomponent properties if they have changed
        props.forEach(function (propDef) {
          var name = propDef.propertyName in _this2.props ? propDef.propertyName : propDef.attributeName;
          var value = nextProps[name];
          if (propDef.type === HTMLElement && value) {
            value = _this2.handleReactDom(propDef, value);
          }

          if (value !== _this2.props[name]) {
            _this2.node[propDef.propertyName] = value;
          }
        }, this);
        return false;
      },
      handleReactDom: function handleReactDom(propDef, value) {
        if (!this.layerUIGeneratedNodes) this.layerUIGeneratedNodes = {};

        if (Array.isArray(value)) {
          var array = [];
          if (!this.layerUIGeneratedNodes[propDef.propertyName]) {
            this.layerUIGeneratedNodes[propDef.propertyName] = array;
          }
          array.length = value.length;
          value.forEach(function (item, index) {
            if (item.tagName) {
              array[index] = item;
            } else {
              var node = array[index] || document.createElement('div');
              ReactDom.render(typeof item === 'function' ? React.createElement(item) : item, node);
              array[index] = node;
            }
          });
        } else if (value.tagName === undefined) {
          if (!this.layerUIGeneratedNodes[propDef.propertyName]) {
            this.layerUIGeneratedNodes[propDef.propertyName] = document.createElement('div');
          }
          ReactDom.render(value, this.layerUIGeneratedNodes[propDef.propertyName]);
        }
        return this.layerUIGeneratedNodes[propDef.propertyName];
      },
      render: function render() {
        var _this3 = this;

        return React.createElement(componentName, { ref: function ref(node) {
            _this3.node = node;
          } });
      }
    });
  });
  return libraryResult;
}

module.exports = initReact;
_base2.default.addAdapter('react', initReact);
},{"../base":14,"layer-websdk":79}],14:[function(require,module,exports){
/**
 * @class layerUI
 * @static
 *
 * The layerUI contains utilities for working with the layerUI components.
 *
 * The key method to know here is the `init()` method.  Any use of the library will need a call:
 *
 * ```
 * layerUI.init({
 *   appId: 'layer:///apps/staging/my-app-id'
 * });
 * ```
 *
 * Or
 *
 * layerUI.init({
 *   appId: 'layer:///apps/staging/my-app-id'
 * });
 * ```
 *
 * See layerUI.settings for more options to layerUI.init.
 *
 * One other property deserving special mention: layerUI.adapters.  Adapters help you to use these widgets within other UI frameworks.
 * It is not required to use an adapter, but it solves many inconsistencies in how these frameworks handle webcomponents built using this framework.
 *
 * While there are many other methods defined here, for new projects ignore everything except layerUI.settings, layerUI.init and layerUI.adapters.
 */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * NOTES TO MAINTAINER:
 *
 * * Avoid using `this`, rather use `layerUI` instead.  Otherwise usage such as:
 *   `import { registerMessage} from 'layer-ui-web'` will give developers a method that
 *   needs scope but won't have it.
 */
var layerUI = {};

/**
 * The settings object stores a hash of configurable properties to change widget Behaviors.
 *
 * The settings object is typically set using layerUI.init().
 *
 * Below are the available settings and their defintions.
 *
 * @property {Object} settings
 *
 * @property {String} [settings.appId]      The app ID to use for all webcomponents.
 *    Setting this is a short-hand for using the `app-id` property on each widget;
 *    you can leave out `app-id` if using this setting.
 *
 * @property {Number} [settings.messageGroupTimeSpan=30,0000]   Messages are grouped based on sender,
 *    as well as time between when Messages are sent
 *    How much time must pass before messages are no longer in the same group? Measured in miliseconds.
 *
 * @property {Boolean} [settings.disableTabAsWhiteSpace=false]   By default hitting TAB in the Composer adds space.
 *    Disable this for tab to go to next component.
 *
 * @property {Number} [settings.markReadDelay=2500]    Delay before marking a Message as read.
 *    This property configures the number of miliseconds to wait after a message becomes visible
 *    before its marked as read.  A value too small means it was visible but the user may not
 *    have actually had time to read it as it scrolls quickly past.
 *
 *    The above code will prevent the `layer-avatar` widget
 *    from being initialized, and allow you to provide your own definition for this html tag.  Your definition
 *    must be registered using the WebComponents `document.registerElement` call.  Call `registerElement` after loading layerUI
 *    because layerUI contains the WebComponents polyfills.
 *
 * @property {Object} [settings.defaultHandler]    The default message renderer for messages not matching any other handler
 * @property {String[]} [settings.textHandlers=['autolinker', 'emoji', 'images', 'newline', 'youtube']] Specify which text handlers you want
 *    Note that any custom handlers you add do not need to be in the settings, they can be called after calling `init()` using layerUI.registerTextHandler.
 * @property {Object} [settings.maxSizes]  The maximum width/height for image and video previews
 * @property {Object} [settings.verticalMessagePadding=0]  Message handlers that must hard code a height into their dom nodes can be
 *     hard to add borders and padding around.  Use this property to offset any hardcoded height by this number of pixels
 */

layerUI.settings = {
  appId: '',
  messageGroupTimeSpan: 1000 * 60 * 30,
  disableTabAsWhiteSpace: false,
  markReadDelay: 2500,
  defaultHandler: {
    tagName: 'layer-message-unknown'
  },
  textHandlers: ['autolinker', 'emoji', 'images', 'newline', 'youtube'],
  maxSizes: { width: 512, height: 512 },
  verticalMessagePadding: 0
};

/**
 * Array of message handlers.  See layerUI.registerMessageHandler.
 *
 * @property {Object[]} handlers
 * @private
 */
layerUI.handlers = [];

/**
 * Hash of Text Handlers.  See layerUI.registerTextHandler.
 *
 * @property {Object} handlers
 * @private
 */
layerUI.textHandlers = {};

/**
 * Hash of components defined using layerUI.components.Component.
 *
 * @property {Object} components
 * @private
 */
layerUI.components = {};

/**
 * Any utilities that need global access will be added here.
 *
 * Utils object has no built-in properties, but rather components in the utils
 * folder will register their utilities here to simplify access to CDN users.
 *
 * @property {Object} utils
 */
layerUI.utils = {};

/**
 * Utility for getting a node for use in List Item `customNodeAbove` and `customNodeBelow`
 *
 * ```
 * if (!listItem.customNodeAbove) {
 *    var node = layerUI.createItemSeparator();
 *    node.appendChild(newSeparatorContent);
 *    listItem.customNodeAbove = node;
 * }
 * ```
 * @method createItemSeparator
 * @returns HTMLElement
 */
layerUI.createItemSeparator = function () {
  var node = document.createElement('div');
  node.classList.add(layerUI.itemSeparatorParentClassName);
  return node;
};

/**
 * Class to use with layerUI.createItemSeparator() created ndoes
 *
 * @property {String} [itemSeparatorParentClassName=layer-list-item-separator-parent]
 */
layerUI.itemSeparatorParentClassName = 'layer-list-item-separator-parent';

/**
 * Adds a separator between list items.
 *
 * While one can directly assign a node to `listItem.customNodeAbove`, there may be many processes that run
 * and which consider adding content between two list items. To do this, there should be a parent container,
 * as well as the ability to find this content and remove it from that parent container.
 *
 * ```
 * layerUI.addListItemSeparator(messageListItem, 'You have read up to here', 'layer-item-separator-read-indicator', true);
 * ```
 *
 * Or
 *
 * ```
 * var node = document.createElement('div');
 * node.innerHTML = 'You have read up to here';
 * layerUI.addListItemSeparator(messageListItem, node, 'layer-item-separator-read-indicator', true);
 * ```
 *
 * Both of these calls will result in `messageListItem.customNodeAbove` looking like:
 *
 * ```
 * <div class='layer-list-item-separator-parent'>
 *     <div class='layer-item-separator-read-indicator'>
 *         You have read up to here
 *     </div>
 * </div>
 * ```
 *
 * @method addListItemSeparator
 * @param {layerUI.mixins.ListItem} listItem    The List Item that the separator is associated with
 * @param {String/HTMLElement} content          The content to put in the separator
 * @param {String} contentClass                 Create a div with this class to put the content into; this allows us to see
 *                                               if there is already a node of that class.
 * @param {Boolean} isAboveItem                 If true, `listItem.customNodeAbove` is used, else `listItem.customNodeBelow`
 */
layerUI.addListItemSeparator = function addListItemSeparator(listItemNode, content, contentClass, isAboveItem) {
  var nodeName = isAboveItem ? 'customNodeAbove' : 'customNodeBelow';
  var node = void 0;

  if (content) {
    node = document.createElement('div');
    node.classList.add(contentClass);
  }

  if (content) {
    if (typeof content === 'string') {
      node.innerHTML = content;
    } else {
      node.appendChild(content);
    }
  }

  // If there is already a layer-list-item-separator-parent, then we just need to make sure it has this content
  if (listItemNode[nodeName] && node) {
    // If it looks like the content already exists, replace it
    var existingContent = listItemNode[nodeName].querySelector('.' + contentClass);
    if (existingContent) {
      existingContent.parentNode.replaceChild(node, existingContent);
    } else {
      listItemNode[nodeName].appendChild(node);
    }
  } else if (!listItemNode[nodeName] && node) {
    // Create a parent node and then add this to it
    var parent = layerUI.createItemSeparator();
    parent.appendChild(node);
    listItemNode[nodeName] = parent;
  } else if (listItemNode[nodeName] && !node) {
    var _existingContent = listItemNode[nodeName].querySelector('.' + contentClass);
    if (_existingContent) {
      _existingContent.parentNode.removeChild(_existingContent);
    }
  }
};

/**
 * A library of adapters for working with various Javascript frameworks.
 *
 * The following adapters are provided built-in:
 *
 * * layerUI.adapters.react
 * * layerUI.adapters.angular (Angular 1.x; does not handle Angular 2.x)
 * * layerUI.adapters.backbone
 *
 * @property {Object} adapters
 */
var adapterError = 'You must call layerUI.init() before you can use an adapter';
layerUI.adapters = {
  angular: function angular() {
    throw new Error(adapterError);
  },
  backbone: function backbone() {
    throw new Error(adapterError);
  },
  react: function react() {
    throw new Error(adapterError);
  }
};

/**
 * Provide a handler for a message containing a specific set of mimeTypes.
 *
 * Your testFunction will return true if it handles the input message.
 * Handlers are evaluated in the order they are registered, so if you have
 * multiple handlers that handle a specific combination of parts, put the default
 * one first.  Handlers can be reordered by directly accessing and manipulating the layerUI.handlers array.
 *
 * ```
 * layerUI.registerMessageHandler({
 *     tagName: 'text-image-location-part',
 *     label: 'Map',
 *     handlesMessage: function(message, container) {
 *       return (message.parts.length === 3 && message.parts[0].mimeType.match(/image\/jpeg/ && message.parts[1].mimeType === 'text/plain' && message.parts[2].mimeType === 'location/json');
 *    }
 * });
 * ```
 *
 * This example will create a `<text-image-locaton-part />` dom node to process any message with 3 parts:
 * an image/jpeg, text/plain and location/json parts.  Note that its up to your application to define a webcomponent for `text-image-location-part`
 * which receives the Message using its `item` property.
 *
 * Note that you can use the `container` argument to prevent some types of content from rendering as a Last Message within a Conversation List,
 * or use it so some MessageLists render things differently from others.
 *
 * @method registerMessageHandler
 * @static
 * @param {Object} options
 * @param {Function} options.handlesMessage
 * @param {layer.Message} options.handlesMessage.message    Message to test and handle with our handler if it matches
 * @param {HTMLElement} options.handlesMessage.container     The container that this will be rendered within; typically identifies a specific
 *                                                          layerUI.MessageList or layerUI.ConversationItem.
 * @param {Boolean} options.handlesMessage.returns          Return true to signal that this handler accepts this Message.
 * @param {String} options.tagName                          Dom node to create if this handler accepts the Message.
 * @param {String} options.label                            Label to show when we can't render the whole message.
 *                                                          Typically identifies the type of content to the user.
 * @param {Number} [options.order=0]                        Some handlers may need to be tested before other handlers to control which one gets
 *                                                          selected; Defaults to order=0, this handler is first
 */
layerUI.registerMessageHandler = function registerMessageHandler(options) {
  if (!options.order) options.order = 0;
  var pushed = false;
  for (var i = 0; i < layerUI.handlers.length; i++) {
    if (options.order <= layerUI.handlers[i].order) {
      layerUI.handlers.splice(i, 0, options);
      pushed = true;
      break;
    }
  }
  if (!pushed) layerUI.handlers.push(options);
};

/**
 * Return the handler object needed to render this Message.
 *
 * This function calls the `handlesMessage` call for each handler registered via layerUI.registerMessageHandler and
 * returns the first handler that says it will handle this Message.
 *
 * @method getHandler
 * @static
 * @param {layer.Message} message
 * @param {HTMLElement} container     The container that this will be rendered within
 * @return {Object} handler     See layerUI.registerMessageHandler for the structure of a handler.
 */
layerUI.getHandler = function (message, container) {
  var handlers = layerUI.handlers.filter(function (handler) {
    return handler.handlesMessage(message, container);
  });
  return handlers[0] || layerUI.settings.defaultHandler;
};

/**
 * Provide a text processor for a `text/plain` message.
 *
 * There is a lot of preprocessing of text that may need to be done before rendering text:
 *
 * * Replacing `\n` with `<br/>`
 * * Turning emoticons symbols into images
 * * Replacing image URLs with image tags
 * * Adding HTML formatting around quoted text
 * * Replacing youtube links with youtube videos
 * * Make up your own...
 *
 * You can enable a predefined Text Handler with:
 *
 * ```
 * layerUI.registerTextHandler({
 *    name: 'emoji'
 * });
 * ```
 *
 * You can define your own handler (defaults to enabled) with:
 *
 * ```
 * layerUI.registerTextHandler({
 *    name: 'youtube',
 *    order: 200,
 *    handler: function(textData, message) {
 *    textData.text = textData.text.replace(/https:\/\/(www\.)?(youtu\.be|youtube\.com)\/(watch\?.*v=)?([a-zA-Z0-9\-]+)/g, function(ignore1, ignore2, ignore3, ignore4, videoId) {
 *       return '<iframe width="560" height="315" src="https://www.youtube.com/embed/' + videoId + '" frameborder="0" allowfullscreen></iframe>';
 *   });
 * });
 * ```
 *
 * @method registerTextHandler
 * @static
 * @param {Object} options
 * @param {String} options.name      A unique name to give your handler
 * @param {Number} options.order     A number used to sort your handler amongst other handlers as order
 *      of execution can matter for any text handler that modifies the text parsed by subsequent parsers.
 * @param {Function} options.handler
 * @param {Object} options.handler.textData
 * @param {String} options.handler.textData.text          Use this to read the current text value and write an update to it
 * @param {String[]} options.handler.textData.afterText   Append elements to this array to add stuff to be rendered below the text.
 *      Anything that goes into `afterText` should NOT be parsed by any text handler.
 * @param {layer.Message} options.handler.message         If your text processor needs access to the original message, this is it, but should be treated as a read-only object in this context.
 * @param {Boolean} [requiresEnable=false]                If provided, this registers the handler but won't use the handler
 *       without a separate call to opt in.  Opt in later using with `layerUI.registerTextHandler({name: handlerName})`
 *       and no handler function.  (For Internal use only)
 */
layerUI.registerTextHandler = function registerTextHandler(options) {
  if (layerUI.textHandlers[options.name]) {
    if (options.handler) {
      Object.keys(options).forEach(function (optionKey) {
        layerUI.textHandlers[options.name][optionKey] = options[optionKey];
      });
    } else {
      layerUI.textHandlers[options.name].enabled = true;
    }
  } else {
    options.enabled = !options.handler || !options.requiresEnable;
    if (!('order' in options)) options.order = 100000;
    layerUI.textHandlers[options.name] = options;
  }
};

/**
 * Register your template for use by an existing Component.
 *
 * Assumes that the specified Component has already been defined using layerUI.components.Component.
 *
 * This can be used to associate a template with the Component, or to overwrite the default template
 * with your custom template.
 *
 * Consider this `avatar.html` file:
 *
 * ```
 *
 * <template>
 *    <style>....</style>
 *    <img></img>
 * </template>
 * < script >
 *    // Register the template in this *.html file to be the layer-avatar template.
 *    window.layerUI.registerTemplate('layer-avatar')
 * </script>
 *
 * ```
 *
 * The call to layerUI.registerTemplate will find the template tag in avatar.html, and associate it with `layer-avatar`.
 *
 * NOTE: the above code assumes that `layerUI` has been attached to `window`; accessing `layerUI` from a template file may otherwise pose challenges.
 *
 * One can also register a template that wasn't created in a standalone template file such as `avatar.html`:
 *
 * * One could create a template using `document.createElement('template')`
 * * One could create a template by putting `<template id='my-avatar'>` within your index.html
 *
 * For these cases, you would need to pass a pointer to that template into `registerTemplate`:
 *
 * ```
 * var template = document.createElement('template');
 * template.innerHTML = '<img></img>';
 * layerUI.registerTemplate('layer-avatar', template);
 *
 * // OR
 * layerUI.registerTemplate('layer-avatar', document.getElementById('my-avatar');
 * ```
 *
 * Note that any styles you write for your template will require the tag-name to be a part of your CSS rules.
 * For those familiar with Shadow Dom and how it simplifies your CSS, we are **not** using Shadow Dom; these CSS
 * rules can affect everything on your page.
 *
 * @method registerTemplate
 * @static
 * @param {String} className                The tag name for the widget your setting the template for; 'layer-avatar'
 * @param {HTMLTemplateElement} [template]  Template node to register.  If none provided, will check the ownerDocument for a template.
 */
layerUI.registerTemplate = function registerTemplate(className, template) {
  if (!template) template = document._currentScript.ownerDocument.querySelector('template');

  // Since we aren't doing shadowDOM, and we don't want to insert the template <style/> tag a thousand times
  // for repeated components, remove the style from the template, and instead cache the styles in
  var styleMatches = template.innerHTML.match(/<style>([\s\S]*?)<\/style>/);
  var styles = styleMatches && styleMatches[1];
  if (styles) {
    template.innerHTML = template.innerHTML.replace(/<style>[\s\S]*?<\/style>/, '');
  }

  // Write template and style as static properties of the Component.
  layerUI.components[className].template = template;
  layerUI.components[className].style = styles;
  template.setAttribute('layer-template-registered', 'true');
};

/**
 * Register this template by passing in a string representation of the template.
 *
 * This is comparable to layerUI.registerTemplate except that
 *
 * 1. Instead of taking as input an HTMLTemplateElement, it instead takes a string containing the HTML for the template.
 * 2. Styles should have been removed from the string before calling this; failure to do so will cause the style to be added to your document
 * once per instanceo of this element.  Having 100 of the same style blocks can be a nuisance.
 *
 * @method buildAndRegisterTemplate
 * @static
 * @protected
 * @param {String} className          The tag name for the widget your setting the template for; 'layer-avatar'
 * @param {String} templateStr        Template string to register.
 */
layerUI.buildAndRegisterTemplate = function buildTemplate(className, templateStr) {

  // Generate a template node
  var template = document.createElement('template');
  template.innerHTML = templateStr;

  // Write it as a static property of the Component
  layerUI.components[className].template = template;
  template.setAttribute('layer-template-registered', 'true');
};

/**
 * Add the style for the template by passing in a string representation of the CSS rules.
 *
 * You do NOT need to call this if using layerUI.registerTemplate.
 *
 * This is comparable to layerUI.registerTemplate except that It only handles styles, not the template itself.
 *
 * @method buildStyle
 * @static
 * @protected
 * @param {String} className           The tag name for the widget your setting the template for; 'layer-avatar'
 * @param {String} styleStr            Style string to associate with this component.  Specifically, expects the output of `Function.toString()`
 */
layerUI.buildStyle = function buildStyles(className, styleStr) {
  layerUI.components[className].style = styleStr;
};

/**
 * Turn a hyphenated name into a camel case name.
 *
 * @method camelCase
 * @static
 * @param {String} str  a-hyphenated-string
 * @returns {String} aCamelCasedString
 */
layerUI.camelCase = function (str) {
  return str.replace(/-(.)/g, function (match, value) {
    return value.toUpperCase();
  });
};

/**
 * Turn a camel case name into a hyphenated name
 *
 * @method hyphenate
 * @static
 * @param {String} aCamelCasedString
 * @returns {String} a-hyphenated-string
 */
var regexHyphenate = /([a-z])([A-Z])/g;
layerUI.hyphenate = function (str) {
  return str.replace(regexHyphenate, function (match, part1, part2) {
    return part1 + '-' + part2.toLowerCase();
  });
};

/**
 * Utility returns whether or not the window is in the background.
 *
 * @method isInBackground
 * @static
 * @returns {Boolean}
 */
layerUI.isInBackground = function () {
  return !document.hasFocus() || document.hidden;
};

/**
 * An adapter is a bit of JS Framework specific code for making this framework work with other UI Frameworks.
 *
 * See layerUI.adapters for examples.
 *
 * An adapter does not need to be registered via `addAdapter` to be used, but doing so makes it available to anyone using this framework.
 *
 * ```
 * layerUI.addAdapter('my-odd-js-framework', function() {....});
 * ```
 *
 * @method addAdapter
 * @static
 * @param {String} name      Name of the adapter. Namespaces it within layerUI.adapters
 * @param {Function} adapter The adapter to make available to apps
 */
layerUI.addAdapter = function (name, adapter) {
  layerUI.adapters[name] = adapter;
};

/**
 * Call init with any custom settings, and to register all components with the dom.
 *
 * Note that `init()` must be called prior to putting any webcomponents into a document.
 *
 * Note as well that if passing in your appId, you must have instantiated a layer.Client with that appId
 * prior to putting any webcomponents into your document.
 *
 * ```javascript
 * layerUI.init({
 *   appId: 'layer:///apps/staging/my-app-id'
 * });
 * ```
 *
 * See layerUI.settings for more options to layerUI.init.
 *
 * @method init
 * @static
 * @param {Object} settings     list any settings you want changed from their default values.
 * @param {Object} mixins       hash of component names with mixins to add to the component
 */
layerUI.init = function init(settings) {
  // No-op -- see layer-ui.js
};

/**
 * Layer UI for Web version string
 *
 * @type {String}
 */
layerUI.version = '1.0.0';

var clientVersions = _layerWebsdk2.default.Client.version.split('.').map(function (value) {
  return Number(value);
});
if (clientVersions[0] !== 3 && _layerWebsdk2.default.Client.version !== '3.1.1') {
  console.error('This version or Layer UI for Web requires Layer WebSDK version 3.1.1 or up');
}

/**
 * This method is shorthand for accessing layerUI.components.Component.registerComponent
 *
 * Note: This code is actually in components/component.js and is only attached to layerUI
 * if you require `layer-ui-web/index.js` or just `layer-ui-web`, else you have to directly
 * access it.
 *
 * @method registerComponent
 */

module.exports = layerUI;
},{"layer-websdk":79}],15:[function(require,module,exports){
/**
                                                                                                                                                                                                     * This is the base class for all UI classes in the Layer UI Framework.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * It works with the webcomponent API/polyfill to define components that:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * * Provides getters/setters/defaults for all defined properties
                                                                                                                                                                                                     * * Read the widget's attributes on being initialized, copying them into properties and triggering property setters
                                                                                                                                                                                                     * * Provides created and destroyed callbacks
                                                                                                                                                                                                     * * Provides onReady and onAttach hooks for custom Mixins
                                                                                                                                                                                                     * * Automate standard template-related tasks
                                                                                                                                                                                                     * * Automate standard event-related tasks
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Methods and properties defined here should only be needed by developers wishing to build new widgets or evolve existing widgets.
                                                                                                                                                                                                     * Note that widgets can be created using other frameworks based on the webcomponent polyfill and still work here.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * A new component is created using:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * var componentDefinition = {
                                                                                                                                                                                                     *   events: ['event-one', 'event-two', 'event-three', 'event-four'],
                                                                                                                                                                                                     *   mixins: [mixinObj1, mixinObj2, mixinObj3],
                                                                                                                                                                                                     *   properties: {
                                                                                                                                                                                                     *      prop1: {
                                                                                                                                                                                                     *          set: function(value) {
                                                                                                                                                                                                     *              this.myRenderer();
                                                                                                                                                                                                     *          }
                                                                                                                                                                                                     *      },
                                                                                                                                                                                                     *      prop2: {
                                                                                                                                                                                                     *          get: function() {
                                                                                                                                                                                                     *              return this.scrollTop;
                                                                                                                                                                                                     *          }
                                                                                                                                                                                                     *      },
                                                                                                                                                                                                     *      prop3: {
                                                                                                                                                                                                     *          value: "Frodo is a Dodo"
                                                                                                                                                                                                     *      },
                                                                                                                                                                                                     *      prop4: {
                                                                                                                                                                                                     *          type: Function
                                                                                                                                                                                                     *      }
                                                                                                                                                                                                     *   },
                                                                                                                                                                                                     *   methods: {
                                                                                                                                                                                                     *     onCreate: function() {
                                                                                                                                                                                                     *        alert("The widget has been created");
                                                                                                                                                                                                     *     },
                                                                                                                                                                                                     *     myRenderer: function() {
                                                                                                                                                                                                     *        this.innerHTML = this.properties.prop1;
                                                                                                                                                                                                     *     }
                                                                                                                                                                                                     *   }
                                                                                                                                                                                                     * };
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * A component defined this way can be registered as follows:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * var layerUI = require('layer-ui-web');
                                                                                                                                                                                                     * layerUI.registerComponent(tagName, componentDefinition);
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ### Properties
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * A property definition can be as simple as:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * layerUI.registerComponent(tagName, {
                                                                                                                                                                                                     *    properties: {
                                                                                                                                                                                                     *       prop1: {}
                                                                                                                                                                                                     *    }
                                                                                                                                                                                                     * });
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * The above code declares `prop1` to be a property, sets up a setter that writes `widget.properties.prop1` any time `widget.prop1` is set,
                                                                                                                                                                                                     * and sets up a getter to read the value from `widget.properties.prop1`.  It also insures that at initialization time, if a `prop1` attribute
                                                                                                                                                                                                     * is found, it will be used as the `prop1` property.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Property Definitions support the following keys:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * *  set: A setter function whose input is the new value.  Note that your setter function is called AFTER this.properties.propName
                                                                                                                                                                                                     *    has been set with the new value; your setter is for any side effects, rendering updates, or additional processing and NOT
                                                                                                                                                                                                     *    for writing the value itself.
                                                                                                                                                                                                     * *  get: A getter is needed if getting the property value from `this.properties.propName` is not getting the latest value.
                                                                                                                                                                                                     *    Perhaps you want to return `this.nodes.input.value` to get text typed in by a user.
                                                                                                                                                                                                     * *  value: If a `value` key is provided, then this will be the default value of your property, to be used if a value is
                                                                                                                                                                                                     *    not provided by the component creator.
                                                                                                                                                                                                     * *  type: Currently accepts `Boolean`, `Number`, `Function`.  Using a type makes the system
                                                                                                                                                                                                     *    more forgiving when processing strings.  This exists because attributes frequently arrive as strings due to the way HTML attributes work.
                                                                                                                                                                                                     *    For example:
                                                                                                                                                                                                     *    * if type is Boolean, and "false", "null", "undefined", "" and "0" are evaluated as `false`; all other values are `true`
                                                                                                                                                                                                     *    * Using this with functions will cause your function string to be evaled, but will lose your function scope and `this` pointer.
                                                                                                                                                                                                     *    * Using this with a number will turn "1234" into `1234`
                                                                                                                                                                                                     * *  noGetterFromSetter: Do **not** use the getter function from within the setter.  Used for special cases where
                                                                                                                                                                                                     *    you have a getter that calculates the values, but where your setter should just make do with the last known value
                                                                                                                                                                                                     *    when determining if the value has changed.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Example
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *  isEnabled: {
                                                                                                                                                                                                     *    type: Boolean,
                                                                                                                                                                                                     *    value: true,
                                                                                                                                                                                                     *    set: function(inValue) {
                                                                                                                                                                                                     *       this.classList.toggle('widget-enabled', inValue);
                                                                                                                                                                                                     *    },
                                                                                                                                                                                                     *    get: function() {
                                                                                                                                                                                                     *       return this.classList.contains('widget-enabled');
                                                                                                                                                                                                     *    }
                                                                                                                                                                                                     * }
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ### Events
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * As part of your layerUI.components.Component.registerComponents call you can pass in an `events` array; this is an array of strings representing events to listen for,
                                                                                                                                                                                                     * and provide as property-based event listeners.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Example:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * layerUI.registerComponent(tagName, {
                                                                                                                                                                                                     *    events: ['layer-something-happening', 'layer-nothing-happening', 'your-custom-event']
                                                                                                                                                                                                     * });
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * The above component definition will result in:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * 1. The component will listen for the 3 events listed, regardless of whether this component triggered the event,
                                                                                                                                                                                                     *    or its child components triggered the event.
                                                                                                                                                                                                     * 2. The component will define the following properties: `onSomethingHappening`, `onNothingHappening` and `onYourCustomEvent`. These properties
                                                                                                                                                                                                     *    are defined for you, you do not need to do anything more than list the events in the events array.
                                                                                                                                                                                                     * 3. Your app can now use either event listeners or property callbacks as illustrated below:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Event Listeners:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * document.body.addEventListener('layer-something-happening', myFunc);
                                                                                                                                                                                                     * document.body.addEventListener('layer-nothing-happening', myFunc);
                                                                                                                                                                                                     * document.body.addEventListener('your-custom-event', myFunc);
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Property callbacks:
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * widget.onSomethingHappening = myFunc;
                                                                                                                                                                                                     * widget.onNothingHappening = myFunc;
                                                                                                                                                                                                     * widget.onYourCustomEvent = myFunc;
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ### Methods
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * You may provide any methods you want within the `methods` hash; be aware though that some methods names
                                                                                                                                                                                                     * are reserved for use by the framework, and some have specific life-cycle implications for the widget.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * #### Reserved
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * The following method names are reserved:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * * `createdCallback`
                                                                                                                                                                                                     * * `attachedCallback`
                                                                                                                                                                                                     * * `detachedCallback`
                                                                                                                                                                                                     * * `attributeChangedCallback`
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ### Mixins
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Mixins can be added to a widget in two ways:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * * A Component may add a `mixins` array to its definition
                                                                                                                                                                                                     * * An Application, initializing the framework via `layerUI.init()` may pass in mixins into the `init` call.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * #### Using Mixins from the Component
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * A component can include any number of Mixins by adding them to the `mixins` Array:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * // Define a Mixin that can contains `properties`, `methods` and `events`:
                                                                                                                                                                                                     * var mixinObj = {
                                                                                                                                                                                                     *   properties: {
                                                                                                                                                                                                     *     prop2: {}
                                                                                                                                                                                                     *   },
                                                                                                                                                                                                     *   methods: {
                                                                                                                                                                                                     *     method2: function() {
                                                                                                                                                                                                     *       alert("I two Met Hed; he was a little nerdy");
                                                                                                                                                                                                     *     }
                                                                                                                                                                                                     *   }
                                                                                                                                                                                                     * });
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * // Add mixinObj to our Component
                                                                                                                                                                                                     * var componentDefinition = {
                                                                                                                                                                                                     *   mixins: [mixinObj],
                                                                                                                                                                                                     *   properties: {
                                                                                                                                                                                                     *      prop1: {
                                                                                                                                                                                                     *          set: function(value) {
                                                                                                                                                                                                     *              this.myRenderer();
                                                                                                                                                                                                     *          }
                                                                                                                                                                                                     *      }
                                                                                                                                                                                                     *   },
                                                                                                                                                                                                     *   methods: {
                                                                                                                                                                                                     *     method1: function() {
                                                                                                                                                                                                     *       alert("I Met Hed; he was nice");
                                                                                                                                                                                                     *     }
                                                                                                                                                                                                     *   }
                                                                                                                                                                                                     * });
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * // Create a Component with prop1, prop2, method1 and method2
                                                                                                                                                                                                     * registerComponent(tagName, componentDefinition);
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * An app can modify an existing component by adding custom mixins to it using `layerUI.init()`.  The `mixins` parameter
                                                                                                                                                                                                     * takes as keys, the tag-name for any widget you want to customize;
                                                                                                                                                                                                     * (e.g `layer-messages-item`, `layer-messages-list`, `layer-conversation-panel`, etc...)
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * The following example adds a search bar to the Message List:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * // Define a Mixin that can contains `properties`, `methods` and `events`:
                                                                                                                                                                                                     * var mixinObj = {
                                                                                                                                                                                                     *   properties: {
                                                                                                                                                                                                     *     prop2: {}
                                                                                                                                                                                                     *   },
                                                                                                                                                                                                     *   methods: {
                                                                                                                                                                                                     *     method2: function() {
                                                                                                                                                                                                     *       alert("I two Met Hed; he was a little nerdy");
                                                                                                                                                                                                     *     }
                                                                                                                                                                                                     * });
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * layerUI.init({
                                                                                                                                                                                                     *   appId: 'my-app-id',
                                                                                                                                                                                                     *   mixins: {
                                                                                                                                                                                                     *     'layer-messages-item': mixinObj
                                                                                                                                                                                                     *   }
                                                                                                                                                                                                     * });
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * #### Mixin Behaviors
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Your mixin can be used to:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * * Add new Events to the widget's `events` array (presumably one of your new methods will call `this.trigger('my-event-name')`)
                                                                                                                                                                                                     * * Add new properties
                                                                                                                                                                                                     * * Add new methods
                                                                                                                                                                                                     * * Add new behaviors to existing properties
                                                                                                                                                                                                     * * Add new behaviors to existing methods
                                                                                                                                                                                                     * * Overwrite existing methods
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ##### Adding an Event
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * var mixinObj = {
                                                                                                                                                                                                     *   events: ['mycompany-button-click'],
                                                                                                                                                                                                     *   methods: {
                                                                                                                                                                                                     *     onCreate: function() {
                                                                                                                                                                                                     *       this.nodes.button = document.createElement('button');
                                                                                                                                                                                                     *       this.appendChild(this.nodes.button);
                                                                                                                                                                                                     *       this.nodes.button.addEventListener('click', this._onMyCompanyButtonClick.bind(this));
                                                                                                                                                                                                     *     },
                                                                                                                                                                                                     *     _onMyCompanyButtonClick: function(evt) {
                                                                                                                                                                                                     *       this.trigger('mycompany-button-click', { message: this.item.message });
                                                                                                                                                                                                     *     }
                                                                                                                                                                                                     *   }
                                                                                                                                                                                                     * });
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * When the user clicks on the `this.nodes.button`, it will trigger the `mycompany-button-click` event.  By listing
                                                                                                                                                                                                     * `mycompany-button-click` event in the `events` array, this will automatically add the `onMycompanyButtonClick` property
                                                                                                                                                                                                     * which you can set to your event handler (or you may just use `document.addEventListener('mycompany-button-click', callback)`).
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ##### Add new behaviors to existing properties
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * If you are modifying a widget that has an existing property, and you want additional side effects to
                                                                                                                                                                                                     * trigger whenever that property is set, you can add your own `set` method to the property.
                                                                                                                                                                                                     * Other modifications to the property will be ignored (`value` and `get` from mixin will be ignored).
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * var mixinObj = {
                                                                                                                                                                                                     *   properties: {
                                                                                                                                                                                                     *     client: {
                                                                                                                                                                                                     *       set: function(client) {
                                                                                                                                                                                                     *         this.properties.user = client.user;
                                                                                                                                                                                                     *       }
                                                                                                                                                                                                     *     }
                                                                                                                                                                                                     *   }
                                                                                                                                                                                                     * };
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * The above mixin can be added to any widget;
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * * If the widget already has a `client` property, both the widget's setter and your setter will be called; order of call is not predetermined.
                                                                                                                                                                                                     * * If the widget does *not* already have a `client`, your `client` setter will be called if/when the `client` is set.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * You can use the Mixin to add any method your widget needs.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * You can also use the Mixin to enhance methods already provided by your widget:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * var mixinObj = {
                                                                                                                                                                                                     *   methods: {
                                                                                                                                                                                                     *     onCreate: function() {
                                                                                                                                                                                                     *         var div = document.createElement('div');
                                                                                                                                                                                                     *         this.appendChild(div);
                                                                                                                                                                                                     *       }
                                                                                                                                                                                                     *     }
                                                                                                                                                                                                     *   }
                                                                                                                                                                                                     * };
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * The above mixin can be added to any widget; the widget's `onCreate` method will be called, AND your `onCreate` method will be called, in no
                                                                                                                                                                                                     * particular order.  You an also use the following `mode` values to change ordering:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * * `layerUI.registerComponent.MODES.BEFORE`: Call your mixin's method before the widget's method
                                                                                                                                                                                                     * * `layerUI.registerComponent.MODES.AFTER`: Call your mixin's method after the widget's method
                                                                                                                                                                                                     * * `layerUI.registerComponent.MODES.OVERWRITE`: Call only your mixin's method, *not* the widget's method
                                                                                                                                                                                                     * * `layerUI.registerComponent.MODES.DEFAULT`: Call your mixin's method in no particular order with regards to the widget's methods
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * var mixinObj = {
                                                                                                                                                                                                     *   methods: {
                                                                                                                                                                                                     *     onCreate: {
                                                                                                                                                                                                     *       mode: layerUI.registerComponent.MODES.BEFORE,
                                                                                                                                                                                                     *       value: function() {
                                                                                                                                                                                                     *         var div = document.createElement('div');
                                                                                                                                                                                                     *         this.appendChild(div);
                                                                                                                                                                                                     *       }
                                                                                                                                                                                                     *     }
                                                                                                                                                                                                     *   }
                                                                                                                                                                                                     * });
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * You can also define a `conditional` on your methods; if any `conditional` function returns `false`, then none of the `BEFORE`, `AFTER`, `DEFAULT` or `OVERWRITE` methods are called:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * var mixinObj = {
                                                                                                                                                                                                     *   methods: {
                                                                                                                                                                                                     *     onRender: {
                                                                                                                                                                                                     *       conditional: function() {
                                                                                                                                                                                                     *         return Boolean(this.item);
                                                                                                                                                                                                     *       },
                                                                                                                                                                                                     *       mode: layerUI.registerComponent.MODES.BEFORE,
                                                                                                                                                                                                     *       value: function() {
                                                                                                                                                                                                     *         var div = document.createElement('div');
                                                                                                                                                                                                     *         this.appendChild(div);
                                                                                                                                                                                                     *       }
                                                                                                                                                                                                     *     }
                                                                                                                                                                                                     *   }
                                                                                                                                                                                                     * });
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * For details on what methods to modify via mixins, see the Life Cycle methods
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * #### Life Cycle Methods
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * All widgets should execute the following life cycle methods:
                                                                                                                                                                                                     *
                                                                                                                                                                                                    
                                                                                                                                                                                                    1. `onCreate()`: Your widget has been created.
                                                                                                                                                                                                        * Uses for `onCreate`:
                                                                                                                                                                                                          * Setup event handlers
                                                                                                                                                                                                          * Add custom nodes and properties that do not depend upon property values
                                                                                                                                                                                                          * Setup local variables/state variables.
                                                                                                                                                                                                        * Widget State when `onCreate` is called:
                                                                                                                                                                                                          * If you have a template, it will have been loaded into your widget before `onCreate`, adding any neccessary child nodes
                                                                                                                                                                                                          * `this.nodes` will be setup and point to any nodes in your template that specify a `layer-id`.
                                                                                                                                                                                                          * If your widget was created with any attributes, they _may_ be available in `this.properties` but you should not depend upon them being set yet.
                                                                                                                                                                                                          * No property setters will have been called yet
                                                                                                                                                                                                          * Your widget will not have a `parentNode`
                                                                                                                                                                                                    1. Property Setters: Your property setters will be called with any attributes and/or properties that your widget was initialized with.
                                                                                                                                                                                                       * The following widget `<my-widget prop1='frodo' prop2='dodo'></my-widget>` will call your setter for `prop1`
                                                                                                                                                                                                         with `frodo`, and `prop2` with `dodo`
                                                                                                                                                                                                       * Default property values will be set; a property defined like this: `properties: { prop1: { value: 55, set: function(newValue) {alert('Set!');} } }` will cause the `prop1` setter will be called with `55`
                                                                                                                                                                                                       * Any properties set via `var element = document.createElement('widget'); element.prop1 = 'frodo';` will fire at this point as well.
                                                                                                                                                                                                       * If no attribute value is passed in and no default value is set the `prop1` setter will *not* be called, and the value will be `null`
                                                                                                                                                                                                    1. `onAfterCreate()`: Your widget has been initialized.
                                                                                                                                                                                                        * Uses for `onAfterCreate`:
                                                                                                                                                                                                          * Setup and DOM manipulation that depends upon property values (else it would go in `onCreate`)
                                                                                                                                                                                                          * One time DOM manipulation based on property values that never change.  Any DOM manipulation based on values that change
                                                                                                                                                                                                            would typically go in `onRender` which can be called repeatedly.
                                                                                                                                                                                                        * Widget state when `onAfterCreate` is called:
                                                                                                                                                                                                          * `onCreate` has been called
                                                                                                                                                                                                          * Property setters have all fired
                                                                                                                                                                                                          * `onRender` has **not**  been called
                                                                                                                                                                                                    1. `onRender()`: DOM manipulation based on current property values.
                                                                                                                                                                                                        * Uses for `onRender`:
                                                                                                                                                                                                          * Typically called after a property value changes that would force the widget to rerender.  Note that for very specific and simple DOM changes,
                                                                                                                                                                                                            the property setter may directly update the DOM rather than call `onRender`.
                                                                                                                                                                                                          * Unlike `onAfterCreate`, `onRender` may be called multiple times
                                                                                                                                                                                                          * Note that this is called immediately after `onAfterCreate`,
                                                                                                                                                                                                          * Note that calls to `onRender` from your property setters will beo ignored until `onAfterCreate` has been called.
                                                                                                                                                                                                        * Widget state when `onRender` is called:
                                                                                                                                                                                                          * The first call will be before `onAttach`; subsequent calls may happen before or after this widget has a `parentNode`
                                                                                                                                                                                                          * `onCreate`, all property setters, and `onAfterCreate` have been called.
                                                                                                                                                                                                    1. `onRerender()`: Widgets that render a Layer Web SDK Object listen for changes to the object and call `onRerender` to update rendering
                                                                                                                                                                                                       of things that can change within those objects.  Unlike `onRender` which would let you render an entirely new Message or Conversation,
                                                                                                                                                                                                       `onRerender` would handle changes within the existing Message or Conversation.  `onRerender` is also used when listening for events
                                                                                                                                                                                                       rather than changes to properties.
                                                                                                                                                                                                    1. `onAttach()`: Your widget has been added to a document.
                                                                                                                                                                                                        * Uses for `onAttach`:
                                                                                                                                                                                                          * Your widget needs to know its `parentNode` to modify its rendering.
                                                                                                                                                                                                          * Your widget needs some sizing information to modify its rendering.
                                                                                                                                                                                                        * Widget state when `onAttach` is called:
                                                                                                                                                                                                          * `onRender` will always be called before `onAttach`.
                                                                                                                                                                                                          * `parentNode` should now have a value.
                                                                                                                                                                                                          * Removing this widget from the DOM and then reinserting it _may_ refire this call.  It will Not refire `onRender`.
                                                                                                                                                                                                    1. `onDetach()`: Your widget has been removed from the html document.
                                                                                                                                                                                                    1. `onDestroy()`: Your widget was has been flagged as destroyed.  This happens if it was removed from the HTML Document, and remained out of
                                                                                                                                                                                                       the document for more than a few moments. Use this function to unsubscribe from any custom event listeners you setup for your widget.
                                                                                                                                                                                                    
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * #### Templates
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * There are a number of ways that a template can be registered to your component.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * _Define a full Template while registering Component_:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * var template = document.querySelector('template');
                                                                                                                                                                                                     * layerUI.registerComponent('my-widget', {
                                                                                                                                                                                                     *     template: template
                                                                                                                                                                                                     * });
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * _Define a template string while registering Component_:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Note that unless the `<template/>` node, the template string is assumed to be DOM nodes only, and no `<style/>` blocks.
                                                                                                                                                                                                     * If using a template string, you may separately provide a style string:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * layerUI.registerComponent('my-widget', {
                                                                                                                                                                                                     *     template: '<div><button />Click me</div>',
                                                                                                                                                                                                     *     styles: 'my-widget {display: block}'
                                                                                                                                                                                                     * });
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * _Define a template after defining your component_:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * layerUI.registerComponent('my-widget', {
                                                                                                                                                                                                     * });
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * layerUI.registerTemplate('my-widget', document.querySelector('template'));
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * _Define a template string after defining your component_:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     * layerUI.registerComponent('my-widget', {
                                                                                                                                                                                                     * });
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * layerUI.buildAndRegisterTemplate('my-widget', '<div><button />Click me</div>');
                                                                                                                                                                                                     * ```
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * @class layerUI.components.Component
                                                                                                                                                                                                     */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _base = require('../base');

var _base2 = _interopRequireDefault(_base);

var _stateManager = require('../mixins/state-manager');

var _stateManager2 = _interopRequireDefault(_stateManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } 

/**
 * Register a component using the specified HTML tagName.
 *
 * Note that you may define your components and styles any way you like, you do not need to conform your
 * component structure to the expected input of this function.  This function Does however provide
 * many simplifying capabilities including
 *
 *  * Auto-generation of setters/getters removing unneccessary boilerplate
 *  * Automatic mapping of hyphen-cased properties to camel-case attributes used within your component
 *  * Automatic applying of any property values passed in before your setters could trigger; gaurentees setters trigger after initialization
 *  * Automatic detection and copying of attribute values into properties
 *  * Utilities for managing templates and styles that are seen within `layerUI` all depend upon this structure.
 *
 * @method registerComponent
 * @static
 * @param {String} tagName    Tag name that is being defined (`layer-avatar`)
 * @param {Object} classDef    Definition of your class
 * @param {Object} classDef.properties    Definition of your class properties
 * @param {Object} classDef.methods    Definition of your class methods
 * @param {String[]} classDef.events    Array of events to listen for and repackage as event handler properties
 * @param {Mixed} template     A `<template />` node or a template string such as `<div><button /></div>`
 * @param {String} style       A String with CSS styles for this widget
 */


/*
 * Setup the Real structure needed for the `methods` object, not a hash of functions,
 * but a hash of functions with a `mode` parameter
 */
function setupMethods(classDef, methodsIn) {
  var methods = classDef.methods;
  Object.keys(methodsIn).forEach(function (methodName) {
    if (!methods[methodName]) methods[methodName] = {};
    var methodDef = methods[methodName];
    var methodInDef = methodsIn[methodName];
    if (!methodDef.methodsBefore) {
      methodDef.methodsBefore = [];
      methodDef.methodsAfter = [];
      methodDef.methodsMiddle = [];
      methodDef.conditional = [];
    }
    if (typeof methodInDef === 'function') {
      methodDef.methodsMiddle.push(methodsIn[methodName]);
    } else if (methodInDef.mode === registerComponent.MODES.BEFORE) {
      methodDef.methodsBefore.push(methodsIn[methodName].value);
    } else if (methodInDef.mode === registerComponent.MODES.AFTER) {
      methodDef.methodsAfter.push(methodsIn[methodName].value);
    } else if (methodInDef.mode === registerComponent.MODES.OVERWRITE) {
      methodDef.lock = methodInDef.value;
    } else if (methodInDef.mode === registerComponent.MODES.DEFAULT) {
      methodDef.methodsMiddle.push(methodsIn[methodName].value);
    }
    if (methodInDef.conditional) methodDef.conditional.push(methodInDef.conditional);
  });
}

/*
 * Provides a basic mixin mechanism.
 *
 * Provide an array of objects with a `properties` key and a `methods` key,
 * and all property defintions and method defintions will be copied into your classDef UNLESS your classDef
 * has provided its own definition.
 * If your mixin provides a created() method, it will be called after the classDef created() method is called;
 * this will be called for any number of mixins.
 *
 * If your mixin provides a property that is also defined by your component,
 *
 * @method setupMixin
 * @param {Object} classDef
 * @private
 */
function setupMixin(classDef, mixin) {
  var propNames = Object.keys(mixin.properties || {});

  // Copy all properties from the mixin into the class definition,
  // unless they are already defined.
  propNames.forEach(function (name) {
    if (!classDef['__' + name]) classDef['__' + name] = [];
    classDef['__' + name].push(mixin.properties[name]);

    // Make sure that this becomes a part of the properties definition of the class if the prop
    // isn't already defined.  used by the props array.
    if (!classDef.properties[name]) {
      classDef.properties[name] = mixin.properties[name];
    } else {
      if (mixin.properties[name].order !== undefined && classDef.properties[name].order === undefined) {
        classDef.properties[name].order = mixin.properties[name].order;
      }
      if (mixin.properties[name].value !== undefined && classDef.properties[name].value === undefined) {
        classDef.properties[name].value = mixin.properties[name].value;
      }
      if (mixin.properties[name].propagateToChildren !== undefined && classDef.properties[name].propagateToChildren === undefined) {
        classDef.properties[name].propagateToChildren = mixin.properties[name].propagateToChildren;
      }
    }
  });

  setupMethods(classDef, mixin.methods || {});
}

/*
 * Merge all mixin function definitions into a single function call.
 *
 * @method finalizeMixinMerge
 * @param {Object} classDef
 * @private
 */
function finalizeMixinMerge(classDef) {
  var propNames = Object.keys(classDef.properties || {});
  propNames.forEach(function (name) {
    if (classDef['__' + name]) {

      // NOTE: Modes are currently applied to properties, but we do not yet support OVERWRITE mode.
      var setters = _layerWebsdk2.default.Util.sortBy(classDef['__' + name].filter(function (def) {
        return def.set;
      }), function (setter) {
        switch (setter.mode) {
          case registerComponent.MODES.BEFORE:
            return 1;
          case registerComponent.MODES.AFTER:
            return 3;
          default:
            return 2;
        }
      });
      classDef['__set_' + name] = setters.map(function (setter) {
        return setter.set;
      });
    }
  });

  var methodNames = Object.keys(classDef.methods || {});

  methodNames.forEach(function (methodName) {
    var methodDef = classDef.methods[methodName];
    var methodList = [].concat(_toConsumableArray(methodDef.methodsBefore), _toConsumableArray(methodDef.methodsMiddle), _toConsumableArray(methodDef.methodsAfter));
    if (methodDef.lock) methodList = [methodDef.lock];
    if (methodList.length === 1 && !methodDef.conditional.length) {
      classDef.methods[methodName] = methodList[0];
    } else {
      classDef['__method_' + methodName] = methodList;
      classDef.methods[methodName] = getMethod(classDef, methodDef.conditional, classDef['__method_' + methodName]);
    }
  });
}

function getMethod(classDef, conditionals, methods) {
  return function runMethod() {
    var _this = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var result = void 0;
    for (var i = 0; i < conditionals.length; i++) {
      if (!conditionals[i].apply(this, args)) return;
    }

    methods.forEach(function (method) {
      var resultTmp = method.apply(_this, args);
      if (resultTmp !== undefined) result = resultTmp;
    });
    return result;
  };
}

/*
 * Add all mixin events in, and then call setupEvents on each event
 */
function setupEvents(classDef) {
  classDef.mixins.filter(function (mixin) {
    return mixin.events;
  }).forEach(function (mixin) {
    classDef.events = classDef.events.concat(mixin.events);
  });
  classDef.events.forEach(function (eventName) {
    return setupEvent(classDef, eventName);
  });
}

/*
 * For each event defined in the `events` property, setup an `onXXX` property.
 *
 * The `onXXX` property works by:
 *
 * 1. Doing nothing unless the app sets this event property to a Function
 * 2. Listening for the specified event via addEventListener
 * 3. Calling any provided function with the event provided by addEventListener
 * 4. Call removeEventListener should this property ever change
 *
 * @method setupEvent
 * @private
 * @param {Object} classDef
 * @param {String} eventName
 */
function setupEvent(classDef, eventName) {
  var camelEventName = _base2.default.camelCase(eventName.replace(/^layer-/, ''));
  var callbackName = 'on' + camelEventName.charAt(0).toUpperCase() + camelEventName.substring(1);
  if (!classDef.properties[callbackName]) {
    classDef.properties[callbackName] = {
      type: Function,
      set: function set(value) {
        if (this.properties['old-' + eventName]) {
          this.removeEventListener(eventName, this.properties['old-' + eventName]);
          this.properties['old-' + eventName] = null;
        }
        if (value) {
          this.addEventListener(eventName, value);
          this.properties['old-' + eventName] = value;
        }
      }
    };
  }
}

/*
 * Get an array of property descriptions.
 *
 * @method
 * @private
 * @param {Object} classDef
 */
function getPropArray(classDef) {
  // Translate the property names into definitions with property/attribute names
  return Object.keys(classDef.properties).map(function (propertyName) {
    return {
      propertyName: propertyName,
      attributeName: _base2.default.hyphenate(propertyName),
      type: classDef.properties[propertyName].type,
      order: classDef.properties[propertyName].order,
      noGetterFromSetter: classDef.properties[propertyName].noGetterFromSetter,
      propagateToChildren: classDef.properties[propertyName].propagateToChildren
    };
  }).sort(function (a, b) {
    if (a.order !== undefined && b.order !== undefined) {
      return a.order - b.order;
    } else if (a.order !== undefined) {
      return -1;
    } else if (b.order !== undefined) {
      return 1;
    } else {
      return 0;
    }
  });
}

/*
 * Cast a property value to its specified type
 */
function castProperty(type, value) {
  // Some special handling is needed for some properties as they may be delivered
  // as strings HTML delivers attributes as strings.
  switch (type) {
    // Translate strings into booleans
    case Boolean:
      if (['false', '0', 'null', 'undefined'].indexOf(value) !== -1) {
        return false;
      } else {
        return Boolean(value);
      }

    case Number:
      return Number(value);

    // Translate strings into functions
    case Function:
      return typeof value === 'string' ? eval('(' + value + ')') : value;
  }
  return value;
}

/*
 * Define a single property based on a single property from the Component's `properties` definition.
 *
 * Will setup the properties getter, setter, default value, and type.
 *
 * @method setupProperty
 * @private
 * @param {Object} classDef   The class definition object
 * @param {Object} prop       A property definition as generated by getPropArray
 * @param {Object} propertyDefHash  A hash of all property definitions for use in reflection
 */
function setupProperty(classDef, prop, propertyDefHash) {
  var newDef = {};
  var name = prop.propertyName;
  var propDef = classDef.properties[name];

  // Copy our property definition into our hash of definitions
  // which will be associated with this class for reflection purposes
  propertyDefHash[name] = propDef;

  // If a getter is provided, use it. else provide a getter that returns this.properties[name].
  // However, if the call comes before we have a properties object, this is an initialization phase
  // where we should not yet have properties so return undefined.

  // NOTE: Do not use arrow functions; that will change the "this" pointer.
  newDef.get = function getter() {
    if (this.properties._internalState.disableGetters) {
      return this.properties[name];
    } else {
      return propDef.get ? propDef.get.apply(this) : this.properties[name];
    }
  };

  // The property setter will set this.properties[name] and then if there is a custom setter, it will be invoked.
  // This means that the setter does NOT need to write to this.properties, but can handle side effects, transformations, etc...
  newDef.set = function propertySetter(value) {
    var _this2 = this;

    if (_base2.default.debug) console.log('Set property ' + this.tagName + '.' + name + ' to ', value);

    if (propDef.type) value = castProperty(propDef.type, value);

    var oldValue = prop.noGetterFromSetter ? this.properties[name] : this[name];
    if (oldValue !== value || this.properties._internalState.inPropInit.indexOf(name) !== -1) {

      // can't call setters with this on because the setters will set other properties which should not
      // trigger further setters if there was no actual change
      var initIndex = this.properties._internalState.inPropInit.indexOf(name);
      var wasInit = initIndex !== -1;
      if (wasInit) this.properties._internalState.inPropInit.splice(initIndex, 1);

      this.properties[name] = value;
      if (classDef['__set_' + name] && !this.properties._internalState.disableSetters) {
        classDef['__set_' + name].forEach(function (setter) {
          return setter.call(_this2, value, wasInit ? null : oldValue);
        });
      }

      if (propDef.propagateToChildren) {
        Object.keys(this.nodes).forEach(function (nodeName) {
          _this2.nodes[nodeName][name] = value;
        });
        if (this._isList) {
          var childNodes = this.childNodes;
          var i = void 0;
          for (i = 0; i < childNodes.length; i++) {
            if (childNodes[i]._isListItem) childNodes[i][name] = value;
          }
        }
      }
    }
  };

  // Write the property def to our class that will be passed into document.registerElement(tagName, classDef)
  classDef[name] = newDef;
}

var registerAllCalled = false;
function registerComponent(tagName, classDef) {
  if (!_base2.default.components[tagName]) _base2.default.components[tagName] = {};
  _base2.default.components[tagName].def = classDef;

  if (classDef.template) {
    _base2.default.components[tagName].template = classDef.template;
    delete classDef.template;
  }

  if (classDef.style) {
    _base2.default.components[tagName].style = classDef.style;
    delete classDef.style;
  }

  if (registerAllCalled) _registerComponent(tagName);
}

// Docs in layer-ui.js
function unregisterComponent(tagName) {
  delete _base2.default.components[tagName];
}

// Docs in layer-ui.js
function registerAll() {
  registerAllCalled = true;
  Object.keys(_base2.default.components).filter(function (tagName) {
    return typeof _base2.default.components[tagName] !== 'function';
  }).forEach(function (tagName) {
    return _registerComponent(tagName);
  });
}

function _registerComponent(tagName) {
  var classDef = _base2.default.components[tagName].def;
  var template = _base2.default.components[tagName].template;


  if (template) {
    if (typeof template === 'string') {
      _base2.default.buildAndRegisterTemplate(tagName, template);
    } else if (template.getAttribute('layer-template-registered') !== 'true') {
      _base2.default.registerTemplate(tagName, template);
    }
  }

  // Insure property exists
  if (!classDef.properties) classDef.properties = {};
  if (!classDef.methods) classDef.methods = {};
  if (!classDef.events) classDef.events = [];
  if (!classDef.mixins) classDef.mixins = [];
  classDef.mixins.push(_stateManager2.default);

  // Add in custom mixins specified via layerUI.settings
  if (_base2.default.settings.mixins[tagName]) {
    classDef.mixins = classDef.mixins.concat(_base2.default.settings.mixins[tagName]);
  }

  // Setup all events specified in the `events` property.  This adds properties,
  // so must precede setupMixins
  setupEvents(classDef);

  // Replace all methods with "merge" parameters
  var methods = classDef.methods;
  classDef.methods = {};
  setupMethods(classDef, standardClassMethods);
  setupMethods(classDef, methods);

  // Propare the classDef's properties to merge with Mixin properties
  var properties = classDef.properties;
  classDef.properties = {};
  setupMixin(classDef, { properties: properties });
  setupMixin(classDef, { properties: standardClassProperties });

  // Some mixins may have mixins of their own; add them to the list;
  // every newly added item must also be processed, so insure loop touches on new items as well
  for (var i = 0; i < classDef.mixins.length; i++) {
    var mixins = classDef.mixins[i].mixins;
    if (mixins) {
      mixins.forEach(function (submixin) {
        if (classDef.mixins.indexOf(submixin) === -1) classDef.mixins.push(submixin);
      });
    }
  }

  classDef.mixins.forEach(function (mixin) {
    return setupMixin(classDef, mixin);
  });
  finalizeMixinMerge(classDef);

  // For each property in the methods hash, setup the setter/getter
  var propertyDefHash = {};
  var props = getPropArray(classDef);

  // Add the property to our object, with suitable getters and setters
  props.forEach(function (prop) {
    return setupProperty(classDef, prop, propertyDefHash);
  });

  // Cleanup; we no longer need this properties object; it can be accessed via propertyDefHash
  delete classDef.properties;

  // For every method, add the expected structure to the function
  Object.keys(classDef.methods).forEach(function (name) {
    classDef[name] = {
      value: classDef.methods[name],
      writable: true
    };
  });
  delete classDef.methods;

  /**
   * createdCallback is part of the Webcomponent lifecycle and drives this framework's lifecycle.
   *
   * It is called after the widget has been created.  We use this to initialize properties, nodes,
   * templates, wait for more properties, call property setters, call `onAfterCreate`, etc.
   *
   * @method createdCallback
   * @private
   */
  classDef.createdCallback = {
    value: function createdCallback() {
      var _this3 = this;

      if (!_base2.default.components[tagName]) return;

      this._initializeProperties();
      this.nodes = {};

      // If a template has been assigned for this class, append it to this node, and parse for layer-ids
      // TODO: Rearchitect layer-message-item to be a place holder for a layer-message-sent-item or layer-message-received-item so that
      // we don't need this hokey stuff here
      var templateNode = this.getTemplate();
      if (templateNode) {
        var clone = document.importNode(templateNode.content, true);
        this.appendChild(clone);
        this.setupDomNodes();
      }

      // Call the Compoent's created method which sets up DOM nodes,
      // event handlers, etc...
      this.onCreate();

      // Call the Component's onAfterCreate method which can handle any setup
      // that requires all properties to be set, dom nodes initialized, etc...
      _layerWebsdk2.default.Util.defer(function () {
        return _this3._onAfterCreate();
      });
    }
  };

  classDef._onAfterCreate = {
    value: function _onAfterCreate() {
      var _this4 = this;

      // Allow Adapters to call _onAfterCreate... and then insure its not run a second time
      if (this.properties._internalState.onAfterCreateCalled) return;
      this.properties._internalState.disableSetters = false;
      this.properties._internalState.disableGetters = false;
      this.properties._internalState.inPropInit = _base2.default.components[tagName].properties.map(function (propDef) {
        return propDef.propertyName;
      });

      props.forEach(function (prop) {
        var value = _this4.properties[prop.propertyName];
        // UNIT TEST: This line is primarily to keep unit tests from throwing errors
        if (value instanceof _layerWebsdk2.default.Root && value.isDestroyed) return;
        if (value !== undefined && value !== null) {
          // Force the setter to trigger; this will force the value to be converted to the correct type,
          // and call all setters
          _this4[prop.propertyName] = value;

          if (prop.propagateToChildren) {
            Object.keys(_this4.nodes).forEach(function (nodeName) {
              return _this4.nodes[nodeName][prop.propertyName] = value;
            });
          }
        }

        // If there is no value, but the parent component has the same property name, presume it to also be
        // propagateToChildren, and copy its value; useful for allowing list-items to automatically grab
        // all parent propagateToChildren properties.
        else if (prop.propagateToChildren && _this4.parentComponent) {
            var parentValue = _this4.parentComponent.properties[prop.propertyName];
            if (parentValue) _this4[prop.propertyName] = parentValue;
          }
      });
      this.properties._internalState.inPropInit = [];
      this.onAfterCreate();
    }
  };

  /**
   * A hash of DOM nodes that are important to this widget.
   *
   * Any dom node in a template file that has a `layer-id` will be written to this hash.
   *
   * Example:
   *
   * ```
   * <template>
   *   <a layer-id='link'><img layer-id='image' /></a>
   * </template
   * ```
   *
   * The above template will result in a `nodes` value of:
   *
   * ```
   * {
   *     link: anchorObject,
   *     image: imageObject
   * }
   * ```
   *
   * And then allow me to have code such as:
   *
   * ```
   * render: function() {
   *    this.nodes.image.src = this.properties.url;
   * }
   * ```
   *
   * @property {Object} nodes
   */

  /**
   * attachedCallback is part of the Webcomponent lifecycle and drives this framework's lifecycle.
   *
   * This calls `onAttach`.
   * @method
   * @private
   */
  classDef.attachedCallback = {
    value: function onAttach() {
      this.onAttach();
    }
  };

  /**
   * Initialize the properties object.
   *
   * This Fixes a bug in webcomponents polyfil that clobbers property getter/setter.
   *
   * The webcomponent polyfil copies in properties before the property getter/setter is applied to the object.
   * As a result, we might have a property of `this.appId` that is NOT accessed via `this.properties.appId`.
   * Further, the getter and setter functions will not invoke as long as this value is perceived as the definition
   * for this Object. So we delete the property `appId` from the object so that the getter/setter up the prototype chain can
   * once again function.
   *
   * @method _initializeProperties
   * @private
   * @param {Object} prop   A property def whose value should be stashed
   */
  classDef._initializeProperties = {
    value: function _initializeProperties() {
      var _this5 = this;

      /**
       * Values for all properties of this widget.
       *
       * All properties are stored in `this.properties`; any property defined in the class definition's `properties` hash
       * are read and written here.
       *
       * Properties may have already been setup by a UI Framework adapter for caching properties passed from the app; if properties
       * exists, they may still need to be setup.
       *
       * @property {Object} properties
       * @protected
       */
      if (this.properties && this.properties._internalState) return;
      if (!this.properties) this.properties = {};

      this.properties._internalState = {
        layerEventSubscriptions: [],
        onCreateCalled: false,
        onAfterCreateCalled: false,
        onRenderCalled: false,
        onAttachCalled: false,
        onDetachCalled: false,
        disableSetters: true,
        disableGetters: true,
        inPropInit: []
      };

      // props.forEach((prop) => {
      //   const value = this[prop.propertyName];
      //   if (value !== undefined) {
      //     this.properties[prop.propertyName] = castProperty(prop.type, value);
      //     delete this[prop.propertyName];
      //   }
      //   this._copyInAttribute(prop);
      // });

      props.forEach(function (prop) {
        return _this5._copyInAttribute(prop);
      });
    }
  };

  /**
   * Handle some messy post-create copying of attribute values over to property
   * values where property setters can fire.
   *
   * @method _copyInAttribute
   * @private
   * @param {Object} prop   A property def object as defined by getPropArray
   */
  classDef._copyInAttribute = {
    value: function _copyInAttribute(prop) {

      var finalValue = null;
      var value = this.getAttribute(prop.attributeName);

      // Firefox seems to need this alternative to getAttribute().
      // TODO: Verify this and determine if it uses the getter here.
      if (value === null && this[prop.attributeName] !== undefined) {
        value = this[prop.attributeName];
      }

      if (value !== null) {
        finalValue = value;
      } else if (this[prop.propertyName] !== undefined) {
        // this only happens in firefox; somehow the property rather than the attribute is set, but
        // the setter is never called; so properties isn't correctly setup
        // TODO: Verify this -- also redundant with initialize properties
        finalValue = this[prop.propertyName];
        delete this[prop.propertyName];
      } else if ('value' in propertyDefHash[prop.propertyName]) {
        finalValue = propertyDefHash[prop.propertyName].value;

        // Don't treat a default value of [] as a static value shared among all instances
        if (Array.isArray(finalValue)) finalValue = finalValue.concat([]);
      }

      this.properties[prop.propertyName] = prop.type ? castProperty(prop.type, finalValue) : finalValue;
    }
  };

  /**
   * detachedCallback is part of the Webcomponent lifecycle and drives this framework's lifecycle.
   *
   * By default, removing this widget from the dom will cause it to be destroyed.
   *
   * Using the `layer-widget-destroyed` event, you may override this behavior using `evt.preventDefault()`:
   *
   * ```
   * document.body.addEventListener('layer-widget-destroyed', function(evt) {
   *    if (evt.target === nodeToNotDestroy) {
   *      evt.preventDefault();
   *    }
   * });
   * ```
   *
   * @event layer-widget-destroyed
   */
  classDef.detachedCallback = {
    value: function detachedCallback() {
      var _this6 = this;

      this.onDetach();

      // Wait 10 seconds after its been removed, then check to see if its still removed from the dom before doing cleanup and destroy.
      setTimeout(function () {
        if (!document.body.contains(_this6) && !document.head.contains(_this6) && _this6.trigger('layer-widget-destroyed')) {
          _this6.onDestroy();
        }
      }, 10000);
    }
  };

  /**
   * Any time a widget's attribute has changed, copy that change over to the properties where it can trigger the property setter.
   *
   * @method attributeChangedCallback
   * @private
   * @param {String} name      Attribute name
   * @param {Mixed} oldValue   Original value of the attribute
   * @param {Mixed} newValue   Newly assigned value of the attribute
   */
  classDef.attributeChangedCallback = {
    value: function attributeChangedCallback(name, oldValue, newValue) {
      if (_base2.default.debug) console.log('Attribute Change on ' + this.tagName + '.' + name + ' from ' + oldValue + ' to ', newValue);
      this[_base2.default.camelCase(name)] = newValue;
    }
  };

  // Register the component with our components hash as well as with the document.
  // WARNING: Calling this in some browsers may cause immediate registeration of the component prior
  // to reaching the next line of code; putting code after this line may be problematic.
  _base2.default.components[tagName].classDef = document.registerElement(tagName, {
    prototype: Object.create(HTMLElement.prototype, classDef)
  });

  /**
   * Identifies the properties exposed by this component.
   *
   * Used by adapters.  Each element of the array consists of:
   *
   * ```
   * {
   *    propertyName: 'onReadThisDoc',
   *    attributeName: 'on-read-this-doc',
   *    type: Boolean
   * }
   * ```
   *
   * @type {Object[]}
   * @static
   */
  _base2.default.components[tagName].properties = props;
};

/**
   * A `<template />` dom node
   *
   * These templates are used during Component initializations.
   *
   * @type {HTMLTemplateElement}
   * @private
   * @static
   */

/**
 * Stylesheet string.
 *
 * A stylesheet string can be added to the document via `styleNode.innerHTML = value` assignment.
 *
 * @type {String}
 * @private
 * @static
 */

/**
 * Mixin modes determines how a new method being added to a class will be executed with respect to any other methods.
 *
 * * BEFORE: Run your method before other methods of the same name
 * * AFTER: Run your method after other methods of the same name
 * * OVERWRITE: Run only your method, no other methods of the same name
 * * DEFAULT: Run your method in normal ordering.
 *
 * @static
 * @property {Object} MODES
 * @property {String} MODES.BEFORE
 * @property {String} MODES.AFTER
 * @property {String} MODES.OVERWRITE
 * @property {String} MODES.DEFAULT
 */
registerComponent.MODES = {
  BEFORE: 'BEFORE',
  AFTER: 'AFTER',
  OVERWRITE: 'OVERWRITE',
  DEFAULT: 'DEFAULT'
};

var standardClassProperties = {
  parentComponent: {},
  mainComponent: {
    get: function get() {
      if (this.properties._isMainComponent) return this;
      if (!this.properties.mainComponent) {
        this.properties.mainComponent = this.properties.parentComponent.mainComponent;
      }
      return this.properties.mainComponent;
    }
  },
  client: {
    propagateToChildren: true
  }
};

var standardClassMethods = {
  /**
   * The setupDomNodes method looks at all child nodes of this node that have layer-id properties and indexes them in the `nodes` property.
   *
   * Typically, this node has child nodes loaded via its template, and ready by the time your `created` method is called.
   *
   * This call is made on your behalf prior to calling `created`, but if using templates after `created` is called,
   * you may need to call this directly.
   *
   * @method setupDomNodes
   * @protected
   */
  setupDomNodes: function setupDomNodes() {
    var _this7 = this;

    this.nodes = {};

    this._findNodesWithin(this, function (node, isComponent) {
      var layerId = node.getAttribute && node.getAttribute('layer-id');
      if (layerId) _this7.nodes[layerId] = node;

      if (isComponent) {
        if (!node.properties) node.properties = {};
        node.properties.parentComponent = _this7;
      }
    });
  },

  /**
   * Iterate over all child nodes generated by the template; skip all subcomponent's child nodes.
   *
   * @method _findNodesWithin
   * @private
   * @param {HTMLElement} node    Node whose subtree should be called with the callback
   * @param {Function} callback   Function to call on each node in the tree
   * @param {HTMLElement} callback.node   Node that the callback is called on
   * @param {Boolean} isComponent         Is the node a Component from this framework
   */
  _findNodesWithin: function _findNodesWithin(node, callback) {
    var children = node.childNodes;
    for (var i = 0; i < children.length; i++) {
      var innerNode = children[i];

      var isLUIComponent = Boolean(innerNode instanceof HTMLElement && _base2.default.components[innerNode.tagName.toLowerCase()]);
      callback(innerNode, isLUIComponent);

      // If its not a custom webcomponent with children that it manages and owns, iterate on it
      if (!isLUIComponent) {
        this._findNodesWithin(innerNode, callback);
      }
    }
  },

  /**
   * Return the default template or the named template for this Component.
   *
   * Get the default template:
   *
   * ```
   * var template = widget.getTemplate();
   * ```
   *
   * Typical components should not need to call this; this will be called automatically prior to calling the Component's `created` method.
   * Some components wanting to reset dom to initial state may use this method explicitly:
   *
   * ```
   * var template = this.getTemplate();
   * var clone = document.importNode(template.content, true);
   * this.appendChild(clone);
   * this.setupDomNodes();
   * ```
   *
   * @method getTemplate
   * @protected
   * @returns {HTMLTemplateElement}
   */
  getTemplate: function getTemplate() {
    var tagName = this.tagName.toLocaleLowerCase();

    if (_base2.default.components[tagName].style) {
      var styleNode = document.createElement('style');
      styleNode.id = 'style-' + this.tagName.toLowerCase();
      styleNode.innerHTML = _base2.default.components[tagName].style;
      document.getElementsByTagName('head')[0].appendChild(styleNode);
      _base2.default.components[tagName].style = ''; // insure it doesn't get added to head a second time
    }
    return _base2.default.components[tagName].template;
  },

  /**
   * Triggers a dom level event which bubbles up the dom.
   *
   * Call with an event name and a `detail` object:
   *
   * ```
   * this.trigger('something-happened', {
   *   someSortOf: 'value'
   * });
   * ```
   *
   * The `someSortOf` key, and any other keys you pass into that object can be accessed via `evt.detail.someSortOf` or `evt.detail.xxxx`:
   *
   * ```
   * // Listen for the something-happened event which because it bubbles up the dom,
   * // can be listened for from any parent node
   * document.body.addEventListener('something-happened', function(evt) {
   *   console.log(evt.detail.someSortOf);
   * });
   * ```
   *
   * layerUI.components.Component.events can be used to generate properties to go with your events, allowing
   * the following widget property to be used:
   *
   * ```
   * this.onSomethingHappened = function(detail) {
   *   console.log(detail.someSortOf);
   * });
   * ```
   *
   * @method trigger
   * @protected
   * @param {String} eventName
   * @param {Object} detail
   * @returns {Boolean} True if process should continue with its actions, false if application has canceled
   *                    the default action using `evt.preventDefault()` (perhaps an event listener wanted to handle the action itself)
   */
  trigger: function trigger(eventName, details) {
    var evt = new CustomEvent(eventName, {
      detail: details,
      bubbles: true,
      cancelable: true
    });
    this.dispatchEvent(evt);
    return !evt.defaultPrevented;
  },

  /**
   * Return array of matching elements as an Array.
   *
   * This basically just calls this.querySelectorAll and then returns a proper Array rather than a NodeList.
   *
   * @method querySelectorAllArray
   * @protected
   * @param {String} XPath selector
   * @returns {HTMLElement[]}
   */
  querySelectorAllArray: function querySelectorAllArray(selector) {
    return Array.prototype.slice.call(this.querySelectorAll(selector));
  },

  /**
   * MIXIN HOOK: Each time a Component is initialized, its onCreate methods will be called.
   *
   * This is called before any properties have been set; use this for initialization that does not
   * depend upon properties, including creating dom nodes, event handlers and initial values for state variables.
   *
   * @method onCreate
   */
  onCreate: {
    mode: registerComponent.MODES.AFTER,
    value: function onCreate() {
      this.properties._internalState.onCreateCalled = true;
    }
  },

  /**
   * MIXIN HOOK: Each time a Component is initialized, its onAfterCreate methods will be called.
   *
   * While one could use layerUI.Components.Component.onCreate, this handler allows you to wait for all
   * properties to be set before your intialization code is run.
   *
   * @method onAfterCreate
   */
  onAfterCreate: {
    mode: registerComponent.MODES.AFTER,
    value: function onAfterCreate() {
      this.properties._internalState.onAfterCreateCalled = true;
      this.onRender();
      this.properties._internalState.onRenderCalled = true;
      if (this.properties._callOnAttachAfterCreate) {
        this.properties._callOnAttachAfterCreate = false;
        this.onAttach();
      }
    }
  },

  /**
   * MIXIN HOOK: Called when rendering the widget.
   *
   * @method onRender
   */
  onRender: {
    conditional: function onCanRender() {
      return this.properties._internalState.onAfterCreateCalled;
    }
  },

  /**
   * MIXIN HOOK: Called after any Query events cause the list
   * to have rerendered.
   *
   * @method onRerender
   */
  onRerender: {
    conditional: function onCanRerender() {
      return this.properties._internalState.onAfterCreateCalled;
    }
  },

  /**
   * MIXIN HOOK: Each time a Component is inserted into a Document, its onAttach methods will be called.
   *
   * Note that prior to this, `parentNode` might have been `null`; at this point,
   * you should be able to see all information about its parent nodes.  Some rendering
   * may need to wait for this.
   *
   * @method onAttach
   */
  onAttach: {
    conditional: function onAttachConditional() {
      if (!this.properties._internalState.onAfterCreateCalled) {
        this.properties._callOnAttachAfterCreate = true;
        return false;
      } else {
        return true;
      }
    },
    mode: registerComponent.MODES.AFTER,
    value: function onAttach() {
      this.properties._internalState.onAttachCalled = true;
    }
  },

  /**
   * MIXIN HOOK: Each time a Component is removed from document.body, its onDetach methods will be called.
   *
   * Note that the `layer-widget-destroyed` event will still trigger even if you provide this, so be aware of
   * what that event will do and that your widget may be destroyed a few seconds after this function is called.
   *
   * @method onDetach
   */
  onDetach: {
    mode: registerComponent.MODES.AFTER,
    value: function onDetach() {
      this.properties.mainComponent = null;
      this.properties.parentComponent = null;
      this.properties._internalState.onDetachCalled = true;
    }
  },

  /**
   * MIXIN HOOK: Add a `onDestroy` method to your component which will be called when your component has been removed fromt the DOM.
   *
   * Use this instead of the WebComponents `detachedCallback` as some
   * boilerplate code needs to be run (this code will shut off all event listeners the widget has setup).
   *
   * Your `onDestroy` callback will run after the node has been removed from the document
   * for at least 10 seconds.  See the `layer-widget-destroyed` event to prevent the widget from being destroyed after removing
   * it from the document.
   *
   * @method onDestroy
   * @private
   */
  onDestroy: function onDestroy() {
    var _this8 = this;

    this.properties._internalState.layerEventSubscriptions.forEach(function (subscribedObject) {
      return subscribedObject.off(null, null, _this8);
    });
    this.properties._internalState.layerEventSubscriptions = [];
    this.classList.add('layer-node-destroyed');
  }
};

function registerMessageComponent(tagName, componentDefinition) {
  var handlesMessage = componentDefinition.methods.handlesMessage;
  var label = componentDefinition.properties.label.value;
  var order = componentDefinition.properties.order;
  registerComponent(tagName, componentDefinition);
  _base2.default.registerMessageHandler({
    handlesMessage: handlesMessage,
    tagName: tagName,
    label: label,
    order: order
  });
}

module.exports = {
  registerComponent: registerComponent,
  registerMessageComponent: registerMessageComponent,
  registerAll: registerAll,
  unregisterComponent: unregisterComponent
};
},{"../base":14,"../mixins/state-manager":62,"layer-websdk":79}],16:[function(require,module,exports){
/**
 * The Layer Channel Item widget renders a single Channel, typically for use representing a
 * channel within a list of channels.
 *
 * This is designed to go inside of the layerUI.components.ConversationsListPanel.List widget, and be a
 * concise enough summary that it can be scrolled through along
 * with hundreds of other Conversations Item widgets.
 *
 * Future Work:
 *
 * * Badges for unread messages (currently just adds a css class so styling can change if there are any unread messages)
 *
 * @class layerUI.components.ConversationsListPanel.Item.Channel
 * @experimental
 * @extends layerUI.components.Component
 */'use strict';

var _component = require('../../../components/component');

var _listItem = require('../../../mixins/list-item');

var _listItem2 = _interopRequireDefault(_listItem);

var _listItemSelection = require('../../../mixins/list-item-selection');

var _listItemSelection2 = _interopRequireDefault(_listItemSelection);

require('../../subcomponents/layer-delete/layer-delete');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerComponent)('layer-channel-item', {
  mixins: [_listItem2.default, _listItemSelection2.default],
  properties: {

    // Every List Item has an item property, here it represents the Conversation to render
    item: {
      set: function set(newConversation, oldConversation) {
        if (newConversation) this.onRerender();
      }
    },

    /**
     * Enable deletion of this Conversation.
     *
     * This property is currently assumed to be settable at creation time only,
     * and does not rerender if changed.
     *
     * This property does nothing if you remove the `delete` node from the template.
     *
     * @property {Boolean} [deleteConversationEnabled=false]
     */
    deleteConversationEnabled: {
      type: Boolean,
      set: function set(value) {
        if (this.nodes.delete) this.nodes.delete.enabled = value;
      }
    }
  },
  methods: {
    onRender: function onRender() {
      this.onRerender();
    },
    onRerender: function onRerender() {
      if (this.item) this.nodes.title.innerHTML = this.item.name;
    },


    /**
     * Run a filter on this item; not match => hidden; match => shown.
     *
     * @method _runFilter
     * @param {String|Regex|Function} filter
     */
    _runFilter: function _runFilter(filter) {
      var channel = this.properties.item;
      var match = void 0;
      if (!filter) {
        match = true;
      } else if (typeof filter === 'function') {
        match = filter(channel);
      } else if (filter instanceof RegExp) {
        match = filter.test(channel.name);
      } else {
        filter = filter.toLowerCase();
        match = channel.name.toLowerCase().indexOf(filter) !== -1;
      }
      this.classList[match ? 'remove' : 'add']('layer-item-filtered');
    }
  }
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-channel-item", "<div class='layer-list-item' layer-id='innerNode'><div class='layer-channel-item-content'><div layer-id='title' class='layer-channel-title'></div></div><layer-delete layer-id='delete'></layer-delete></div>", "");
  layerUI.buildStyle("layer-channel-item", "layer-channel-item {\ndisplay: flex;\nflex-direction: column;\n}\nlayer-channel-item .layer-list-item {\ndisplay: flex;\nflex-direction: row;\nalign-items: center;\n}\nlayer-channel-item  .layer-list-item .layer-channel-item-content {\nflex-grow: 1;\nwidth: 100px; \n}\nlayer-channel-item.layer-item-filtered .layer-list-item {\ndisplay: none;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../../../mixins/list-item":57,"../../../mixins/list-item-selection":56,"../../subcomponents/layer-delete/layer-delete":35}],17:[function(require,module,exports){
/**
     * The Layer Conversation Item widget renders a single Conversation, typically for use representing a
     * conversation within a list of conversations.
     *
     * This is designed to go inside of the layerUI.components.ConversationsListPanel.List widget, and be a
     * concise enough summary that it can be scrolled through along
     * with hundreds of other Conversations Item widgets.
     *
     * Future Work:
     *
     * * Badges for unread messages (currently just adds a css class so styling can change if there are any unread messages)
     *
     * @class layerUI.components.ConversationsListPanel.Item.Conversation
     * @extends layerUI.components.Component
     */'use strict';

var _component = require('../../../components/component');

var _listItem = require('../../../mixins/list-item');

var _listItem2 = _interopRequireDefault(_listItem);

var _listItemSelection = require('../../../mixins/list-item-selection');

var _listItemSelection2 = _interopRequireDefault(_listItemSelection);

require('../../subcomponents/layer-conversation-last-message/layer-conversation-last-message');

require('../../subcomponents/layer-delete/layer-delete');

require('../../subcomponents/layer-avatar/layer-avatar');

require('../../subcomponents/layer-conversation-title/layer-conversation-title');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _component.registerComponent)('layer-conversation-item', {
  mixins: [_listItem2.default, _listItemSelection2.default],
  properties: {

    // Every List Item has an item property, here it represents the Conversation to render
    item: {
      set: function set(newConversation, oldConversation) {
        if (this.nodes.lastMessage) {
          this.nodes.lastMessage.canFullyRenderLastMessage = this.canFullyRenderLastMessage;
        }
      }
    },

    /**
     * Enable deletion of this Conversation.
     *
     * This property is currently assumed to be settable at creation time only,
     * and does not rerender if changed.
     *
     * This property does nothing if you remove the `delete` node from the template.
     *
     * @property {Boolean} [deleteConversationEnabled=false]
     */
    deleteConversationEnabled: {
      type: Boolean,
      set: function set(value) {
        if (this.nodes.delete) this.nodes.delete.enabled = value;
      }
    },

    /**
     * Provide a function to determine if the last message is rendered in the Conversation List.
     *
     * By default, only text/plain last-messages are fully rendered in the Conversation List.
     *
     * All other messages are rendered using the `label` passed in with their layerUI.registerMessageHandler call.
     *
     * ```javascript
     * listItem.canFullyRenderLastMessage = function(message) {
     *     return true; // Render the current Messages
     * }
     * ```
     *
     * @property {Function} [canFullyRenderLastMessage=null]
     */
    canFullyRenderLastMessage: {}
  },
  methods: {
    onRender: function onRender() {
      this.onRerender();
    },
    onRerender: function onRerender() {
      var users = this.item.participants.filter(function (user) {
        return !user.sessionOwner;
      });
      var isRead = !this.item.lastMessage || this.item.lastMessage.isRead;

      this.nodes.avatar.users = users;
      this.classList[isRead ? 'remove' : 'add']('layer-conversation-unread-messages');
    },


    /**
     * Run a filter on this item; not match => hidden; match => shown.
     *
     * @method _runFilter
     * @param {String|Regex|Function} filter
     */
    _runFilter: function _runFilter(filter) {
      var conversation = this.properties.item;
      var match = void 0;
      if (!filter) {
        match = true;
      } else if (typeof filter === 'function') {
        match = filter(conversation);
      } else {
        var values = [];
        if (conversation.metadata.conversationName) values.push(conversation.metadata.conversationName);
        conversation.participants.forEach(function (identity) {
          values.push(identity.displayName);
          values.push(identity.firstName);
          values.push(identity.lastName);
          values.push(identity.emailAddress);
        });
        if (filter instanceof RegExp) {
          match = values.filter(function (value) {
            return filter.test(value);
          }).length;
        } else {
          filter = filter.toLowerCase();
          match = values.filter(function (value) {
            if (value) {
              return value.toLowerCase().indexOf(filter) !== -1;
            } else {
              return false;
            }
          }).length;
        }
      }
      this.classList[match ? 'remove' : 'add']('layer-item-filtered');
    }
  }
}); 


(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-conversation-item", "<div class='layer-list-item' layer-id='innerNode'><layer-avatar layer-id='avatar'></layer-avatar><div class='layer-conversation-item-content'><layer-conversation-title layer-id='title'></layer-conversation-title><layer-conversation-last-message layer-id='lastMessage'></layer-conversation-last-message></div><layer-delete layer-id='delete'></layer-delete></div>", "");
  layerUI.buildStyle("layer-conversation-item", "layer-conversation-item {\ndisplay: flex;\nflex-direction: column;\n}\nlayer-conversation-item .layer-list-item {\ndisplay: flex;\nflex-direction: row;\nalign-items: center;\n}\nlayer-conversation-item .layer-list-item layer-avatar {\nmargin-right: 15px;\n}\nlayer-conversation-item  .layer-list-item .layer-conversation-item-content {\nflex-grow: 1;\nwidth: 100px; \n}\nlayer-conversation-item.layer-item-filtered .layer-list-item {\ndisplay: none;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../../../mixins/list-item":57,"../../../mixins/list-item-selection":56,"../../subcomponents/layer-avatar/layer-avatar":29,"../../subcomponents/layer-conversation-last-message/layer-conversation-last-message":32,"../../subcomponents/layer-conversation-title/layer-conversation-title":33,"../../subcomponents/layer-delete/layer-delete":35}],18:[function(require,module,exports){
/**
     * The Layer Conversation List widget renders a scrollable, pagable list of Conversations.
     *
     * This Component can be added to your project directly in the HTML file:
     *
     * ```
     * <layer-conversations-list></layer-conversations-list>
     * ```
     *
     * Or via DOM Manipulation:
     *
     * ```javascript
     * var conversation = document.createElement('layer-conversations-list');
     * ```
     *
     * And then its properties can be set as:
     *
     * ```javascript
     * var list = document.querySelector('layer-conversations-list');
     * list.onConversationSelected = function(evt) {
     *    alert(evt.detail.item.id + ' has been selected');
     * }
     * ```
     *
     * ## Common Properties
     *
     * The most common property of this widget is layerUI.components.ConversationsListPanel.onConversationSelected, as typical use
     * of this widget is to prompt the user to select a Conversation, and use that selection elsewhere.
     *
     * Note that you can also listen for `layer-conversation-selected` to achieve the same result:
     *
     * ```
     * document.body.addEventListener('layer-conversation-selected', function(evt) {
     *    alert(evt.detail.item.id + ' has been selected');
     * });
     * ```
     *
     * You may also sometimes want to set which Conversation to mark as selected:
     *
     * ```javascript
     * conversationList.selectedConversationId = myConversation.id;
     * ```
     *
     * @class layerUI.components.ConversationsListPanel.List
     * @extends layerUI.components.Component
     * @mixin layerUI.mixins.List
     * @mixin layerUI.mixins.MainComponent
     * @mixin layerUI.mixins.ListSelection
     */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _component = require('../../../components/component');

var _list = require('../../../mixins/list');

var _list2 = _interopRequireDefault(_list);

var _listSelection = require('../../../mixins/list-selection');

var _listSelection2 = _interopRequireDefault(_listSelection);

var _mainComponent = require('../../../mixins/main-component');

var _mainComponent2 = _interopRequireDefault(_mainComponent);

require('../layer-conversation-item/layer-conversation-item');

require('../layer-channel-item/layer-channel-item');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _component.registerComponent)('layer-conversations-list', {
  mixins: [_list2.default, _listSelection2.default, _mainComponent2.default],

  /**
   * Configure a custom action when a Conversation is selected;
   *
   * Use `evt.preventDefault()` to prevent default handling from occuring.
   *
   * ```javascript
   *    document.body.addEventListener('layer-conversation-selected', function(evt) {
   *      var conversation = evt.detail.item;
   *
   *      // To prevent the UI from proceding to select this conversation:
   *      evt.preventDefault();
   *    });
   * ```
   *
   * OR
   *
   * ```javascript
   *    converationList.onConversationSelected = function(evt) {
   *      var conversation = evt.detail.item;
   *
   *      // To prevent the UI from proceding to select this conversation:
   *      evt.preventDefault();
   *    });
   * ```
   *
   * @property {Function} onConversationSelected
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Conversation} evt.detail.item   The selected Conversation
   * @param {Event} evt.detail.originalEvent               The click event that selected the Conversation
   */

  /**
   * See layerUI.components.ConversationsListPanel.onConversationSelected.
   *
   * @event layer-conversation-selected
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Conversation} evt.detail.item   The selected Conversation
   * @param {Event} evt.detail.originalEvent               The click event that selected the Conversation
   */

  /**
   * The user has clicked to delete a conversation.
   *
   * ```javascript
   *    conversationListNode.onConversationDeleted = function(evt) {
   *      var conversation = evt.detail.item;
   *
   *      // To prevent the UI from proceding to delete this conversation (perhaps you want
   *      // to leave the Conversation instead of delete it):
   *      evt.preventDefault();
   *      conversation.leave();
   *    };
   * ```
   *
   *  OR
   *
   * ```javascript
   *    document.body.addEventListener('layer-conversation-deleted', function(evt) {
   *      var conversation = evt.detail.item;
   *
   *      // To prevent the UI from proceding to delete this conversation (perhaps you want
   *      // to leave the Conversation instead of delete it):
   *      evt.preventDefault();
   *      conversation.leave();
   *    });
   * ```
   *
   * @property {Function} onConversationDeleted
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Conversation} evt.detail.item
   */

  /**
   * See layerUI.components.ConversationsListPanel.List.onConversationDeleted.
   *
   * @event layer-conversation-deleted
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Conversation} evt.detail.item
   */

  events: ['layer-conversation-selected', 'layer-conversation-deleted'],
  properties: {

    /**
     * Get/Set the selected Conversation by ID.
     *
     * ```javascript
     * conversationList.selectedConversationId = myConversation.id;
     * ```
     *
     * Or if using a templating engine:
     *
     * ```html
     * <layer-conversations-list selected-conversation-id={{selectedConversation.id}}></layer-conversations-list>
     * ```
     *
     * The above code will set the selected Conversation and render the conversation as selected.
     *
     * @property {String} [selectedConversationId='']
     * @deprecated see layerUI.components.ConversationsListPanel.ListSelection.selectedId
     */
    selectedConversationId: {
      set: function set(value) {
        this.selectedId = value;
      },
      get: function get() {
        return this.selectedId;
      }
    },

    /**
     * Function allows for control over which Conversations can be deleted and which can not.
     *
     * Return true means enabled, false is disabled.
     *
     *  ```javascript
     * conversationPanel.deleteConversationEnabled = function(conversation) {
     *     return conversation.metadata.category !== 'adminStuff';
     * });
     * ```
     *
     * If delete is enabled, the layerUI.components.misc.Delete.enabled property is changed, causing
     * the `layer-delete-enabled` css class to be added/removed on that widget.
     *
     * @property {Function} [deleteConversationEnabled=null]
     * @property {layer.Conversation} deleteConversationEnabled.conversation
     * @property {Boolean} deleteConversationEnabled.return
     */
    deleteConversationEnabled: {
      type: Function
    },

    /**
     * The model to generate a Query for if a Query is not provided.
     *
     * @readonly
     * @private
     * @property {String} [_queryModel=layer.Query.Conversation]
     */
    _queryModel: {
      value: _layerWebsdk2.default.Query.Conversation
    },

    /**
     * The event name to trigger on selecting a Conversation.
     *
     * @readonly
     * @private
     * @property {String} [_selectedItemEventName=layer-conversation-selected]
     */
    _selectedItemEventName: {
      value: 'layer-conversation-selected'
    },

    /**
     * Provide a function to determine if the last message is rendered in the Conversation List.
     *
     * By default, only text/plain last-messages are rendered in the Conversation List.
     *
     * ```javascript
     * list.canFullyRenderLastMessage = function(message) {
     *     return message.parts[0].mimeType === 'text/mountain' ||
     *            message.parts[0].mimeType === 'text/plain';
     * }
     * ```
     *
     * If you enable rendering of images for example, you would be enabling the handler that renders image messages
     * in the Message List to render that same image in the Conversation List.
     *
     * If you prevent rendering of a Message, it will instead render the `label` attribute for that message handler;
     * see layerUI.registerMessageHandler for more info on the `label`.
     *
     * TODO: Should test to see what handler is returned rather than testing the mimeType
     *
     * @property {Function} canFullyRenderLastMessage
     */
    canFullyRenderLastMessage: {
      type: Function,
      value: function value(message) {
        return message.parts[0].mimeType === 'text/plain';
      }
    }
  },
  methods: {
    /**
     * Generate a `layer-conversation-item` widget.
     *
     * @method _generateItem
     * @private
     * @param {layer.Conversation} conversation
     */
    _generateItem: function _generateItem(conversation) {
      var isChannel = conversation instanceof _layerWebsdk2.default.Channel;
      var conversationWidget = document.createElement('layer-' + (isChannel ? 'channel' : 'conversation') + '-item');
      conversationWidget.id = this._getItemId(conversation.id);
      conversationWidget.deleteConversationEnabled = typeof this.deleteConversationEnabled === 'function' ? this.deleteConversationEnabled(conversation) : true;
      conversationWidget.canFullyRenderLastMessage = this.canFullyRenderLastMessage;
      conversationWidget.item = conversation;
      if (this.filter) conversationWidget._runFilter(this.filter);
      return conversationWidget;
    }
  }
}); 


(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-conversations-list", "<div class='layer-load-indicator' layer-id='loadIndicator'>Loading conversations...</div>", "");
  layerUI.buildStyle("layer-conversations-list", "layer-conversations-list {\noverflow-y: auto;\ndisplay: block;\n}\nlayer-conversations-list .layer-load-indicator {\ntext-align: center;\nborder-top: solid 1px #ccc;\nfont-style: italic;\ndisplay: none;\n}\nlayer-conversations-list.layer-loading-data .layer-load-indicator {\ndisplay: block;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../../../mixins/list":59,"../../../mixins/list-selection":58,"../../../mixins/main-component":60,"../layer-channel-item/layer-channel-item":16,"../layer-conversation-item/layer-conversation-item":17,"layer-websdk":79}],19:[function(require,module,exports){
/**
 * The Layer User List renders a pagable list of layer.Identity objects, and allows the user to select people to talk with.
 *
 * This is typically used for creating/updating Conversation participant lists.
 *
 * This Component can be added to your project directly in the HTML file:
 *
 * ```
 * <layer-identities-list></layer-identities-list>
 * ```
 *
 * Or via DOM Manipulation:
 *
 * ```javascript
 * var identitylist = document.createElement('layer-identities-list');
 * ```
 *
 * And then its properties can be set as:
 *
 * ```javascript
 * var identityList = document.querySelector('layer-identities-list');
 * identityList.selectedIdentities = [identity3, identity6];
 * identityList.onIdentitySelected = identityList.onIdentityDeselected = function(evt) {
 *    log("The new selected users are: ", identityList.selectedIdentities);
 * }
 * ```
 *
 * ## Events
 *
 * Events listed here come from either this component, or its subcomponents.
 *
 * * {@link layerUI.components.IdentitiesListPanel.List#layer-identity-deselected layer-identity-deselected}: User has clicked to unselect an Identity
 * * {@link layerUI.components.IdentitiesListPanel.List#layer-identity-selected layer-identity-selected}: User has clicked to select an Identity
 *
 * @class layerUI.components.IdentitiesListPanel.List
 * @extends layerUI.components.Component
 * @mixin layerUI.mixins.List
 * @mixin layerUI.mixins.MainComponent
 */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _component = require('../../../components/component');

var _list = require('../../../mixins/list');

var _list2 = _interopRequireDefault(_list);

var _mainComponent = require('../../../mixins/main-component');

var _mainComponent2 = _interopRequireDefault(_mainComponent);

var _hasQuery = require('../../../mixins/has-query');

var _hasQuery2 = _interopRequireDefault(_hasQuery);

require('../layer-identity-item/layer-identity-item');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerComponent)('layer-identities-list', {
  mixins: [_list2.default, _mainComponent2.default, _hasQuery2.default],

  /**
   * The user has clicked to select an Identity in the Identities List.
   *
   * ```javascript
   *    identityList.onIdentitySelected = function(evt) {
   *      var identityAdded = evt.detail.item;
   *      var selectedIdentities = evt.target.selectedIdentities;
   *
   *      // To prevent the UI from proceding to add the identity to the selectedIdentities:
   *      // Note that identityAdded is not yet in selectedIdentities so that you may prevent it from being added.
   *      evt.preventDefault();
   *    };
   * ```
   *
   *  OR
   *
   * ```javascript
   *    document.body.addEventListener('layer-identity-selected', function(evt) {
   *      var identityAdded = evt.detail.item;
   *      var selectedIdentities = evt.target.selectedIdentities;
   *
   *      // To prevent the UI from proceding to add the identity to the selectedIdentities:
   *      // Note that identityAdded is not yet in selectedIdentities so that you may prevent it from being added.
   *      evt.preventDefault();
   *    });
   * ```
   *
   * @event layer-identity-selected
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Identity} evt.detail.item
   */
  /**
   * A identity selection change has occurred
   *
   * See the {@link layerUI.components.IdentitiesListPanel.List#layer-identity-selected layer-identity-selected} event for more detail.
   *
   * @property {Function} onIdentitySelected
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Identity} evt.detail.item
   */

  /**
   * The user has clicked to deselect a identity in the identities list.
   *
   *    identityList.onIdentityDeselected = function(evt) {
   *      var identityRemoved = evt.detail.item;
   *      var selectedIdentities = evt.target.selectedIdentities;
   *
   *      // To prevent the UI from proceding to add the identity to the selectedIdentities:
   *      // Note that identityRemoved is still in selectedIdentities so that you may prevent it from being removed.
   *      evt.preventDefault();
   *    };
   *
   *  OR
   *
   *    document.body.addEventListener('layer-identity-deselected', function(evt) {
   *      var identityRemoved = evt.detail.item;
   *      var selectedIdentities = evt.target.selectedIdentities;
   *
   *      // To prevent the UI from proceding to add the identity to the selectedIdentities:
   *      // Note that identityRemoved is still in selectedIdentities so that you may prevent it from being removed.
   *      evt.preventDefault();
   *    });
   *
   * @event layer-identity-deselected
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Identity} evt.detail.item
   */
  /**
   * A identity selection change has occurred
   *
   * See the {@link layerUI.components.IdentitiesListPanel.List#layer-identity-deselected layer-identity-deselected} event for more detail.
   *
   * @property {Function} onIdentityDeselected
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Identity} evt.detail.item
   */

  events: ['layer-identity-selected', 'layer-identity-deselected'],
  properties: {

    /**
     * Array of layer.Identity objects representing the identities who should be rendered as Selected.
     *
     * This property can be used both get and set the selected identities; however, if setting you should not be manipulating
     * the existing array, but rather setting a new array:
     *
     * Do NOT do this:
     *
     * ```javascript
     * list.selectedIdentities.push(identity1); // DO NOT DO THIS
     * ```
     *
     * Instead, Please do this:
     *
     * ```javascript
     * var newList = list.selectedIdentities.concat([]);
     * newList.push(identity1);
     * list.selectedIdentities = newList;
     * ```
     *
     * @property {layer.Identity[]} [selectedIdentities=[]]
     */
    selectedIdentities: {
      set: function set(value) {
        var _this = this;

        if (!value) value = [];
        if (!Array.isArray(value)) return;
        if (!value) value = [];
        this.properties.selectedIdentities = value.map(function (identity) {
          if (!(identity instanceof _layerWebsdk2.default.Identity)) return _this.properties.client.getIdentity(identity.id);
          return identity;
        });
        this._renderSelection();
      }
    },

    /**
     * The model to generate a Query for if a Query is not provided.
     *
     * @readonly
     * @private
     * @property {String} [_queryModel=layer.Query.Identity]
     */
    _queryModel: {
      value: _layerWebsdk2.default.Query.Identity
    }
  },
  methods: {

    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {
      if (!this.id) this.id = _layerWebsdk2.default.Util.generateUUID();
      this.properties.selectedIdentities = [];

      this.addEventListener('layer-identity-item-selected', this._handleIdentitySelect.bind(this));
      this.addEventListener('layer-identity-item-deselected', this._handleIdentityDeselect.bind(this));
    },


    /**
     * Handle a user Selection event triggered by a layerUI.components.IdentitiesListPanel.Item.
     *
     * Adds the Identity to the selectedIdentities array.
     *
     * @method _handleIdentitySelect
     * @private
     * @param {Event} evt
     */
    _handleIdentitySelect: function _handleIdentitySelect(evt) {
      evt.stopPropagation();
      var identity = evt.detail.item;
      var index = this.selectedIdentities.indexOf(identity);

      // If the item is not in our selectedIdentities array, add it
      if (index === -1) {
        // If app calls prevent default, then don't add the identity to our selectedIdentities list, just call preventDefault on the original event.
        if (this.trigger('layer-identity-selected', { item: identity })) {
          this.selectedIdentities.push(identity);
        } else {
          evt.preventDefault();
        }
      }
    },


    /**
     * Handle a user Deselection event triggered by a layerUI.components.IdentitiesListPanel.Item
     *
     * Removes the identity from the selectedIdentities array.
     *
     * @method _handleIdentityDeselect
     * @private
     * @param {Event} evt
     */
    _handleIdentityDeselect: function _handleIdentityDeselect(evt) {
      evt.stopPropagation();
      var identity = evt.detail.item;
      var index = this.selectedIdentities.indexOf(identity);

      // If the item is in our selectedIdentities array, remove it
      if (index !== -1) {
        // If app calls prevent default, then don't remove the identity, just call preventDefault on the original event.
        if (this.trigger('layer-identity-deselected', { item: identity })) {
          this.selectedIdentities.splice(index, 1);
        } else {
          evt.preventDefault();
        }
      }
    },


    /**
     * Append a layerUI.components.IdentitiesListPanel.Item to the Document Fragment
     *
     * @method _generateItem
     * @param {layer.Identity} identity
     * @private
     */
    _generateItem: function _generateItem(identity) {
      var identityWidget = document.createElement('layer-identity-item');
      identityWidget.item = identity;
      identityWidget.id = this._getItemId(identity.id);
      identityWidget.selected = this.selectedIdentities.indexOf(identity) !== -1;
      identityWidget._runFilter(this.filter);
      return identityWidget;
    },


    /**
     * Call this on any Query change events.
     *
     * This updates the selectedIdentities after doing standard query update
     *
     * @method onRerender
     * @private
     * @param {Event} evt
     */
    onRerender: function onRerender() {
      var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      switch (evt.type) {
        // If its a remove event, find the user and remove its widget.
        case 'remove':
          {
            var removalIndex = this.selectedIdentities.indexOf(evt.target);
            if (removalIndex !== -1) this.selectedIdentities.splice(removalIndex, 1);
            break;
          }

        // If its a reset event, all data is gone, rerender everything.
        case 'reset':
          this.selectedIdentities = [];
          break;
      }
    },


    /**
     * Update the selected property of all Identity Items based on the selectedIdentities property.
     *
     * @method _renderSelection
     * @private
     */
    _renderSelection: function _renderSelection() {
      var _this2 = this;

      var selectedNodes = this.querySelectorAllArray('.layer-identity-item-selected').map(function (node) {
        return node.parentNode;
      });
      var selectedIds = this.selectedIdentities.map(function (identity) {
        return '#' + _this2._getItemId(identity.id);
      });
      var nodesToSelect = this.selectedIdentities.length ? this.querySelectorAllArray(selectedIds.join(', ')) : [];
      selectedNodes.forEach(function (node) {
        if (nodesToSelect.indexOf(node) === -1) node.selected = false;
      });
      nodesToSelect.forEach(function (node) {
        if (selectedNodes.indexOf(node) === -1) node.selected = true;
      });
    }
  }
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-identities-list", "<div class='layer-load-indicator' layer-id='loadIndicator'>Loading users...</div>", "");
  layerUI.buildStyle("layer-identities-list", "layer-identities-list {\noverflow-y: auto;\ndisplay: block;\n}\nlayer-identities-list .layer-load-indicator {\ntext-align: center;\nborder-top: solid 1px #ccc;\nfont-style: italic;\ndisplay: none;\n}\nlayer-identities-list.layer-loading-data .layer-load-indicator {\ndisplay: block;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../../../mixins/has-query":55,"../../../mixins/list":59,"../../../mixins/main-component":60,"../layer-identity-item/layer-identity-item":20,"layer-websdk":79}],20:[function(require,module,exports){
/**
 * The Layer User Item represents a single user within a User List.
 *
 * This widget could be used to represent a User elsewhere, in places where a `<layer-avatar />` is insufficient.
 *
 * This widget includes a checkbox for selection.
 *
 * @class layerUI.components.IdentitiesListPanel.Item
 * @mixin layerUI.mixins.ListItem
 * @extends layerUI.components.Component
 */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _component = require('../../../components/component');

var _listItem = require('../../../mixins/list-item');

var _listItem2 = _interopRequireDefault(_listItem);

require('../../subcomponents/layer-avatar/layer-avatar');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerComponent)('layer-identity-item', {
  mixins: [_listItem2.default],
  properties: {

    /**
     * Is this user item currently selected?
     *
     * Setting this to true will set the checkbox to checked, and add a
     * `layer-identity-item-selected` css class.
     *
     * @property {Boolean} [selected=false]
     */
    selected: {
      type: Boolean,
      set: function set(value) {
        if (this.nodes.checkbox) this.nodes.checkbox.checked = value;
        this.innerNode.classList[value ? 'add' : 'remove']('layer-identity-item-selected');
      },
      get: function get() {
        return this.nodes.checkbox ? this.nodes.checkbox.checked : Boolean(this.properties.selected);
      }
    }
  },
  methods: {
    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {
      if (!this.id) this.id = _layerWebsdk2.default.Util.generateUUID();
      this.nodes.checkbox.addEventListener('change', this._onChange.bind(this));
      this.nodes.checkbox.id = this.id + '-checkbox';
      this.nodes.title.setAttribute('for', this.nodes.checkbox.id);
    },


    /**
     * If the checkbox state changes, make sure that the class is updated.
     *
     * If the custom event is canceled, roll back the change.
     *
     * @method _onChange
     * @param {Event} evt
     * @private
     */
    _onChange: function _onChange(evt) {
      evt.stopPropagation();
      var checked = this.selected;
      var identity = this.item;

      // Trigger the event and see if evt.preventDefault() was called
      var customEventResult = this.trigger('layer-identity-item-' + (checked ? 'selected' : 'deselected'), { item: identity });

      if (customEventResult) {
        this.innerNode.classList[checked ? 'add' : 'remove']('layer-identity-item-selected');
      } else {
        this.selected = !checked;
      }
      this.onSelection(evt);
    },


    /**
     * MIXIN HOOK: Each time a an item's selection state changes, this will be called.
     *
     * @method onSelection
     */
    onSelection: function onSelection(evt) {
      // No-op
    },


    /**
     * Render/rerender the user, showing the avatar and user's name.
     *
     * @method _render
     * @private
     */
    onRender: function onRender() {
      this.onRerender();
    },


    /**
     * Update the rendering of the avatar/username
     *
     * @method _render
     * @private
     */
    onRerender: function onRerender() {
      this.nodes.avatar.users = [this.item];
      this.nodes.title.innerHTML = this.item.displayName;
      this.toggleClass('layer-identity-item-empty', !this.item.displayName);
    },


    /**
     * Run a filter on this item, and hide it if it doesn't match the filter.
     *
     * @method _runFilter
     * @param {String|Regex|Function} filter
     */
    _runFilter: function _runFilter(filter) {
      var identity = this.properties.item;
      var match = false;
      if (!filter) {
        match = true;
      } else if (filter instanceof RegExp) {
        match = filter.test(identity.displayName) || filter.test(identity.firstName) || filter.test(identity.lastName) || filter.test(identity.emailAddress);
      } else if (typeof filter === 'function') {
        match = filter(identity);
      } else {
        filter = filter.toLowerCase();
        match = identity.displayName.toLowerCase().indexOf(filter) !== -1 || identity.firstName.toLowerCase().indexOf(filter) !== -1 || identity.lastName.toLowerCase().indexOf(filter) !== -1 || identity.emailAddress.toLowerCase().indexOf(filter) !== -1;
      }
      this.classList[match ? 'remove' : 'add']('layer-item-filtered');
    }
  }
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-identity-item", "<div class='layer-list-item'><layer-avatar layer-id='avatar'></layer-avatar><label class='layer-identity-name' layer-id='title'></label><input type='checkbox' layer-id='checkbox'></input></div>", "");
  layerUI.buildStyle("layer-identity-item", "layer-identity-item {\ndisplay: flex;\nflex-direction: column;\n}\nlayer-identity-item .layer-list-item {\ndisplay: flex;\nflex-direction: row;\nalign-items: center;\n}\nlayer-identity-item .layer-list-item layer-avatar {\nmargin-right: 20px;\n}\nlayer-identity-item .layer-list-item label {\nflex-grow: 1;\nwidth: 100px; \n}\nlayer-identity-item.layer-item-filtered .layer-list-item {\ndisplay: none;\n}\nlayer-identity-item.layer-identity-item-empty {\ndisplay: none;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../../../mixins/list-item":57,"../../subcomponents/layer-avatar/layer-avatar":29,"layer-websdk":79}],21:[function(require,module,exports){
/**
 * The Layer Conversation Panel includes a Message List, Typing Indicator Panel, and a Compose bar.
 *
 * Note that its up to the developer to tell this panel what its showing by setting the `conversationId` property.
 * This property affects what messages are rendered, what typing indicators are sent and rendered, and what Conversations messages are
 * sent to when your user types into the compose bar.
 *
 * Changing the `conversationId` is as simple as:
 *
 * ```javascript
 *  function selectConversation(conversation) {
 *    conversationPanel.conversationId = conversation.id;
 *  }
 * ```
 *
 * or if using a templating engine, something like this would also work for setting the `conversationId`:
 *
 * ```
 * <layer-conversation-panel conversation-id={selectedConversationId}></layer-conversation-panel>
 * ```
 *
 * This Component can be added to your project directly in the HTML file:
 *
 * ```
 * <layer-conversation-panel></layer-conversation-panel>
 * ```
 *
 * Or via DOM Manipulation:
 *
 * ```javascript
 * var conversation = document.createElement('layer-conversation-panel');
 * ```
 *
 * ## Key Properties
 *
 * * layerUI.components.ConversationPanel.conversationId (attribute-name: `conversation-id`): Set what conversation is being viewed
 * * layerUI.components.ConversationPanel.queryId (attribute-name: `query-id`): If your app already has a layer.Query, you can provide it to this widget to render and page through its Messages.  If you don't have a layer.Query instance, this widget will generate one for you.
 *
 * NOTE: If you provide your own Query, you must update its predicate when changing Conversations.
 *
 * ## Events
 *
 * Events listed here come from either this component, or its subcomponents.
 *
 * * {@link layerUI.components.subcomponents.Composer#layer-send-message layer-send-message}: User has requested their Message be sent
 * * {@link layerUI.components.subcomponents.Delete#layer-message-deleted layer-message-deleted}: User has requested a Message be deleted
 * * {@link layerUI.components.subcomponents.TypingIndicator#layer-typing-indicator-change layer-typing-indicator-change}: Someone in the Conversation has started/stopped typing
 *
 * @class layerUI.components.ConversationPanel
 * @extends layerUI.components.Component
 * @mixin layerUI.mixins.MainComponent
 */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _component = require('../../components/component');

var _mainComponent = require('../../mixins/main-component');

var _mainComponent2 = _interopRequireDefault(_mainComponent);

var _hasQuery = require('../../mixins/has-query');

var _hasQuery2 = _interopRequireDefault(_hasQuery);

var _focusOnKeydown = require('../../mixins/focus-on-keydown');

var _focusOnKeydown2 = _interopRequireDefault(_focusOnKeydown);

require('../messages-list-panel/layer-messages-list/layer-messages-list');

require('../subcomponents/layer-composer/layer-composer');

require('../subcomponents/layer-typing-indicator/layer-typing-indicator');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerComponent)('layer-conversation-panel', {
  mixins: [_mainComponent2.default, _hasQuery2.default, _focusOnKeydown2.default],

  /**
   * This event is triggered before any Message is sent.
   *
   * You can use this event to provide your own logic for sending the Message.
   *
   * ```javascript
   * conversationPanel.onSendMessage = function(evt) {
   *   evt.preventDefault();
   *   var message = evt.detail.item;
   *   myAsyncLookup(function(result) {
   *     var part = new layer.MessagePart({
   *       mimeType: 'application/json',
   *       body: result
   *     });
   *     message.addPart(part);
   *     message.send();
   *   });
   * };
   * ```
   *
   * @property {Function} onSendMessage
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Message} evt.detail.item
   */

  /**
   * This event is triggered before any Message is sent.
   *
   * You can use this event to provide your own logic for sending the Message.
   *
   * ```javascript
   * document.body.addEventListener('layer-send-message', function(evt) {
   *   evt.preventDefault();
   *   var message = evt.detail.item;
   *   myAsyncLookup(function(result) {
   *     var part = new layer.MessagePart({
   *       mimeType: 'application/json',
   *       body: result
   *     });
   *     message.addPart(part);
   *     message.send();
   *   });
   * });
   * ```
   *
   * @event layer-send-message
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Message} evt.detail.item
   * @param {Object} evt.detail.notification
   */

  /**
   * This event is triggered before the Message is deleted.
   *
   * You can use this event to provide your own logic for deleting the Message, or preventing it from being deleted.
   *
   * ```javascript
   * conversationPanel.onMessageDeleted = function(evt) {
   *   evt.preventDefault();
   *   var message = evt.detail.item;
   *   message.delete(layer.Constants.DELETION_MODES.MY_DEVICES);
   * };
   * ```
   *
   * @property {Function} onMessageDeleted
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Message} evt.detail.item
   */

  /**
   * This event is triggered before the Message is deleted.
   *
   * You can use this event to provide your own logic for deleting the Message, or preventing it from being deleted.
   *
   * ```javascript
   * document.body.addEventListener('layer-message-deleted', function(evt) {
   *   evt.preventDefault();
   *   var message = evt.detail.item;
   *   message.delete(layer.Constants.DELETION_MODES.MY_DEVICES);
   * });
   * ```
   *
   * @event layer-message-deleted
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Message} evt.detail.item
   */

  /**
   * Custom handler to use for rendering typing indicators.
   *
   * By calling `evt.preventDefault()` on the event you can provide your own custom typing indicator text to this widget:
   *
   * ```javascript
   * conversationPanel.onTypingIndicator = function(evt) {
   *    evt.preventDefault();
   *    var widget = evt.target;
   *    var typingUsers = evt.detail.typing;
   *    var pausedUsers = evt.detail.paused;
   *    var text = '';
   *    if (typingUsers.length) text = typingUsers.length + ' users are typing';
   *    if (pausedUsers.length && typingUsers.length) text += ' and ';
   *    if (pausedUsers.length) text += pausedUsers.length + ' users have paused typing';
   *    widget.value = text;
   * };
   * ```
   *
   * Note that as long as you have called `evt.preventDefault()` you can also just directly manipulate child domNodes of `evt.detail.widget`
   * if a plain textual message doesn't suffice.
   *
   * @property {Function} onTypingIndicatorChange
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Identity[]} evt.detail.typing
   * @param {layer.Identity[]} evt.detail.paused
   */

  /**
   * Custom handler to use for rendering typing indicators.
   *
   * By calling `evt.preventDefault()` on the event you can provide your own custom typing indicator text to this widget:
   *
   * ```javascript
   * document.body.addEventListener('layer-typing-indicator-change', function(evt) {
   *    evt.preventDefault();
   *    var widget = evt.target;
   *    var typingUsers = evt.detail.typing;
   *    var pausedUsers = evt.detail.paused;
   *    var text = '';
   *    if (typingUsers.length) text = typingUsers.length + ' users are typing';
   *    if (pausedUsers.length && typingUsers.length) text += ' and ';
   *    if (pausedUsers.length) text += pausedUsers.length + ' users have paused typing';
   *    widget.value = text;
   * });
   * ```
   *
   * Note that as long as you have called `evt.preventDefault()` you can also just directly manipulate child domNodes of `evt.detail.widget`
   * if a plain textual message doesn't suffice.
   *
   * @event layer-typing-indicator-change
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Identity[]} evt.detail.typing
   * @param {layer.Identity[]} evt.detail.paused
   */

  /**
   * This event is triggered whenever the composer value changes.
   *
   * This is not a cancelable event.
   *
   * ```javascript
   * conversationPanel.onComposerChangeValue = function(evt) {
   *   this.setState({composerValue: evt.detail.value});
   * }
   * ```
   *
   * @property {Function} onComposerChangeValue
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {String} evt.detail.value
   * @param {String} evt.detail.oldValue
   */
  events: ['layer-message-deleted', 'layer-send-message', 'layer-typing-indicator-change', 'layer-composer-change-value'],

  properties: {

    // Documented in mixins/has-query.js
    query: {
      set: function set(value) {
        this.nodes.list.query = value;
      }
    },

    /**
     * ID of the Conversation being shown by this panel.
     *
     * This Conversation ID specifies what conversation to render and interact with.
     * This property needs to be changed any time you change to view a different Conversation.
     *
     * Alternative: See layerUI.components.LayerConversation.conversation property.  Strings however are easier to stick
     * into html template files.
     *
     * ```
     * function selectConversation(selectedConversation) {
     *   // These two lines are equivalent:
     *   widget.conversation = selectedConversation;
     *   widget.conversationId = selectedConversation.id;
     * }
     * ```
     *
     * @property {String} [conversationId='']
     */
    conversationId: {
      set: function set(value) {
        var _this = this;

        if (value && value.indexOf('layer:///conversations') !== 0 && value.indexOf('layer:///channels') !== 0) this.properties.conversationId = '';
        if (this.client) {
          if (this.conversationId) {
            if (this.client.isReady && !this.client.isDestroyed) {
              this.conversation = this.client.getObject(this.conversationId, true);
            } else {
              this.client.once('ready', function () {
                if (_this.conversationId) _this.conversation = _this.client.getObject(_this.conversationId, true);
              });
            }
          } else {
            this.conversation = null;
          }
        }
      }
    },

    /**
     * The Conversation being shown by this panel.
     *
     * This Conversation ID specifies what conversation to render and interact with.
     * This property needs to be changed any time you change to view a different Conversation.
     *
     * Alternative: See layerUI.components.LayerConversation.conversationId property for an easier property to use
     * within html templates.
     *
     * ```
     * function selectConversation(selectedConversation) {
     *   // These two lines are equivalent:
     *   widget.conversationId = selectedConversation.id;
     *   widget.conversation = selectedConversation;
     * }
     * ```
     *
     * @property {layer.Container}
     */
    conversation: {
      set: function set(value) {
        if (value && !(value instanceof _layerWebsdk2.default.Conversation || value instanceof _layerWebsdk2.default.Channel)) this.properties.conversation = null;
        if (this.client) this._setupConversation();
      }
    },

    // Docs in mixins/has-query.js; new behavior here is that any change to hasGeneratedQuery means
    // that now THIS component is responsible for managing the query predicate; call _setupConversation to see that done.
    hasGeneratedQuery: {
      set: function set(value) {
        if (value && this.conversationId && this.client) this._setupConversation();
      },

      type: Boolean
    },

    /**
     * Refocus on the Conversation Panel any time the Conversation ID changes.
     *
     * So, the user clicked on a Conversation in a Conversation List, and focus is no longer on this widget?
     * Automatically refocus on it.
     *
     * @property {Boolean} [autoFocusConversation=true]
     */
    autoFocusConversation: {
      value: true,
      type: Boolean
    },

    // Docs in mixins/main-component.js
    client: {
      set: function set(value) {
        if (value) {
          if (!this.conversation && this.conversationId) this.conversation = value.getObject(this.conversationId, true);
          if (this.conversation) this._setupConversation();
        }
      }
    },

    /**
     * Function allows for additional dom nodes to be generated and inserted before/after messages
     *
     * ```
     * conversationPanel.onRenderListItem = function(widget, messages) {
     *   var message = widget.item;
     *   if (message.sentAt.toDateString() !== messages[index - 1].sentAt.toDateString()) {
     *     widget.customNodeAbove = document.createElement('hr');
     *     widget.customNodeBelow = document.createElement('hr');
     *   }
     *  });
     * ```
     *
     * @property {Function} onRenderListItem
     * @property {layerUI.components.MessagesListPanel.Item} onRenderListItem.widget
     *    One row of the list
     * @property {layer.Message[]} onRenderListItem.items
     *    full set of messages in the list
     * @property {Number} onRenderListItem.index
     *    index of the message in the items array
     * @property {Boolean} onRenderListItem.isTopItemNew
     *    If the top item is index 0, and its newly added rather than just affected by changes
     *    around it, this is often useful to know.
     */
    onRenderListItem: {
      type: Function,
      set: function set(value) {
        this.nodes.list.onRenderListItem = value;
      },
      get: function get() {
        return this.nodes.list.onRenderListItem;
      }
    },

    /**
     * Provide property to override the function used to render a date for each Message Item.
     *
     * Note that changing this will not rerender the list.
     *
     * ```javascript
     * conversationPanel.dateRenderer = function(date) {
     *    return date.toISOString();
     * };
     * ```
     *
     * @property {Function} [dateRenderer=null]
     */
    dateRenderer: {
      type: Function,
      set: function set(value) {
        this.nodes.list.dateRenderer = value;
      }
    },

    /**
     * Provide property to override the function used to render a date for each Message Item.
     *
     * Note that changing this will not rerender the list.
     *
     * ```javascript
     * conversationPanel.messageStatusRenderer = function(message) {
     *    return message.readStatus === layer.Constants.RECIPIENT_STATE.ALL ? 'read' : 'processing...';
     * };
     * ```
     *
     * See layer.Message for more information on the properties available to determine a message's status.
     *
     * @property {Function} [messageStatusRenderer=null]
     */
    messageStatusRenderer: {
      type: Function,
      set: function set(value) {
        this.nodes.list.messageStatusRenderer = value;
      }
    },

    /**
     * A dom node to render when there are no messages in the list.
     *
     * Could just be a message "Empty Conversation".  Or you can add interactive widgets.
     *
     * ```
     * var div = document.createElement('div');
     * div.innerHTML = 'Empty Conversation';
     * widget.emptyMessageListNode = div;
     * ```
     *
     * @property {HTMLElement} [emptyMessageListNode=null]
     */
    emptyMessageListNode: {
      type: HTMLElement,
      set: function set(value) {
        this.nodes.list.emptyNode = value;
      },
      get: function get(value) {
        return this.nodes.list.emptyNode;
      }
    },

    /**
     * Deletion of this Message is enabled.
     *
     * ```
     * widget.getMessageDeleteEnabled = function(message) {
     *    return message.sender.sessionOwner;
     * }
     * ```
     *
     * @property {Function}
     */
    getMessageDeleteEnabled: {
      type: Function,
      value: function value(message) {
        return message.sender.sessionOwner;
      },
      set: function set(value) {
        this.nodes.list.getMessageDeleteEnabled = value;
      }
    },

    /**
     * An array of buttons (dom nodes) to be added to the Compose bar, right side.
     *
     * ```
     * widget.composeButtons = [
     *     document.createElement('button'),
     *     document.createElement('button')
     * ];
     * ```
     *
     * @property {HTMLElement[]} [composeButtons=[]]
     */
    composeButtons: {
      type: HTMLElement,
      set: function set(value) {
        this.nodes.composer.buttons = value;
      }
    },

    /**
     * An array of buttons (dom nodes) to be added to the Compose bar, left side.
     *
     * ```
     * widget.composeButtonsLeft = [
     *     document.createElement('button'),
     *     document.createElement('button')
     * ];
     * ```
     *
     * @property {HTMLElement[]} [composeButtonsLeft=[]]
     */
    composeButtonsLeft: {
      type: HTMLElement,
      set: function set(value) {
        this.nodes.composer.buttonsLeft = value;
      }
    },

    /**
     * Use this to get/set the text in the Compose bar.
     *
     * ```
     * widget.composeText = 'This text will appear in the editor within the compose bar';
     * var message = conversation.createMessage(widget.composeText);
     * ```
     *
     * @property {String} [composeText='']
     */
    composeText: {
      get: function get() {
        return this.nodes.composer.value;
      },
      set: function set(value) {
        this.nodes.composer.value = value;
      }
    },

    /**
     * Use this to get/set the text in the Compose bar.
     *
     * ```
     * widget.composePlaceholder = 'Enter a message. Or dont. It really doesnt matter.';
     * ```
     *
     * @property {String} [composePlaceholder='']
     */
    composePlaceholder: {
      get: function get() {
        return this.nodes.composer.placeholder;
      },
      set: function set(value) {
        this.nodes.composer.placeholder = value;
      }
    },

    /**
     * Disable the widget to disable read receipts and other behaviors that may occur while the widget is hidden.
     *
     * ```
     * widget.disable = true;
     * ```
     *
     * @property {Boolean}
     */
    disable: {
      type: Boolean,
      set: function set(value) {
        this.nodes.list.disable = value;
      }
    },

    /**
     * The model to generate a Query for if a Query is not provided.
     *
     * @readonly
     * @private
     * @property {String} [_queryModel=layer.Query.Message]
     */
    _queryModel: {
      value: _layerWebsdk2.default.Query.Message
    }
  },
  methods: {
    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {},


    /**
     * When a key is pressed and text is not focused, focus on the composer
     *
     * @method onKeyDown
     */
    onKeyDown: function onKeyDown() {
      this.focusText();
    },


    /**
     * Place focus on the text editor in the Compose bar.
     *
     * ```
     * widget.focusText();
     * ```
     *
     * @method
     */
    focusText: function focusText() {
      this.nodes.composer.focus();
    },


    /**
     * Send the Message that the user has typed in... or that you have specified.
     *
     * ```
     * widget.composeText = "Hello world";
     * widget.send(); // send the current text in the textarea
     * ```
     *
     * ```
     * widget.send(parts); // send custom message parts but NOT the text in the textarea
     * ```
     *
     * @method
     * @param {layer.MessagePart[]} optionalParts
     */
    send: function send(optionalParts) {
      var _nodes$composer;

      var args = optionalParts ? [optionalParts] : [];
      (_nodes$composer = this.nodes.composer).send.apply(_nodes$composer, args);
    },


    /**
     * Given a Conversation ID and a Client, setup the Composer and Typing Indicator
     *
     * @method _setupConversation
     * @private
     */
    _setupConversation: function _setupConversation() {
      var conversation = this.properties.conversation;

      // Client not ready yet? retry once authenticated.
      if (this.client && !this.client.isReady) {
        this.client.once('ready', this._setupConversation.bind(this));
        return;
      } else if (!this.client) {
        return;
      }

      this.nodes.composer.conversation = conversation;
      this.nodes.typingIndicators.conversation = conversation;
      if (this.hasGeneratedQuery) {
        if (conversation instanceof _layerWebsdk2.default.Conversation) {
          this.query.update({
            predicate: 'conversation.id = "' + conversation.id + '"'
          });
        } else if (conversation instanceof _layerWebsdk2.default.Channel) {
          this.query.update({
            predicate: 'channel.id = "' + conversation.id + '"'
          });
        } else {
          this.query.update({
            predicate: ''
          });
        }
      }
      if (this.autoFocusConversation) this.focusText();
    }
  }
});

(function () {
  var layerUI = require('../../base');
  layerUI.buildAndRegisterTemplate("layer-conversation-panel", "<layer-messages-list layer-id='list'></layer-messages-list><layer-typing-indicator layer-id='typingIndicators'></layer-typing-indicator><layer-composer layer-id='composer'></layer-composer>", "");
  layerUI.buildStyle("layer-conversation-panel", "layer-conversation-panel {\ndisplay: flex;\nflex-direction: column;\noutline: none; \n}\nlayer-messages-list {\nflex-grow: 1;\nheight: 100px;\n}\nlayer-composer {\nborder-top: 1px solid #dedede;\nmin-height: 30px;\n}", "");
})();
},{"../../base":14,"../../components/component":15,"../../mixins/focus-on-keydown":54,"../../mixins/has-query":55,"../../mixins/main-component":60,"../messages-list-panel/layer-messages-list/layer-messages-list":28,"../subcomponents/layer-composer/layer-composer":31,"../subcomponents/layer-typing-indicator/layer-typing-indicator":40,"layer-websdk":79}],22:[function(require,module,exports){
/**
                                  * The Layer Notifier widget can show Desktop Notifications when your app is in the background,
                                  * and Toast notifications when your app is in the foreground.
                                  *
                                  * You can customize the toast styling and layout by providing a custom Template.
                                  *
                                  * Add this to your page as:
                                  *
                                  * ```
                                  * <layer-notifier notify-in-foreground="toast" icon-url="https://myco.com/myimage.png"></layer-notifier>
                                  * ```
                                  *
                                  * Or via DOM Manipulation:
                                  *
                                  * ```javascript
                                  * var notifier = document.createElement('layer-notifier');
                                  * notifier.notifyInForeground = 'toast';
                                  * notifier.iconUrl = 'https://myco.com/myimage.png';
                                  * ```
                                  *
                                  * Note that you typically would not want to have a notification if your app is in the foreground,
                                  * and the new message is already visible to the user.  However,
                                  * this widget does not know what conversation is currently visible, so its up to you to manage this.
                                  *
                                  * Provide a layerUI.components.misc.Notifier.onMessageNotification handler to perform tests to see
                                  * if notifications are required, and then call `evt.preventDefault()` to prevent the notification from showing.
                                  *
                                  * @class layerUI.components.Notifier
                                  * @extends layerUI.components.Component
                                  */'use strict';

var _notifyjs = require('notifyjs');

var _notifyjs2 = _interopRequireDefault(_notifyjs);

var _base = require('../../base');

var _component = require('../../components/component');

var _mainComponent = require('../../mixins/main-component');

var _mainComponent2 = _interopRequireDefault(_mainComponent);

require('../subcomponents/layer-avatar/layer-avatar');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Notify = _notifyjs2.default; 

if ('default' in Notify) Notify = Notify.default; // Annoying difference between webpack and browserify...

(0, _component.registerComponent)('layer-notifier', {
  mixins: [_mainComponent2.default],

  /**
   * Before showing any notification, this event will be triggered.
   *
   * Call `evt.preventDefault()`
   * to prevent the notification from being rendered.  Not calling `preventDefault()` allows the notification to occur.
   * This lets you customize behaviors on a per-notification basis.
   *
   * ```
   * document.body.addEventListener('layer-message-notification', function(evt) {
   *   if (evt.detail.item.conversationId === myOpenConversationId) {
   *     evt.preventDefault();
   *   }
   * }
   * ```
   *
   * @event layer-message-notification
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Message} evt.detail.item     The Message that has triggered this notification
   * @param {Boolean} evt.detail.isBackground   Is the app running in the background
   * @param {String} evt.detail.type            What type of notification has been configured for this event ("desktop" or "toast")
   */
  /**
   * Before showing any notification, this event will be triggered.
   *
   * Call `evt.preventDefault()`
   * to prevent the notification from being rendered.  Not calling `preventDefault()` allows the notification to occur.
   * This lets you customize behaviors on a per-notification basis.
   *
   * ```
   * notifier.onMessageNotification = function(evt) {
   *   if (evt.detail.item.conversationId === myOpenConversationId && !evt.detail.isBackground) {
   *     evt.preventDefault();
   *   }
   * }
   * ```
   *
   * @property {Function} onMessageNotification
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Message} evt.detail.item     The Message that has triggered this notification
   * @param {Boolean} evt.detail.isBackground   Is the app running in the background
   * @param {String} evt.detail.type            What type of notification has been configured for this event ("desktop" or "toast")
   */

  /**
   * Use this event to handle the user clicking on the notification.
   *
   * ```
   * document.body.addEventListener('layer-notification-click', function(evt) {
   *   if (evt.detail.item.conversationId !== myOpenConversationId && !evt.detail.isBackground) {
   *     // Open the Conversation:
   *     document.querySelector('layer-conversation').conversationId = evt.detail.item.conversationId;
   *   }
   * });
   * ```
   *
   * @event layer-notification-click
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Message} evt.detail.item   The Message that has triggered this notification
   */

  /**
   * Use this event to handle the user clicking on the notification.
   *
   * ```
   * notifier.onNotificationClick = function(evt) {
   *   if (evt.detail.item.conversationId !== myOpenConversationId) {
   *     // Open the Conversation:
   *     document.querySelector('layer-conversation').conversationId = evt.detail.item.conversationId;
   *   }
   * };
   * ```
   *
   * @property {Function} onNotificationClick
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Message} evt.detail.item   The Message that has triggered this notification
   */

  events: ['layer-message-notification', 'layer-notification-click'],
  properties: {

    // Docs in mixins/main-component.js
    client: {
      set: function set(value) {
        value.on('messages:notify', this._notify.bind(this));
      }
    },

    /**
     * When your app is in the background, how should it show notifications of new Messages.
     *
     * Possible values:
     *
     * * desktop: Use desktop notifications when app is in the background
     * * toast: Use in-page toast notifications when app is in the background
     * * none or "": No notifications
     *
     * ```
     * <layer-notifier notify-in-background="none"></layer-notifier>
     * ```
     *
     * @property {String} [notifyInBackground=desktop]
     */
    notifyInBackground: {
      value: 'desktop',
      set: function set(value) {
        if (value === 'desktop' && window.Notification) {
          Notify.requestPermission(this._onPermissionGranted.bind(this));
        }
      }
    },

    /**
     * When your app is in the foreground, how should it show notifications of new Messages.
     *
     * Possible values:
     *
     * * desktop: Use desktop notifications when app is in the foreground
     * * toast: Use in-page toast notifications when app is in the foreground
     * * none or "": No notifications
     *
     * * ```
     * <layer-notifier notify-in-foreground="toast"></layer-notifier>
     * ```
     *
     * @property {String} [notifyInForeground=none]
     */
    notifyInForeground: {
      value: 'none',
      set: function set(value) {
        if (value === 'desktop' && window.Notification) {
          Notify.requestPermission(this._onPermissionGranted.bind(this));
        }
      }
    },

    /**
     * Modify the window titlebar to notify users of new messages
     *
     * NOTE: Rather than always show this indicator whenever there are unread messages, we only show
     * this indicator if the most recently received message is unread.  Further, this will not show
     * after reloading the app; its assumed that the user who reloads your app has seen what they want
     * to see, and that the purpose of this indicator is to flag new stuff that should bring them back to your window.
     *
     * See layerUI.components.Notifier.notifyCharacterForTitlebar for more controls.
     *
     * @property {String} notifyInTitleBar
     */
    notifyInTitlebar: {
      type: Boolean,
      value: true
    },

    /**
     * Set a character or string to prefix your window titlebar with when there are unread messages.
     *
     * This property is used if layerUI.components.Notifier.notifyInTitlebar is enabled.
     *
     * @property {String} notifyCharacterForTitlebar
     */
    notifyCharacterForTitlebar: {
      value: '⬤'
    },

    /**
     * Set to true to force the notifier to show the unread badge in the titlebar, or set to false to force it to remove this.
     *
     * Use this at runtime to modify the badging behavior, use layerUI.components.Notifier.notifyInTitlebar to enable/disable
     * badging.  Treat this as state rather than setting.
     *
     * If you want to just set the badge until the message is marked as read, use layerUI.components.Notifier.flagTitlebarForMessage
     *
     * @property {Boolean} flagTitlebar
     */
    flagTitlebar: {
      type: Boolean,
      value: false,
      set: function set(value) {
        if (value) {
          if (document.title.indexOf(this.notifyCharacterForTitlebar) !== 0) {
            document.title = this.notifyCharacterForTitlebar + ' ' + document.title;
          }
        } else if (document.title.indexOf(this.notifyCharacterForTitlebar) === 0) {
          document.title = document.title.substring(this.notifyCharacterForTitlebar.length + 1);
        }
      }
    },

    /**
     * Tells the notifier to put a badge in the titlebar for the specified message if its unread, and clear it once read.
     *
     * @property {layer.Message} flagTitlebarForMessage
     */
    flagTitlebarForMessage: {
      set: function set(message, oldMessage) {
        if (oldMessage) oldMessage.off(null, this._handleTitlebarMessageChange, this);
        if (!message || message.isRead) {
          this.flagTitlebar = false;
        } else {
          this.flagTitlebar = true;
          message.on('messages:change', this._handleTitlebarMessageChange, this);
        }
      }
    },

    /**
     * If the user hasn't granted priveledges to use desktop notifications, they won't be shown.
     *
     * This is a state property set by this component if/when the user/browser has approved the necessary permissions.
     *
     * @property {Boolean} [userEnabledDesktopNotifications=false]
     * @readonly
     */
    userEnabledDesktopNotifications: {
      value: false
    },

    /**
     * To provide a custom icon to render within notifications, put the URL here.
     *
     * Leave this blank to use the sender's `avatarUrl` as the notification icon.
     *
     * * ```
     * <layer-notifier icon-url="https://myco.co/logo.png"></layer-notifier>
     * ```
     *
     * @property {String} [iconUrl=]
     */
    iconUrl: {
      value: ''
    },

    /**
     * Number of seconds the notification will stay before its automatically dismissed.
     *
     * * ```
     * <layer-notifier timeout-seconds="60"></layer-notifier>
     * ```
     *
     * @property {Number} [timeoutSeconds=30]
     */
    timeoutSeconds: {
      type: Number,
      value: 30
    },

    /**
     * Timeout ID for clearing the toast notification
     *
     * @private
     * @property {Number} [_toastTimeout=0]
     */
    _toastTimeout: {
      value: 0
    }
  },
  methods: {

    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {
      this.addEventListener('click', this.onClickToast.bind(this));
      this.addEventListener('transitionend', this._afterTransition.bind(this), true);
    },


    /**
     * After finishing an animation, trigger this callback which removes the animation classes.
     *
     * @method _afterTransition
     * @private
     */
    _afterTransition: function _afterTransition() {
      this.classList.remove('layer-notifier-toast-fade');
    },


    /**
     * Callback indicating that the user has granted permissions for desktop notifications.
     *
     * @method _onPermissionGranted
     * @private
     */
    _onPermissionGranted: function _onPermissionGranted() {
      this.properties.userEnabledDesktopNotifications = true;
    },


    /**
     * Notify the user of a new messages.
     *
     * Determines if foreground or background notifications are being used,
     * and what type of notification is preferred for that state.
     *
     * Triggers an event so the app can confirm/block the notification.
     *
     * @method _notify
     * @param {layer.LayerEvent} evt
     * @private
     */
    _notify: function _notify(evt) {
      var isBackground = (0, _base.isInBackground)();
      var type = isBackground ? this.notifyInBackground : this.notifyInForeground;
      var message = evt.message;

      // Note: desktopNotify does a message.off() call that deletes all event handlers associated with this widget;
      // so make sure it gets called AFTER titlebarNotify which has a more precise off() call
      // TODO: Fix this.
      if (this.notifyInTitlebar && isBackground) {
        this.flagTitlebarForMessage = message;
      }

      if (type && type !== 'none') {
        if (this.trigger('layer-message-notification', { item: message, type: type, isBackground: isBackground })) {
          if (type === 'desktop' && this.properties.userEnabledDesktopNotifications) {
            this.desktopNotify(evt.message);
          } else if (type === 'toast') {
            this.toastNotify(evt.message);
          }
        }
      }
    },


    /**
     * Whenever the flagTitlebarForMessage message changes, check if its now read.
     *
     * @method _handleTitlebarMessageChange
     * @private
     */
    _handleTitlebarMessageChange: function _handleTitlebarMessageChange() {
      var message = this.flagTitlebarForMessage;
      if (message && message.isRead) {
        this.flagTitlebar = false;
        this.flagTitlebarForMessage = null;
      }
    },


    /**
     * Show a desktop notification for this message.
     *
     * @method desktopNotify
     * @param {layer.Message} message
     */
    desktopNotify: function desktopNotify(message) {
      var _this = this;

      try {
        var text = message.getText();
        if (this.properties.desktopNotify) this.closeDesktopNotify();

        this.properties.desktopMessage = message;
        this.properties.desktopNotify = new Notify('Message from ' + message.sender.displayName, {
          icon: this.iconUrl || message.sender.avatarUrl,
          timeout: this.timeoutSeconds,
          body: text || 'New file received',
          tag: message.conversationId || 'announcement',
          closeOnClick: true,
          notifyClick: function notifyClick() {
            window.focus();
            _this.trigger('layer-notification-click', { item: message });
            _this.onDesktopClick(message);
          }
        });
        this.properties.desktopNotify.show();

        message.on('messages:change', function (evt) {
          if (message.isRead) {
            _this.closeDesktopNotify();
          }
        }, this);
      } catch (e) {
        // do nothing
      }
    },


    /**
     * Close the desktop notification.
     *
     * @method closeDesktopNotify
     */
    closeDesktopNotify: function closeDesktopNotify() {
      if (this.properties.desktopNotify) {
        this.properties.desktopNotify.close();
        this.properties.desktopMessage.off(null, null, this);
        this.properties.desktopMessage = this.properties.desktopNotify = null;
      }
    },


    /**
     * MIXIN HOOK: User has clicked on a desktop notification.
     *
     * @method
     * @param {layer.Message} message
     */
    onDesktopClick: function onDesktopClick(message) {
      // No-op
    },


    /**
     * Show a toast notification for this message.
     *
     * @method toastNotify
     * @param {layer.Message} message
     */
    toastNotify: function toastNotify(message) {
      var _this2 = this;

      var placeholder = this.querySelector('.layer-message-item-placeholder');
      var handler = (0, _base.getHandler)(message, this);

      if (handler) {
        if (placeholder) this.nodes.container.removeChild(placeholder);
        this.nodes.avatar.users = [message.sender];
        this.nodes.title.innerHTML = message.sender.displayName;

        if (this.properties._toastTimeout) clearTimeout(this.properties._toastTimeout);
        this.classList.add(handler.tagName);

        var messageHandler = document.createElement(handler.tagName);
        messageHandler.parentComponent = this;
        messageHandler.message = message;

        messageHandler.classList.add('layer-message-item-placeholder');
        this.nodes.container.appendChild(messageHandler);
        this.classList.add('layer-notifier-toast-fade');
        this.classList.add('layer-notifier-toast');
        this.properties._toastTimeout = setTimeout(this.closeToast.bind(this), this.timeoutSeconds * 1000);

        this.properties.toastMessage = message;
        message.on('messages:change', function (evt) {
          if (message.isRead) {
            _this2.closeToast();
          }
        }, this);
      }
    },


    /**
     * Close the toast notification.
     *
     * @method closeToast
     */
    closeToast: function closeToast() {
      this.classList.add('layer-notifier-toast-fade');
      this.classList.remove('layer-notifier-toast');

      clearTimeout(this.properties._toastTimeout);
      this.properties._toastTimeout = 0;
      if (this.properties.toastMessage) this.properties.toastMessage.off(null, null, this);
      this.properties.toastMessage = null;
    },


    /**
     * MIXIN HOOK: The user has clicked on the toast dialog.
     *
     * @method onClickToast
     * @private
     * @param {Event} evt
     */
    onClickToast: function onClickToast(evt) {
      if (this.properties.toastMessage) {
        evt.preventDefault();
        evt.stopPropagation();
        this.trigger('layer-notification-click', { item: this.properties.toastMessage });
        this.closeToast();
      }
    }
  }
});

(function () {
  var layerUI = require('../../base');
  layerUI.buildAndRegisterTemplate("layer-notifier", "<layer-avatar layer-id='avatar'></layer-avatar><div class='layer-message-item-main' layer-id='container'><div class='layer-notifier-title' layer-id='title'></div><div class='layer-message-item-placeholder'></div></div>", "");
  layerUI.buildStyle("layer-notifier", "layer-notifier {\nposition: fixed;\nz-index: 1000;\nright: 10px;\ntop: -10000px;\nmax-width: 40%;\nmax-height: 250px;\ndisplay: flex;\nopacity: 0;\ntransition: opacity 500ms;\n}\nlayer-notifier.layer-notifier-toast-fade {\ntop: 10px;\n}\nlayer-notifier.layer-notifier-toast {\ntop: 10px;\nflex-direction: row;\nopacity: 1;\ntransition: opacity 1s;\n}\nlayer-notifier .layer-message-item-main {\ndisplay: flex;\nflex-direction: column;\nflex-grow: 1;\n}\nlayer-notifier layer-message-text-plain {\noverflow: hidden;\nmax-height: 200px;\n}", "");
})();
},{"../../base":14,"../../components/component":15,"../../mixins/main-component":60,"../subcomponents/layer-avatar/layer-avatar":29,"notifyjs":74}],23:[function(require,module,exports){
/**
 * The Layer Membership Item represents a single user within a Membership List.
 *
 *
 * @class layerUI.components.MembershipListPanel.Item
 * @experimental
 * @mixin layerUI.mixins.ListItem
 * @extends layerUI.components.Component
 */'use strict';

var _listItem = require('../../../mixins/list-item');

var _listItem2 = _interopRequireDefault(_listItem);

var _listItemSelection = require('../../../mixins/list-item-selection');

var _listItemSelection2 = _interopRequireDefault(_listItemSelection);

var _component = require('../../component');

require('../../subcomponents/layer-avatar/layer-avatar');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerComponent)('layer-membership-item', {
  mixins: [_listItem2.default, _listItemSelection2.default],
  properties: {
    item: {
      set: function set(member) {
        if (member) member.identity.on('identities:change', this.onRerender.bind(this));
      }
    }
  },
  methods: {
    /**
     * Render/rerender the user, showing the avatar and user's name.
     *
     * @method onRender
     * @private
     */
    onRender: function onRender() {
      this.nodes.avatar.users = [this.item.identity];
      this.onRerender();
    },


    /**
     * Render/rerender changes to the Identity object or Membership object.
     *
     * @method onRerender
     * @private
     */
    onRerender: function onRerender() {
      this.nodes.title.innerHTML = this.item.identity.displayName || 'User ID ' + this.item.identity.userId;
    },


    /**
     * Run a filter on this item, and hide it if it doesn't match the filter.
     *
     * @method _runFilter
     * @param {String|Regex|Function} filter
     */
    _runFilter: function _runFilter(filter) {
      var identity = this.properties.item.identity;
      var match = false;
      if (!filter) {
        match = true;
      } else if (filter instanceof RegExp) {
        match = filter.test(identity.displayName) || filter.test(identity.firstName) || filter.test(identity.lastName) || filter.test(identity.emailAddress);
      } else if (typeof filter === 'function') {
        match = filter(identity);
      } else {
        filter = filter.toLowerCase();
        match = identity.displayName.toLowerCase().indexOf(filter) !== -1 || identity.firstName.toLowerCase().indexOf(filter) !== -1 || identity.lastName.toLowerCase().indexOf(filter) !== -1 || identity.emailAddress.toLowerCase().indexOf(filter) !== -1;
      }
      this.classList[match ? 'remove' : 'add']('layer-item-filtered');
    }
  }
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-membership-item", "<div class='layer-list-item'><layer-avatar layer-id='avatar'></layer-avatar><label class='layer-membership-name' layer-id='title'></label></div>", "");
  layerUI.buildStyle("layer-membership-item", "layer-membership-item {\ndisplay: flex;\nflex-direction: column;\n}\nlayer-membership-item .layer-list-item {\ndisplay: flex;\nflex-direction: row;\nalign-items: center;\n}\nlayer-membership-item .layer-list-item layer-avatar {\nmargin-right: 20px;\n}\nlayer-membership-item .layer-list-item label {\nflex-grow: 1;\nwidth: 100px; \n}\nlayer-membership-item.layer-item-filtered .layer-list-item {\ndisplay: none;\n}\nlayer-membership-item.layer-membership-item-empty {\ndisplay: none;\n}", "");
})();
},{"../../../base":14,"../../../mixins/list-item":57,"../../../mixins/list-item-selection":56,"../../component":15,"../../subcomponents/layer-avatar/layer-avatar":29}],24:[function(require,module,exports){
/**
 * The Layer Membership List renders a pagable list of layer.Membership objects, and allows the user to
 * see who else is in the Channel with them.
 *
 * This Component can be added to your project directly in the HTML file:
 *
 * ```
 * <layer-membership-list></layer-membership-list>
 * ```
 *
 * Or via DOM Manipulation:
 *
 * ```javascript
 * var membersList = document.createElement('layer-membership-list');
 * ```
 *
 * @class layerUI.components.MembershipListPanel.List
 * @experimental This feature is incomplete, and available as Preview only.
 * @extends layerUI.components.Component
 * @mixin layerUI.mixins.List
 * @mixin layerUI.mixins.MainComponent
 * @mixin layerUI.mixins.ListSelection
 */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _component = require('../../component');

var _list = require('../../../mixins/list');

var _list2 = _interopRequireDefault(_list);

var _mainComponent = require('../../../mixins/main-component');

var _mainComponent2 = _interopRequireDefault(_mainComponent);

var _listSelection = require('../../../mixins/list-selection');

var _listSelection2 = _interopRequireDefault(_listSelection);

require('../layer-membership-item/layer-membership-item');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerComponent)('layer-membership-list', {
  mixins: [_list2.default, _listSelection2.default, _mainComponent2.default],

  /**
   * The user has clicked to select an Member in the Membership List.
   *
   * ```javascript
   *    membersList.onMembershipSelected = function(evt) {
   *      var memberSelected = evt.detail.item;
   *
   *      // To prevent the UI from proceding to add the member to the selectedIdentities:
   *      // Note that memberAdded is not yet in selectedIdentities so that you may prevent it from being added.
   *      evt.preventDefault();
   *    };
   * ```
   *
   *  OR
   *
   * ```javascript
   *    document.body.addEventListener('layer-membership-selected', function(evt) {
   *      var memberSelected = evt.detail.item;
   *
   *      // To prevent the UI from proceding to add the member to the selectedIdentities:
   *      // Note that memberAdded is not yet in selectedIdentities so that you may prevent it from being added.
   *      evt.preventDefault();
   *    });
   * ```
   *
   * @event layer-membership-selected
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Membership} evt.detail.item
   */
  /**
   * A membership selection change has occurred
   *
   * See the {@link layerUI.components.MembershipListPanel.List#layer-membership-selected layer-membership-selected} event for more detail.
   *
   * @property {Function} onMembershipSelected
   * @param {Event} evt
   * @param {Object} evt.detail
   * @param {layer.Membership} evt.detail.item
   */

  events: ['layer-membership-selected'],
  properties: {
    /**
     * ID of the Channel whose membership is being shown by this panel.
     *
     * This property may need to be changed any time you change to view a different Channel.
     *
     * Alternative: See layerUI.components.MembershipListPanel.List.channel property.  Strings however are easier to stick
     * into html template files.
     *
     * ```
     * function selectChannel(selectedChannel) {
     *   // These two lines are equivalent:
     *   widget.channel = selectedChannel;
     *   widget.channelId = selectedChannel.id;
     * }
     * ```
     *
     * @property {String} [channelId='']
     */
    channelId: {
      set: function set(value) {
        var _this = this;

        if (value && value.indexOf('layer:///channels') !== 0 && value.indexOf('layer:///channels') !== 0) this.properties.channelId = '';
        if (this.client && this.channelId) {
          if (this.client.isReady && !this.client.isDestroyed) {
            this.channel = this.client.getObject(this.channelId, true);
          } else {
            this.client.once('ready', function () {
              if (_this.channelId) _this.channel = _this.client.getObject(_this.channelId, true);
            });
          }
        }
      }
    },

    /**
     * The Channel whose Membership is being shown by this panel.
     *
     * This property may need to be changed any time you change to view a different channel.
     *
     * Alternative: See layerUI.components.MembershipListPanel.List.channelId property for an easier property to use
     * within html templates.
     *
     * ```
     * function selectchannel(selectedChannel) {
     *   // These two lines are equivalent:
     *   widget.channelId = selectedChannel.id;
     *   widget.channel = selectedChannel;
     * }
     * ```
     *
     * @property {layer.Channel}
     */
    channel: {
      set: function set(value) {
        if (value && !(value instanceof _layerWebsdk2.default.Channel)) value = this.properties.channel = null;
        if (this.query) {
          this.query.update({
            predicate: value ? 'channel.id = "' + value.id + '"' : ''
          });
        }
      }
    },

    /**
     * The model to generate a Query for if a Query is not provided.
     *
     * @readonly
     * @private
     * @property {String} [_queryModel=layer.Query.Membership]
     */
    _queryModel: {
      value: _layerWebsdk2.default.Query.Membership
    },

    /**
     * The event name to trigger on selecting a Member.
     *
     * @readonly
     * @private
     * @property {String} [_selectedItemEventName=layer-membership-selected]
     */
    _selectedItemEventName: {
      value: 'layer-membership-selected'
    }
  },
  methods: {

    /**
     * Append a layerUI.components.IdentitiesListPanel.Item to the Document Fragment
     *
     * @method _generateItem
     * @param {layer.Membership} membership
     * @private
     */
    _generateItem: function _generateItem(membership) {
      var membershipWidget = document.createElement('layer-membership-item');
      membershipWidget.item = membership;
      membershipWidget.id = this._getItemId(membership.id);
      membershipWidget._runFilter(this.filter);
      return membershipWidget;
    }
  }
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-membership-list", "<div class='layer-load-indicator' layer-id='loadIndicator'>Loading users...</div>", "");
  layerUI.buildStyle("layer-membership-list", "layer-membership-list {\noverflow-y: auto;\ndisplay: block;\n}\nlayer-membership-list .layer-load-indicator {\ntext-align: center;\nborder-top: solid 1px #ccc;\nfont-style: italic;\ndisplay: none;\n}\nlayer-membership-list.layer-loading-data .layer-load-indicator {\ndisplay: block;\n}", "");
})();
},{"../../../base":14,"../../../mixins/list":59,"../../../mixins/list-selection":58,"../../../mixins/main-component":60,"../../component":15,"../layer-membership-item/layer-membership-item":23,"layer-websdk":79}],25:[function(require,module,exports){
/**
    * The Layer Message Item widget renders a single Message synopsis.
    *
    * This is designed to go inside of the layerUI.MessageList widget.  This widget renders the framework of information that goes around a Message,
    * but leaves it up to custom handlers to render the contents and assorted MIME Types of the messages.
    *
    * This Component has two named templates:
    *
    * * `layer-message-item-sent`: Rendering for Messages sent by the owner of this Session
    * * `layer-message-item-received`: Rendering for Messages sent by other users
    *
    * ## Advanced Customization
    *
    * The simple way to customize the widget is to modify its template.
    * For more advanced customizations where the Message Item widget needs new properties, methods and capabilities, you have two options:
    *
    * 1. Define a custom `<layer-message-item/>` widget; this works but your now entirely responsible for all of its
    *    behaviors, and can not easily integrate fixes and enhancements added to this repo. This is discussed in more
    *    detail at [docs.layer.com](https://docs.layer.com).
    * 2. Enhance the provided widget with Mixins.  Below illustrates an example of a mixin.
    *
    * A Custom Mixin can be used to add Properties and Methods to this class.
    * Any method of this class can be enhanced using a Custom Mixin, however the following methods are recommended
    * as sufficient for most solutions:
    *
    * * layerUI.components.MessagesListPanel.List.onCreate: Your widget has just been created; it has a DOM node, it has child
    *   nodes, *it has no properties*, nor does not yet have a `parentNode`.
    *   Provide an `onCreate` if there is any DOM manipulation you want to do any initialization.  (DOM Manipulation here should NOT depend
    *   upon property values).
    * * layerUI.components.MessagesListPanel.List.onAttach: Your widget now has a `parentNode`.  This is solely for initialization
    *   code that depends upon looking at the `parentNode`, and is not commonly used.
    * * layerUI.components.MessagesListPanel.List.onRender: Your Message Item widget has just been rendered for the first time.
    *   Your widget should have an `item` at this point and any property-based dom manipulation can be done at this time.
    *
    * The following example adds a search bar to the Message List
    * ```
    * layerUI.init({
    *   appId: 'my-app-id',
    *   mixins: {
    *     'layer-messages-item': {
    *       properties: {
    *         selected: {
    *           value: false,
    *           set: function(value) {
    *             if (this.nodes.checkbox) this.nodes.checkbox.checked = value;
    *           },
    *           get: function() {
    *             return this.nodes.checkbox ? this.nodes.checkbox.checked : this.properties.selected;
    *           }
    *         }
    *       },
    *       methods: {
    *         onCreate: function() {
    *           this.nodes.checkbox = document.createElement('input');
    *           this.nodes.checkbox.type = 'checkbox';
    *           this.nodes.checkbox.classList.add('custom-checkbox');
    *           this.nodes.checkbox.addEventListener('click', this._handleCustomCheckboxEvent.bind(this));
    *           this.appendChild(this.nodes.checkbox);
    *         },
    *
    *         // When the widget has been rendered is a good time to do any property based dom manipulation
    *         onRender: function() {
    *          this.nodes.checkbox.checked = this.selected;
    *         },
    *
    *         // Search is run whenver the user changes the search text, app changes the search text,
    *         // or new messages arrive that need to be searched
    *         _handleCustomCheckboxEvent(evt) {
    *           this.trigger('custom-message-checkbox-change', {
    *             isChecked: this.selected,
    *             item: this.item
    *           });
    *         }
    *       }
    *     }
    *   }
    * });
    * ```
    *
    * @class layerUI.components.MessagesListPanel.Item
    * @mixins layerUI.mixins.ListItem
    * @extends layerUI.components.Component
    */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = {
  properties: {

    // Every List Item has an item property, here it represents the Conversation to render
    item: {},

    /**
     * Deletion of this Message is enabled.
     *
     * ```
     * widget.getDeleteEnabled = function(message) {
     *    return message.sender.sessionOwner;
     * }
     * ```
     *
     * @property {Function}
     */
    getDeleteEnabled: {
      type: Function
    },

    /**
     * HTML Tag to generate for the current content
     *
     * @private
     * @property {String}
     */
    _contentTag: {
      set: function set(newTag, oldTag) {
        if (oldTag) this.removeClass(oldTag);
        if (newTag) this.addClass(newTag);
      }
    },

    /**
     * Provide property to override the function used to render a date for each Message Item.
     *
     * Note that changing this will not regenerate the list; this should be set when initializing a new List.
     *
     * ```javascript
     * messageItem.dateRenderer = function(date) {
     *    return date.toISOString();
     * };
     * ```
     *
     * @property {Function}
     */
    dateRenderer: {},

    /**
     * Provide property to override the function used to render a date for each Message Item.
     *
     * Note that changing this will not regenerate the list; this should be set when initializing a new List.
     *
     * ```javascript
     * messageItem.messageStatusRenderer = function(message) {
     *    return message.readStatus === layer.Constants.RECIPIENT_STATE.ALL ? 'read' : 'processing...';
     * };
     * ```
     *
     * @property {Function}
     */
    messageStatusRenderer: {}
  },
  methods: {
    onRender: function onRender() {
      try {

        // Setup the layer-sender-name
        if (this.nodes.sender) {
          this.nodes.sender.innerHTML = this.item.sender.displayName;
        }

        if (this.nodes.avatar) {
          this.nodes.avatar.users = [this.item.sender];
        }

        // Setup the layer-date
        if (this.nodes.date) {
          if (this.dateRenderer) this.nodes.date.dateRenderer = this.dateRenderer;
          this.nodes.date.date = this.item.sentAt;
        }

        // Setup the layer-message-status
        if (this.nodes.status && this.messageStatusRenderer) this.nodes.status.messageStatusRenderer = this.messageStatusRenderer;

        // Setup the layer-delete
        if (this.nodes.delete) {
          this.nodes.delete.enabled = this.getDeleteEnabled ? this.getDeleteEnabled(this.properties.item) : true;
        }

        // Generate the renderer for this Message's MessageParts.
        this._applyContentTag();

        // Render all mutable data
        this.onRerender();
      } catch (err) {
        console.error('layer-message-item.render(): ', err);
      }
    },

    onRerender: function onRerender() {
      var readStatus = this.properties.item.readStatus;
      var deliveryStatus = this.properties.item.deliveryStatus;
      var statusPrefix = 'layer-message-status';
      this.toggleClass('layer-unread-message', !this.properties.item.isRead);
      this.toggleClass(statusPrefix + '-read-by-all', readStatus === _layerWebsdk2.default.Constants.RECIPIENT_STATE.ALL);
      this.toggleClass(statusPrefix + '-read-by-some', readStatus === _layerWebsdk2.default.Constants.RECIPIENT_STATE.SOME);
      this.toggleClass(statusPrefix + '-read-by-none', readStatus === _layerWebsdk2.default.Constants.RECIPIENT_STATE.NONE);

      this.toggleClass(statusPrefix + '-delivered-to-all', deliveryStatus === _layerWebsdk2.default.Constants.RECIPIENT_STATE.ALL);
      this.toggleClass(statusPrefix + '-delivered-to-some', deliveryStatus === _layerWebsdk2.default.Constants.RECIPIENT_STATE.SOME);
      this.toggleClass(statusPrefix + '-delivered-to-none', deliveryStatus === _layerWebsdk2.default.Constants.RECIPIENT_STATE.NONE);

      this.toggleClass(statusPrefix + '-pending', this.properties.item.isSaving());
    },


    /**
     * The parent component sets the _contentTag property, and now its time to use it.
     *
     * Use that tagName to create a DOM Node to render the MessageParts.
     *
     * @method
     * @private
     */
    _applyContentTag: function _applyContentTag() {
      var _this = this;

      var messageHandler = document.createElement(this._contentTag);
      messageHandler.parentComponent = this;
      messageHandler.message = this.item;
      this.nodes.messageHandler = messageHandler;

      this.nodes.content.appendChild(messageHandler);
      _layerWebsdk2.default.Util.defer(function () {
        if (messageHandler.style.height) {
          _this.nodes.content.style.height = messageHandler.style.height;
        }
      });
    }
  }
}; 
},{"layer-websdk":79}],26:[function(require,module,exports){
'use strict';

var _component = require('../../../components/component');

var _listItem = require('../../../mixins/list-item');

var _listItem2 = _interopRequireDefault(_listItem);

var _layerMessageItemMixin = require('../layer-message-item-mixin');

var _layerMessageItemMixin2 = _interopRequireDefault(_layerMessageItemMixin);

require('../../subcomponents/layer-avatar/layer-avatar');

require('../../subcomponents/layer-date/layer-date');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _component.registerComponent)('layer-message-item-received', {
  mixins: [_listItem2.default, _layerMessageItemMixin2.default]
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-message-item-received", "<div class='layer-list-item' layer-id='innerNode'><div class='layer-message-body-and-avatar'><layer-avatar layer-id='avatar' show-presence='false'></layer-avatar><div class='layer-message-item-main'><div class='layer-message-item-content' layer-id='content'></div></div></div><div class='layer-sender-info'><div class='layer-sender-name' layer-id='sender'></div><layer-date layer-id='date'></layer-date></div></div>", "");
  layerUI.buildStyle("layer-message-item-received", "layer-message-item-received {\ndisplay: flex;\nflex-direction: column;\nalign-content: stretch;\n}\nlayer-message-item-received .layer-list-item {\ndisplay: flex;\nflex-direction: column;\nalign-content: stretch;\n}\nlayer-message-item-received .layer-message-body-and-avatar {\ndisplay: flex;\nflex-direction: row;\nalign-items: flex-end;\n}\nlayer-message-item-received  .layer-message-item-main {\nflex-grow: 1;\noverflow: hidden;\n}\nlayer-message-item-received .layer-message-item-main .layer-message-item-content {\nmax-width: 90%;\n}\nlayer-message-item-received layer-message-text-plain {\ndisplay: block;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../../../mixins/list-item":57,"../../subcomponents/layer-avatar/layer-avatar":29,"../../subcomponents/layer-date/layer-date":34,"../layer-message-item-mixin":25}],27:[function(require,module,exports){
'use strict';

var _component = require('../../../components/component');

var _listItem = require('../../../mixins/list-item');

var _listItem2 = _interopRequireDefault(_listItem);

var _layerMessageItemMixin = require('../layer-message-item-mixin');

var _layerMessageItemMixin2 = _interopRequireDefault(_layerMessageItemMixin);

require('../../subcomponents/layer-avatar/layer-avatar');

require('../../subcomponents/layer-delete/layer-delete');

require('../../subcomponents/layer-date/layer-date');

require('../../subcomponents/layer-message-status/layer-message-status');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _component.registerComponent)('layer-message-item-sent', {
  mixins: [_listItem2.default, _layerMessageItemMixin2.default]
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-message-item-sent", "<div class='layer-list-item' layer-id='innerNode'><div class='layer-message-body-and-avatar' layer-id='messageRow'><div class='layer-message-item-main'><div class='layer-message-item-content' layer-id='content'></div></div><div class='layer-avatar-delete-panel'><layer-avatar layer-id='avatar' show-presence='false'></layer-avatar><layer-delete layer-id='delete'></layer-delete></div></div><div class='layer-sender-info layer-sender-details'><div class='layer-sender-name' layer-id='sender'></div><layer-message-status layer-id='status'></layer-message-status><layer-date layer-id='date'></layer-date></div></div>", "");
  layerUI.buildStyle("layer-message-item-sent", "layer-message-item-sent {\ndisplay: flex;\nflex-direction: column;\nalign-content: stretch;\n}\nlayer-message-item-sent img.emoji {\nmargin: 0 .05em 0 .1em;\nvertical-align: -0.1em;\n}\nlayer-message-item-sent .layer-list-item {\ndisplay: flex;\nflex-direction: column;\nalign-items: stretch;\n}\nlayer-message-item-sent .layer-message-body-and-avatar {\ndisplay: flex;\nflex-direction: row;\nalign-items: flex-end;\nflex-grow: 1;\n}\nlayer-message-item-sent .layer-message-item-main {\ntext-align: right;\nflex-grow: 1;\noverflow: hidden;\n}\nlayer-message-item-sent .layer-message-item-main .layer-message-item-content {\ndisplay: inline-block;\ntext-align: right;\nmax-width: 90%;\n}\nlayer-message-item-sent layer-message-text-plain {\ndisplay: block;\n}\nlayer-message-item-sent .layer-avatar-delete-panel {\ndisplay: flex;\nflex-direction: row;\nalign-items: center;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../../../mixins/list-item":57,"../../subcomponents/layer-avatar/layer-avatar":29,"../../subcomponents/layer-date/layer-date":34,"../../subcomponents/layer-delete/layer-delete":35,"../../subcomponents/layer-message-status/layer-message-status":37,"../layer-message-item-mixin":25}],28:[function(require,module,exports){
/**
                          * The Layer Message List widget renders a scrollable, pagable list of layerUI.components.MessagesListPanel.Item widgets.
                          *
                          * This is designed to go inside of the layerUI.Conversation widget.
                          *
                          * This Component has two named templates:
                          *
                          * * `layer-message-item-sent`: Rendering for Messages sent by the owner of this Session
                          * * `layer-message-item-received`: Rendering for Messages sent by other users
                          *
                          * Messages are organized into sets where a set starts with the first message from a given user, and ends when either
                          * a different user sends a Message, or a long enough pause occurs.  Each Message will have firstInSeries/lastInSeries properties,
                          * and these need to be maintained as new Messages are loaded, deleted, etc...
                          *
                          * ## Advanced Customization
                          *
                          * To enhance the Message List widget with new properties, methods and capabilities, you have two options:
                          *
                          * 1. Define a custom `<layer-message-list/>` widget; this works but your now entirely responsible for all of its
                          *    behaviors, and can not easily integrate fixes and enhancements added to this repo. Defining components is discussed in
                          *    layerUI.components.Component.
                          * 2. Enhance the provided widget with Mixins.  Details of Mixins are described in layerUI.components.Component.
                          *    Below illustrates an example of a mixin for modifying this widget.
                          *
                          *
                          * The following example adds a search bar to the Message List
                          *
                          * ```
                          * layerUI.init({
                          *   appId: 'my-app-id',
                          *   layer: window.layer,
                          *   mixins: {
                          *     'layer-messages-list': {
                          *       properties: {
                          *         searchText: {
                          *           value: '',
                          *           set: function(value) {
                          *             this.nodes.searchBar.value = value;
                          *             this._runSearch();
                          *           },
                          *           get: function() {
                          *             return this.nodes.searchBar.value;
                          *           }
                          *         }
                          *       },
                          *       methods: {
                          *         // When the widget is created, setup/initialize our custom behaviors
                          *         onCreate: function() {
                          *           this.nodes.searchBar = document.createElement('input');
                          *           this.nodes.searchBar.classList.add('custom-search-bar');
                          *           this.nodes.searchBar.addEventListener('change', this._runSearch.bind(this));
                          *           this.insertBefore(this.nodes.searchBar, this.firstChild);
                          *         },
                          *
                          *
                          *         // Whenver any messages are added/removed/changed, rerun our search
                          *         onRerender: function() {
                          *           if (this.searchText) this._runSearch();
                          *         },
                          *
                          *         // Search is run whenver the user changes the search text, app changes the search text,
                          *         // or new messages arrive that need to be searched
                          *         _runSearch() {
                          *           var searchText = this.searchText;
                          *           Array.prototype.slice.call(this.childNodes).forEach(function(messageItem) {
                          *             if (messageItem._isListItem) {
                          *               var message = messageItem.item;
                          *               if (message.parts[0].body.indexOf(searchText) === -1) {
                          *                 messageItem.classList.remove('search-matches');
                          *               } else {
                          *                 messageItem.classList.add('search-matches');
                          *               }
                          *             }
                          *           });
                          *         }
                          *       }
                          *     }
                          *   }
                          * });
                          * ```
                          *
                          * @class layerUI.components.MessagesListPanel.List
                          * @extends layerUI.components.Component
                          *
                          * @mixin layerUI.mixins.EmptyList
                          * @mixin layerUI.mixins.List
                          */'use strict';

var _animatedScrollto = require('animated-scrollto');

var _animatedScrollto2 = _interopRequireDefault(_animatedScrollto);

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _base = require('../../../base');

var _base2 = _interopRequireDefault(_base);

var _component = require('../../../components/component');

var _list = require('../../../mixins/list');

var _list2 = _interopRequireDefault(_list);

var _hasQuery = require('../../../mixins/has-query');

var _hasQuery2 = _interopRequireDefault(_hasQuery);

var _emptyList = require('../../../mixins/empty-list');

var _emptyList2 = _interopRequireDefault(_emptyList);

require('../layer-message-item-sent/layer-message-item-sent');

require('../layer-message-item-received/layer-message-item-received');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Mandatory delay between loading one page and the next.  If user is scrolling too fast, they'll have to wait at least (2) seconds.
var PAGING_DELAY = 2000; 


(0, _component.registerComponent)('layer-messages-list', {
  mixins: [_list2.default, _hasQuery2.default, _emptyList2.default],
  properties: {

    /**
     * Provide property to override the function used to render a date for each Message Item.
     *
     * Note that changing this will not regenerate the list; this should be set when initializing a new List.
     *
     * ```javascript
     * messageListPanel.dateRenderer = function(message) {
     *    var date = message.sentAt;
     *    return date.toISOString();
     * };
     * ```
     *
     * @property {Function} [dateRenderer=null]
     */
    dateRenderer: {},

    /**
     * Provide property to override the function used to render a date for each Message Item.
     *
     * Note that changing this will not regenerate the list; this should be set when initializing a new List.
     *
     * ```javascript
     * messageList.messageStatusRenderer = function(message) {
     *    return message.readStatus === layer.Constants.RECIPIENT_STATE.ALL ? 'read' : 'processing...';
     * };
     * ```
     *
     * @property {Function} [messageStatusRenderer=null]
     */
    messageStatusRenderer: {},

    /**
     * Deletion of this Message is enabled.
     *
     * ```
     * widget.getMessageDeleteEnabled = function(message) {
     *    return message.sender.sessionOwner;
     * }
     * ```
     *
     * @property {Function}
     */
    getMessageDeleteEnabled: {},

    /**
     * Disable read receipts and other behaviors; typically used when the widget has been hidden from view.
     *
     * ```
     * widget.disable = true;
     * ```
     *
     * @property {Boolean}
     */
    disable: {
      set: function set(value) {
        if (!value) {
          this.properties.stuckToBottom = true;
          this.scrollTo(this.scrollHeight - this.clientHeight);
          this._checkVisibility();
        }
      }
    },

    /**
     * If the user scrolls within this many screen-fulls of the top of the list, page the Query.
     *
     * If value is 0, will page once the user reaches the top.  If the value is 0.5, will page once the user
     * reaches a `scrollTop` of 1/2 `clientHeight`.
     *
     * @property {Number} [screenFullsBeforePaging=2.0]
     */
    screenFullsBeforePaging: {
      value: 2.0
    }
  },
  methods: {

    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {
      if (!this.id) this.id = _layerWebsdk2.default.Util.generateUUID();

      // Init some local props
      this.properties.lastPagedAt = 0;
      this.properties.isSelfScrolling = false;
      this.properties.stuckToBottom = true;
      this.properties._checkVisibilityBound = this._checkVisibility.bind(this);

      window.addEventListener('focus', this.properties._checkVisibilityBound);
    },


    /**
     * Cleanup all pointers to self created by registering event handlers.
     *
     * @method onDestroy
     * @private
     */
    onDestroy: function onDestroy() {
      window.removeEventListener('focus', this.properties._checkVisibilityBound);
    },


    /**
     * Tests to see if we should load a new page of data.
     *
     * 1. Tests scrollTop to see if we are close enough to the top
     * 2. Tests if we are already loading that page of data
     *
     * @method _shouldPage
     * @return {Boolean}
     * @private
     */
    _shouldPage: function _shouldPage() {
      var pagingHeight = Math.max(this.clientHeight, 300) * this.screenFullsBeforePaging;
      return this.scrollTop <= pagingHeight && this.scrollHeight > this.clientHeight + 1 && !this.isDataLoading;
    },


    /**
     * Handler is called whenever the list is scrolled.
     *
     * Scrolling is caused by user activity, OR by setting the `scrollTop`.
     * Typically, we want to stay `stuckToButton` so that any time new Messages arrive,
     * we scroll to the bottom to see them.  Any user scrolling however may disable that behavior.
     *
     * @method _handleScroll
     * @private
     */
    _handleScroll: {
      mode: _component.registerComponent.MODES.OVERWRITE,
      value: function value() {
        var _this = this;

        if (this.properties.isSelfScrolling) return;

        // If the user has scrolled within screenFullsBeforePaging of the top of the page... and if the page has enough contents to actually
        // be scrollable, page the Messages.
        if (this._shouldPage() && !this.properties.delayedPagingTimeout) {
          if (this.properties.lastPagedAt + PAGING_DELAY < Date.now()) {
            if (!this.query.isFiring) {
              this.query.update({ paginationWindow: this.query.paginationWindow + 50 });
              this.isDataLoading = this.properties.query.isFiring;
            }
          } else if (!this.properties.delayedPagingTimeout) {
            // User is scrolling kind of fast, lets slow things down a little
            this.properties.delayedPagingTimeout = setTimeout(function () {
              _this.query.update({ paginationWindow: _this.query.paginationWindow + 50 });
              _this.isDataLoading = _this.properties.query.isFiring;
              _this.properties.delayedPagingTimeout = 0;
            }, 500);
          }
        }

        // If we have scrolled to the bottom, set stuckToBottom to true, else false.
        var stuckToBottom = this.scrollHeight - 10 <= this.clientHeight + this.scrollTop;
        if (stuckToBottom !== this.properties.stuckToBottom) {
          this.properties.stuckToBottom = stuckToBottom;
        }

        // Trigger checks on visibility to update read state
        this._checkVisibility();
      }
    },

    /**
     * Scroll the list to the specified Y position in pixels.
     *
     * Will call _checkVisibility() when done.
     *
     * ```
     * widget.scrollTo(500);
     * ```
     *
     * @method scrollTo
     * @param {Number} position
     */
    scrollTo: {
      mode: _component.registerComponent.MODES.OVERWRITE,
      value: function value(position) {
        var _this2 = this;

        if (position === this.scrollTop) return;
        this.properties.isSelfScrolling = true;
        this.scrollTop = position;
        setTimeout(function () {
          _this2.properties.isSelfScrolling = false;
          _this2._checkVisibility();
        }, 200);
      }
    },

    /**
     * Scrolls the list to the specified Y position.
     *
     * Will call _checkVisibility() when done.
     *
     * ```
     * widget.animateScrollTo(500);
     * ```
     *
     * @method animateScrollTo
     * @param {Number} position
     */
    animateScrollTo: function animateScrollTo(position) {
      var _this3 = this;

      if (position === this.scrollTop) return;
      this.properties.isSelfScrolling = true;
      if (this.properties.cancelAnimatedScroll) this.properties.cancelAnimatedScroll();
      var cancel = this.properties.cancelAnimatedScroll = (0, _animatedScrollto2.default)(this, position, 200, function () {
        // Wait for any onScroll events to trigger before we clear isSelfScrolling and procede
        setTimeout(function () {
          if (cancel !== _this3.properties.cancelAnimatedScroll) return;
          _this3.properties.cancelAnimatedScroll = null;

          _this3.properties.isSelfScrolling = false;
          _this3._checkVisibility();
        }, 100);
      });
    },


    /**
     * Check which Messages are fully visible, and mark them as Read.
     *
     * TODO PERFORMANCE: Should be able to skip to the visible items and near-visible items without iterating over entire list
     *
     * NOTE: Only mark messages as read if the document has focus.  Just being visible but not in focus does not give us
     * sufficient cause to assume the user has read it.
     *
     * TODO: At some point we may need to customize whether document.hasFocus() is required; in particular, this could cause problems for anyone
     * running in an iFrame.  Is top.document.hasFocus() a suitable solution, or are there scenarios where top might not even be accessable due to
     * being a different domain?
     *
     * @method
     * @private
     */
    _checkVisibility: function _checkVisibility() {
      var _this4 = this;

      if (_base2.default.isInBackground() || this.disable) return;

      // The top that we can see is marked by how far we have scrolled.
      // However, all offsetTop values of the child nodes will be skewed by the value of this.nodes.loadIndicator.offsetTop, so add that in.
      var visibleTop = this.scrollTop + this.nodes.loadIndicator.offsetTop;

      // The bottom that we can see is marked by how far we have scrolled plus the height of the panel.
      // However, all offsetTop values of the child nodes will be skewed by the value of this.nodes.loadIndicator.offsetTop, so add that in.
      var visibleBottom = this.scrollTop + this.clientHeight + this.nodes.loadIndicator.offsetTop;
      var children = Array.prototype.slice.call(this.childNodes);
      children.forEach(function (child) {
        if (child.offsetTop >= visibleTop && child.offsetTop + child.clientHeight <= visibleBottom) {
          if (child.properties && child.properties.item && !child.properties.item.isRead) {
            // TODO: Use a scheduler rather than many setTimeout calls
            setTimeout(function () {
              return _this4._markAsRead(child);
            }, _base2.default.settings.markReadDelay);
          }
        }
      }, this);
    },


    /**
     * Mark a the Message associated with this item as read.
     *
     * This method validates that the Message flagged as ready to be read by `_checkVisibility()` is
     * in fact still fully visible after the delay.
     *
     * @method _markAsRead
     * @private
     * @param {layerUI.components.MessagesListPanel.Item} child
     */
    _markAsRead: function _markAsRead(child) {
      if (_base2.default.isInBackground() || this.disable) return;

      var visibleTop = this.scrollTop + this.nodes.loadIndicator.offsetTop;
      var visibleBottom = this.scrollTop + this.clientHeight + this.nodes.loadIndicator.offsetTop;
      if (child.offsetTop >= visibleTop && child.offsetTop + child.clientHeight <= visibleBottom) {
        child.properties.item.isRead = true;
      }
    },


    /**
     * Append a Message to the document fragment, updating the previous messages' lastInSeries property as needed.
     *
     * @method _generateItem
     * @private
     */
    _generateItem: function _generateItem(message) {
      var handler = _base2.default.getHandler(message, this);
      if (handler) {
        var messageWidget = document.createElement(message.sender.sessionOwner ? 'layer-message-item-sent' : 'layer-message-item-received');
        messageWidget.id = this._getItemId(message.id);
        messageWidget.dateRenderer = this.dateRenderer;
        messageWidget.messageStatusRenderer = this.messageStatusRenderer;
        messageWidget.getDeleteEnabled = this.getMessageDeleteEnabled;
        messageWidget._contentTag = handler.tagName;
        messageWidget.item = message;
        return messageWidget;
      } else {
        return null;
      }
    },


    /**
     * Are the two Messages in the same Group?
     *
     * See LayerUI.settings.messageGroupTimeSpan to adjust the definition of Same Group.
     *
     * @method _inSameGroup
     * @private
     * @param {layer.Message} m1
     * @param {layer.Message} m2
     */
    _inSameGroup: function _inSameGroup(m1, m2) {
      if (!m1 || !m2) return false;
      var diff = Math.abs(m1.sentAt.getTime() - m2.sentAt.getTime());
      return m1.sender === m2.sender && diff < _base2.default.settings.messageGroupTimeSpan;
    },


    /**
     * Whenever new message items are added to the list, we need to assign lastInSeries and firstInSeries values to them,
     * as well as update those values in nearby message items.
     *
     * @method _processAffectedWidgetsCustom
     * @private
     * @param {layerUI.components.MessagesListPanel.Item[]} widgets
     */
    _processAffectedWidgetsCustom: function _processAffectedWidgetsCustom(widgets, firstIndex, isTopItemNew) {
      if (widgets.length === 0) return;
      if (isTopItemNew) widgets[0].firstInSeries = true;
      for (var i = 1; i < widgets.length; i++) {
        var sameGroup = this._inSameGroup(widgets[i - 1].item, widgets[i].item);
        widgets[i].firstInSeries = !sameGroup;
        widgets[i - 1].lastInSeries = !sameGroup;
      }
      if (!widgets[widgets.length - 1].nextSibling) widgets[widgets.length - 1].lastInSeries = true;
    },


    _renderResetData: {
      mode: _component.registerComponent.MODES.AFTER,
      value: function _renderResetData(evt) {
        this.properties.stuckToBottom = true;
        this.properties.lastPagedAt = 0;
        this.properties.isSelfScrolling = false;
      }
    },

    _renderWithoutRemovedData: {
      mode: _component.registerComponent.MODES.OVERWRITE,
      value: function value(evt) {
        this.properties.listData = [].concat(this.properties.query.data).reverse();

        var messageWidget = this.querySelector('#' + this._getItemId(evt.target.id));
        if (messageWidget) this.removeChild(messageWidget);

        var removeIndex = this.properties.listData.length - evt.index; // Inverted for reverse order
        var affectedItems = this.properties.listData.slice(Math.max(0, removeIndex - 3), removeIndex + 3);
        this._gatherAndProcessAffectedItems(affectedItems, false);
      }
    },

    _renderInsertedData: {
      mode: _component.registerComponent.MODES.OVERWRITE,
      value: function value(evt) {
        var _this5 = this;

        if (this.properties.appendingMore) {
          if (!this.properties.insertEvents) this.properties.insertEvents = [];
          this.properties.insertEvents.push(evt);
          return;
        }
        var oldListData = this.properties.listData;
        this.properties.listData = [].concat(this.properties.query.data).reverse();

        var insertIndex = oldListData.length - evt.index; // Inverted for reverse order
        var isTopItemNew = insertIndex === 0;

        var affectedItems = this.properties.listData.slice(Math.max(0, insertIndex - 3), insertIndex + 4);
        var fragment = this._generateFragment([evt.target]);
        if (insertIndex < oldListData.length) {
          var insertBeforeNode = affectedItems.length > 1 ? this.querySelector('#' + this._getItemId(oldListData[insertIndex].id)) : null;
          this.insertBefore(fragment, insertBeforeNode);
        } else {
          this.appendChild(fragment);
        }
        this._gatherAndProcessAffectedItems(affectedItems, isTopItemNew);
        this._updateLastMessageSent();
        if (this.properties.stuckToBottom) {
          setTimeout(function () {
            return _this5.animateScrollTo(_this5.scrollHeight - _this5.clientHeight);
          }, 0);
        } else {
          this._checkVisibility();
        }
        if (!evt.inRender) this.onRerender();
      }
    },

    /**
     * The last message sent by the session owner should show some pending/read-by/etc... status.
     *
     * Other messages may also do this, but adding the `layer-last-message-sent` css class makes it easy
     * to conditionally show status only for the last sent message.
     *
     * TODO: Review if a CSS :last-child could isolate last message sent from last message received, and be used for easily styling this.
     *
     * @method _updateLastMessageSent
     * @private
     */
    _updateLastMessageSent: function _updateLastMessageSent() {
      for (var i = this.properties.listData.length - 1; i >= 0; i--) {
        if (this.properties.listData[i].sender.sessionOwner) {
          var item = this.querySelector('#' + this._getItemId(this.properties.listData[i].id));
          if (item && !item.classList.contains('layer-last-message-sent')) {
            this.querySelectorAllArray('.layer-last-message-sent').forEach(function (node) {
              node.classList.remove('layer-last-message-sent');
            });
            item.classList.add('layer-last-message-sent');
          }
          break;
        }
      }
    },


    /**
     * Identify the message-item that is fully visible and at the top of the viewport.
     *
     * We use this before paging in new data so that we know which message should still
     * be at the top after we insert new messages at the top, and must compensate our `scrollTop`
     * accordingly.
     *
     * @method _findFirstVisibleItem
     * @private
     */
    _findFirstVisibleItem: function _findFirstVisibleItem() {
      var visibleTop = this.scrollTop;
      var visibleBottom = this.scrollTop + this.clientHeight;
      var children = Array.prototype.slice.call(this.childNodes);
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.offsetTop >= visibleTop && child.offsetTop + child.clientHeight <= visibleBottom) {
          if (child.properties && child.properties.item) {
            return child;
          }
        }
      }
      return null;
    },


    /**
     * Render a new page of data received from the Query.
     *
     * @method _renderPagedData
     * @private
     */
    _renderPagedData: {
      mode: _component.registerComponent.MODES.OVERWRITE,
      value: function value(evt) {
        if (evt.data.length === 0) {
          this.isDataLoading = this.properties.query.isFiring;
          return;
        }

        // Set this so that if the user is clinging to the scrollbar forcing it to stay at the top,
        // we know we just paged and won't page again.
        this.properties.lastPagedAt = Date.now();

        // Get both the query data and the event data
        var oldListData = this.properties.listData;
        this.properties.listData = [].concat(this.properties.query.data).reverse();
        var newData = [].concat(evt.data).reverse();

        // Get the affected items
        var affectedItems = [].concat(newData);
        var fragment = void 0;
        if (oldListData.length) affectedItems = affectedItems.concat(oldListData.slice(0, 3));

        // Append only a few items at a time, with pauses to keep browser running smoothly.
        // Don't append anything to the document until its all generated
        // TODO: This sucks.  For 100 items, it takes 5 iterates of 20ms each, so it adds 100ms lag to render,
        // and the only good news is that this 100ms lag results in performance of the rest of the browser not degrading.
        var appendMore = function appendMore() {
          var _this6 = this;

          if (!this.query || this.query.isDestroyed) return;
          this.properties.appendingMore = true;
          var processItems = newData.splice(0, 20);
          fragment = this._generateFragment(processItems, fragment);
          if (newData.length) {
            setTimeout(function () {
              return appendMore.call(_this6);
            }, 20);
          } else {
            this.properties.appendingMore = false;
            _layerWebsdk2.default.Util.defer(function () {
              return _this6._renderPagedDataDone(affectedItems, fragment, evt);
            });
          }
        }.bind(this);
        appendMore();
      }
    },

    /**
     * After we have rendered the newly paged in messages, some post processing is needed.
     *
     * 1. Call processAffectedWidgets
     * 2. Scroll to maintain an appropriate position
     * 3. Insert the document fragment into our widget
     * 4. Check visibility on newly rendered items
     *
     * @method _renderPagedDataDone
     * @private
     */
    _renderPagedDataDone: function _renderPagedDataDone(affectedItems, fragment, evt) {
      var _this7 = this;

      // Find the nodes of all affected items in both the document and the fragment,
      // and call processAffectedWidgets on them
      if (affectedItems.length) {
        var affectedWidgetsQuery = '#' + affectedItems.map(function (message) {
          return _this7._getItemId(message.id);
        }).join(', #');
        var affectedWidgets = this.querySelectorAllArray(affectedWidgetsQuery);
        if (fragment) {
          var fragmentWidgets = Array.prototype.slice.call(fragment.querySelectorAll(affectedWidgetsQuery));
          affectedWidgets = fragmentWidgets.concat(affectedWidgets);
        }
        try {
          // When paging new data, top item should always be new
          this._processAffectedWidgets(affectedWidgets, true);
        } catch (e) {
          console.error(e);
        }
      }

      var firstVisibleItem = this._findFirstVisibleItem();
      var initialOffset = firstVisibleItem ? firstVisibleItem.offsetTop - this.nodes.loadIndicator.offsetTop - this.scrollTop : 0;

      // Now that DOM manipulation is completed,
      // we can add the document fragments to the page
      var nextItem = this.nodes.loadIndicator.nextSibling;
      this.insertBefore(fragment, nextItem);

      // TODO PERFORMANCE: We should not need to do this as we page UP; very wasteful
      this._updateLastMessageSent();

      if (this.properties.stuckToBottom) {
        this.scrollTo(this.scrollHeight - this.clientHeight);
      } else if (firstVisibleItem && evt.type === 'data' && evt.data.length !== 0) {
        this.scrollTo(firstVisibleItem.offsetTop - this.nodes.loadIndicator.offsetTop - initialOffset);
      }

      this.isDataLoading = this.properties.query.isFiring;
      this._checkVisibility();
      if (!evt.inRender) this.onRerender();

      if (this.properties.insertEvents) this.properties.insertEvents.forEach(function (anEvt) {
        return _this7._renderInsertedData(anEvt);
      });
      delete this.properties.insertEvents;
    }
  }
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-messages-list", "<div class='layer-empty-list' layer-id='emptyNode'></div><div class='layer-load-indicator' layer-id='loadIndicator'>Loading messages...</div>", "");
  layerUI.buildStyle("layer-messages-list", "layer-messages-list {\ndisplay: block;\nflex-grow: 1;\nheight: 100px; \npadding-bottom: 15px;\noverflow-y: scroll; \n-webkit-overflow-scrolling: touch;\n}\nlayer-messages-list .layer-load-indicator {\ntext-align: center;\nborder-bottom: solid 1px #ccc;\nfont-style: italic;\nopacity: 0;\n}\nlayer-messages-list.layer-loading-data .layer-load-indicator {\nopacity: 1;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../../../mixins/empty-list":53,"../../../mixins/has-query":55,"../../../mixins/list":59,"../layer-message-item-received/layer-message-item-received":26,"../layer-message-item-sent/layer-message-item-sent":27,"animated-scrollto":67,"layer-websdk":79}],29:[function(require,module,exports){
/**
 * The Layer Avatar widget renders an icon representing a user or users.
 *
 * This widget appears within
 *
 * * layerUI.components.MessagesListPanel.Item: Represents the sender of a Message
 * * layerUI.components.ConversationsListPanel.Item.Conversation: Represents the participants of a Conversation
 * * layerUI.components.IdentitiesListPanel.Item: Represents a user in a User List
 *
 * Rendering is done using data from the `layer.Identity` object for each user, using the layer.Identity.avatarUrl if available to
 * add an image, or first initials from layer.Identity.firstName, layer.Identity.lastName if no avatarUrl is available.
 * layer.Identity.displayName is used as a fallback.
 *
 * The simplest way to customize this widget is to replace it with your own implementation of the `<layer-avatar />` tag.
 *
 * ```javascript
 * layerUI.registerComponent('layer-avatar', {
 *    properties: {
 *      users: {
 *        set: function(value) {
 *           this.render();
 *        }
 *      }
 *    },
 *    methods: {
 *      render: function() {
 *        this.innerHTML = 'All Hail ' + this.properties.users[0].displayName;
 *      }
 *    }
 * });
 *
 * // Call init after custom components are defined
 * layerUI.init({
 *   appId:  'layer:///apps/staging/UUID'
 * });
 * ```
 *
 * Note that the main parameter is a `users` array, not a single user:
 *
 * * When used in a Messages List or Identities List, there will be only one user in the list
 * * When used in a Conversations List, there may be multiple users who are participants of the Conversation.
 *
 * @class layerUI.components.subcomponents.Avatar
 * @extends layerUI.components.Component
 */'use strict';

var _component = require('../../../components/component');

require('../layer-presence/layer-presence');


(0, _component.registerComponent)('layer-avatar', {
  properties: {

    /**
     * Array of users to be represented by this Avatar.
     *
     * Typically this only has one user represented with a layer.Identity.
     *
     * @property {layer.Identity[]} [users=[]}
     */
    users: {
      set: function set(newValue, oldValue) {
        if (oldValue && newValue && newValue.length === oldValue.length) {
          var matches = newValue.filter(function (identity) {
            return oldValue.indexOf(identity) !== -1;
          });
          if (matches !== newValue.length) return;
        }
        if (!newValue) newValue = [];
        if (!Array.isArray(newValue)) newValue = [newValue];
        // classList.toggle doesn't work right in IE 11
        this.classList[newValue.length ? 'add' : 'remove']('layer-has-user');
        this.onRender();
      }
    },

    showPresence: {
      value: true,
      type: Boolean
    }
  },
  methods: {
    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {
      this.properties.users = [];
    },


    /**
     * Render the users represented by this widget.
     *
     * @method
     * @private
     */
    onRender: function onRender() {
      // Clear the innerHTML if we have rendered something before
      if (this.users.length) {
        this.innerHTML = '';
      }

      // Render each user
      this.users.forEach(this._renderUser.bind(this));

      // Add the "cluster" css if rendering multiple users
      // No classList.toggle due to poor IE11 support
      this.classList[this.users.length > 1 ? 'add' : 'remove']('layer-avatar-cluster');
      if (this.users.length === 1 && this.showPresence && this.users[0].getClient().isPresenceEnabled) {
        this.nodes.presence = document.createElement('layer-presence');
        this.nodes.presence.item = this.users[0];
        this.appendChild(this.nodes.presence);
      }
    },


    /**
     * Render each individual user.
     *
     * @method
     * @private
     */
    _renderUser: function _renderUser(user) {
      if (user.avatarUrl) {
        var img = document.createElement('img');
        img.onerror = function () {
          img.style.display = 'none';
        };
        img.src = user.avatarUrl;
        this.appendChild(img);
      } else {
        var span = document.createElement('span');

        // Use first and last name if provided
        if (user.firstName && user.lastName) {
          span.innerHTML = user.firstName.substring(0, 1).toUpperCase() + user.lastName.substring(0, 1).toUpperCase();
        }

        // Use displayName to try and find a first and last name
        else if (user.displayName.indexOf(' ') !== -1) {
            span.innerHTML = user.displayName.substr(0, 1).toUpperCase() + user.displayName.substr(user.displayName.indexOf(' ') + 1, 1).toUpperCase();
          }

          // If all else fails, use the first two letters
          else {
              span.innerHTML = user.displayName.substring(0, 2).toUpperCase();
            }
        this.appendChild(span);
      }
    }
  }
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-avatar", "", "");
  layerUI.buildStyle("layer-avatar", "layer-avatar {\ndisplay: block;\n}\nlayer-avatar layer-presence {\nposition: absolute;\nbottom: 0px;\nright: 0px;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../layer-presence/layer-presence":38}],30:[function(require,module,exports){
/**
     * Provides a Button Panel for adding custom actions to the layerUI.Composer panel.
     *
     * You can populate this button panel using the layerUI.components.ConversationPanel.composeButtons property.
     *
     * Alternatively, you can replace this by defining a custom `layer-compose-button-panel` to make the resulting component entirely yours:
     *
     * ```
     * document.registerElement('layer-compose-button-panel', {
     *   prototype: Object.create(HTMLElement.prototype, {
     *     createdCallback: {
     *       value: function() {
     *         this.innerHTML = "<button>Click me!</button>";
     *       }
     *     }
     *   })
     * });
     *
     * // Call init after custom components are defined
     * layerUI.init({
     *   appId:  'layer:///apps/staging/UUID'
     * });
     * ```
     *
     * @class layerUI.components.subcomponents.ComposeButtonPanel
     * @extends layerUI.components.Component
     */'use strict';

var _component = require('../../../components/component');

(0, _component.registerComponent)('layer-compose-button-panel', {
  properties: {
    /**
     * Custom buttons to put in the panel.
     *
     * @property {HTMLElement[]} [buttons=[]]
     */
    buttons: {
      value: [],
      set: function set(value) {
        this.classList[value && value.length ? 'remove' : 'add']('is-empty');
        this.onRender();
      }
    }
  },
  methods: {
    /**
     * Render any custom buttons provided via the `buttons` property.
     *
     * @method
     * @private
     */
    onRender: function onRender() {
      this.innerHTML = '';
      if (this.buttons.length) {
        var fragment = document.createDocumentFragment();
        this.buttons.forEach(function (button) {
          return fragment.appendChild(button);
        });
        this.appendChild(fragment);
      }
    }
  }
}); 


(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-compose-button-panel", "", "");
  layerUI.buildStyle("layer-compose-button-panel", "layer-compose-button-panel.is-empty {\ndisplay: none;\n}\nlayer-compose-button-panel {\ndisplay: flex;\nflex-direction: row;\nalign-items: stretch;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15}],31:[function(require,module,exports){
/**
 * The Layer Composer widget provides the textarea for layerUI.components.ConversationPanel.
 *
 * It provides a self-resizing text area that resizes to the size of the entered text, and sends typing indicators as the user types.
 *
 * Special behaviors to know about:
 *
 * * CSS Class `layer-composer-one-line-of-text`: If there is only a single line's worth of text, then this CSS class is applied to
 *   help center the text
 * * Event `layer-file-selected`: This widget listens for this event, and if it receives it, uses that event to retrieve a file to send in
 *   the Conversation.  Event comes from layerUI.components.subcomponents.FileUploadButton or from your custom widgets.
 * * Keyboard Handling: ENTER: Sends message unless its accompanied by a modifier key.  TAB: Enters a \t character unless you
 *   set `layerUI.settings.disableTabAsWhiteSpace` to true
 *
 * @class layerUI.components.subcomponents.Composer
 * @extends layerUI.components.Component
 */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _base = require('../../../base');

var _base2 = _interopRequireDefault(_base);

var _component = require('../../../components/component');

require('../layer-compose-button-panel/layer-compose-button-panel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var ENTER = 13;
var TAB = 9;

(0, _component.registerComponent)('layer-composer', {
  properties: {

    /**
     * Specify which Conversation we are sending messages and typing indicators to.
     *
     * @property {layer.Conversation} [conversation=null]
     */
    conversation: {
      set: function set(value) {
        if (value) this.client = value.getClient();
        this._setTypingListenerConversation();
      }
    },

    /**
     * The Client are we using to communicate.
     *
     * @property {layer.Client} [client=null]
     */
    client: {
      set: function set(value) {
        if (!this.nodes.input) console.error('NO INPUT FOR COMPOSER');
        if (value) {
          this.properties.typingListener = this.properties.client.createTypingListener(this.nodes.input);
          this._setTypingListenerConversation();
        }
      }
    },

    /**
     * Custom buttons to put in the panel, on the right side.
     *
     * @property {HTMLElement[]} [buttons=[]]
     */
    buttons: {
      set: function set(value) {
        this.nodes.buttonPanel.buttons = value;
      }
    },

    /**
     * Custom buttons to put in the panel, on the left side.
     *
     * @property {HTMLElement[]} [buttonsLeft=[]]
     */
    buttonsLeft: {
      set: function set(value) {
        this.nodes.buttonPanelLeft.buttons = value;
      }
    },

    /**
     * The text shown in the editor; this is the editor's value.
     *
     * @property {String} [value='']
     */
    value: {
      set: function set(value) {
        var oldValue = this.nodes.input.value;
        this.nodes.input.value = value;
        this.onRender();
        this._triggerChange(value, oldValue);
      },
      get: function get() {
        return this.nodes.input.value;
      }
    },
    /**
     * The text shown in the editor; this is the editor's placeholder.
     *
     * @property {String} [placeholder='']
     */
    placeholder: {
      set: function set(value) {
        this.nodes.input.placeholder = value;
        this.onRender();
      },
      get: function get() {
        return this.nodes.input.placeholder;
      }
    }
  },
  methods: {
    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {
      this.classList.add('layer-composer-one-line-of-text');
      this.properties.buttons = [];

      // Setting this in the template causes errors in IE 11.
      this.nodes.input.placeholder = 'Enter a message';
      this.nodes.input.addEventListener('keydown', this._onKeyDown.bind(this));
      this.nodes.input.addEventListener('input', this._onInput.bind(this));

      // Event handlers
      this.addEventListener('layer-file-selected', this._handleAttachments.bind(this));
      this.addEventListener('layer-send-click', this.send.bind(this, null));
    },


    /**
     * Whenever the value changes, trigger a `layer-composer-change-value` event.
     *
     * @method
     * @private
     * @param {String} value      The current value
     * @param {String} oldValue   The prior value
     */
    _triggerChange: function _triggerChange(value, oldValue) {
      if (value === oldValue) return;
      this.properties.value = value;

      /**
       * This event is triggered whenever the composer value changes.
       *
       * This is not a cancelable event.
       *
       * ```javascript
       * document.body.addEventListener('layer-composer-change-value', function(evt) {
       *   this.setState({composerValue: evt.detail.value});
       * }
       * ```
       *
       * @event layer-composer-change-value
       * @param {Event} evt
       * @param {Object} evt.detail
       * @param {String} evt.detail.value
       * @param {String} evt.detail.oldValue
       */
      this.trigger('layer-composer-change-value', { value: value, oldValue: oldValue });
    },


    /**
     * Focus on the textarea so keyboard actions enter text into it.
     *
     * @method
     */
    focus: function focus() {
      this.nodes.input.focus();
    },


    /**
     * Update the Typing Listener's `conversation` property so that it reports typing activity
     * to the correct Conversation.
     *
     * @method
     * @private
     */
    _setTypingListenerConversation: function _setTypingListenerConversation() {
      this.properties.typingListener.setConversation(this.conversation);
    },


    /**
     * Send the Message that the user has typed in.
     *
     * This is called automatically when the user hits `ENTER`.
     *
     * This can also be called directly:
     *
     * ```
     * widget.send(); // send the current text in the textarea
     * ```
     *
     * ```
     * widget.send(parts); // send custom message parts but NOT the text in the textarea
     * ```
     *
     * @method
     * @param {layer.MessagePart[]} optionalParts
     */
    send: function send(optionalParts) {

      var parts = [];
      if (optionalParts) {
        parts = optionalParts;
      } else if (this.nodes.input.value) {
        parts.push(new _layerWebsdk2.default.MessagePart({
          type: 'text/plain',
          body: this.nodes.input.value
        }));
        this.nodes.input.value = '';
      }

      if (parts.length === 0) return;

      var message = this.conversation ? this.conversation.createMessage({ parts: parts }) : null;

      /**
       * This event is triggered before any Message is sent; used to control notifications and override sending.
       *
       * You can use this event to control the notifications by modifying the `evt.detail.notification` object.
       * Note that you should modify the object but not try to replace the object.
       *
       * ```javascript
       * document.body.addEventListener('layer-send-message', function(evt) {
       *   var message = evt.detail.item;
       *   var notification = evt.detail.notification;
       *   notification.title = 'You have a new Message from ' + message.sender.displayName;
       *   notification.sound = 'sneeze.aiff';
       *   if (message.parts[0].mimeType === 'text/plain') {
       *     notification.text = evt.detail.item.parts[0].body;
       *   } else {
       *     notification.text = 'You have received a file';
       *   }
       * }
       * ```
       *
       * You can also use this event to provide your own logic for sending the Message.
       *
       * ```javascript
       * document.body.addEventListener('layer-send-message', function(evt) {
       *   var message = evt.detail.item;
       *   evt.preventDefault();
       *   myAsyncLookup(function(result) {
       *     var part = new layer.MessagePart({
       *       mimeType: 'application/json',
       *       body: result
       *     });
       *     message.addPart(part);
       *     message.send();
       *   });
       * });
       * ```
       *
       * @event layer-send-message
       * @param {Event} evt
       * @param {Object} evt.detail
       * @param {layer.MessagePart[]} evt.detail.parts   The array of message parts that will be sent
       * @param {layer.Message} evt.detail.item          The message that was created from the parts; null if no Conversation property is set
       * @param {layer.Conversation} evt.detail.conversation  The conversation that the message was created on; may be null if no conversation has been set.
       * @param {Object} evt.detail.notification
       * @param {String} evt.detail.notification.text
       * @param {String} evt.detail.notification.title
       * @param {String} evt.detail.notification.sound
       */
      var textPart = parts.filter(function (part) {
        return part.mimeType === 'text/plain';
      })[0];
      var notification = {
        text: textPart ? textPart.body : 'File received',
        title: 'New Message from ' + this.client.user.displayName
      };

      if (this.trigger('layer-send-message', {
        parts: parts,
        notification: notification,
        item: message,
        conversation: this.conversation
      })) {
        if (!this.conversation) {
          console.error('Unable to send message without a conversationId');
        } else if (this.conversation instanceof _layerWebsdk2.default.Channel) {
          this.onSend(message);
          message.send();
        } else {
          this.onSend(message, notification);
          message.send(notification);
        }
      }
    },


    /**
     * MIXIN HOOK: Called just before sending a message.
     *
     * @method
     * @param {layer.Message} message
     * @param {Object} notification   See layer.Message.send for details on the notification object
     */
    onSend: function onSend(message, notification) {
      // No-op
    },


    /**
     * On ENTER call `send()`; on TAB enter some spacing rather than leaving the text area.
     *
     * @method
     * @private
     */
    _onKeyDown: function _onKeyDown(event) {
      if (event.keyCode === ENTER) {
        if (!event.shiftKey && !event.ctrlKey && !event.metaKey) {
          event.preventDefault();
          this.send();
        } else {
          event.target.value += '\n';
        }
        this._onInput(event);
      } else if (!_base2.default.settings.disableTabAsWhiteSpace && event.keyCode === TAB && !event.shiftKey) {
        event.preventDefault();
        event.target.value += '\t  ';
        this._onInput(event);
      }
    },
    _onInput: function _onInput(event) {
      this.onRender();
      this._triggerChange(this.nodes.input.value, this.properties.value);
    },


    /**
     * On any change in value, recalculate our height and lineHeight to fit the input text.
     *
     * @method
     * @private
     */
    onRender: function onRender() {
      var _this = this;

      setTimeout(function () {
        _this.nodes.resizer.innerHTML = _this.nodes.input.value.replace(/\n/g, '<br/>') || '&nbsp;';
        _this.nodes.lineHeighter.innerHTML = _this.nodes.input.value.replace(/\n/g, '<br/>') || '&nbsp;';
        var willBeOneLine = !_this.nodes.input.value.match(/\n/) && _this.nodes.resizer.clientHeight - _this.nodes.lineHeighter.clientHeight < 10;

        // Prevent scrollbar flickering in and then out
        if (willBeOneLine) {
          _this.nodes.input.style.overflow = 'hidden';
          setTimeout(function () {
            _this.nodes.input.style.overflow = '';
          }, 1);
        }

        // Note that classList.toggle doesn't work right in IE11
        _this.classList[willBeOneLine ? 'add' : 'remove']('layer-composer-one-line-of-text');
      }, 10);
    },


    /**
     * If a file event was detected, send some attachments.
     *
     * @method
     * @private
     */
    _handleAttachments: function _handleAttachments(evt) {
      this.send(evt.detail.parts);
    }
  }
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-composer", "<layer-compose-button-panel layer-id='buttonPanelLeft' class='layer-button-panel-left'></layer-compose-button-panel><div class='layer-compose-edit-panel' layer-id='editPanel'><div class='hidden-resizer' layer-id='resizer'>&nbsp;&nbsp;</div><div class='hidden-lineheighter' layer-id='lineHeighter'>&nbsp;</div><textarea rows=\"1\" autoFocus layer-id='input'></textarea></div><layer-compose-button-panel layer-id='buttonPanel' class='layer-button-panel-right'></layer-compose-button-panel>", "");
  layerUI.buildStyle("layer-composer", "layer-composer {\ndisplay: flex;\nflex-direction: row;\n}\nlayer-composer .layer-compose-edit-panel {\nposition: relative;\nflex-grow: 1;\nwidth: 100px; \npadding: 1px 0px;\n}\nlayer-composer textarea, layer-composer .hidden-resizer, layer-composer .hidden-lineheighter {\nline-height: 1.2em;\nmin-height: 20px;\noverflow :hidden;\nborder-width: 0px;\nfont-size: 1em;\npadding: 4px 8px;\nbox-sizing: border-box;\nfont-family: \"Open Sans\", \"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", sans-serif;\nmargin: 0px;\n}\nlayer-composer textarea {\nresize: none;\noutline: none;\ncolor: rgba(0,0,0,0.87);\nposition: absolute;\nz-index: 2;\ntop: 0px;\nleft: 0px;\nwidth: 100%;\nheight: 100%;\noverflow-y: auto;\nwhite-space: pre-wrap;\nword-wrap: break-word;\n}\nlayer-composer.layer-composer-one-line-of-text textarea {\noverflow-y: hidden;\n}\nlayer-composer .hidden-resizer {\nopacity: 0.1;\nwhite-space: pre-wrap;\nword-wrap: break-word;\nmax-height: 250px;\n}\nlayer-composer .layer-compose-edit-panel .hidden-lineheighter {\ntop: 0px;\nopacity: 0.1;\nwhite-space: nowrap;\nposition: absolute;\nright: 10000px;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../layer-compose-button-panel/layer-compose-button-panel":30,"layer-websdk":79}],32:[function(require,module,exports){
/**
 * The Layer widget renders a Last Message for a layer.Conversation.
 *
 * This is provided as a specialized component so that it can be easily redefined by your app to
 * provide your own Conversation Last Message rendering:
 *
 * ```
 * layerUI.registerComponent('layer-conversation-last-message', {
 *   properties: {
 *      item: {}
 *   },
 *   methods: {
 *     created: function() {
 *       this.innerHTML = this.item.lastMessage.parts[0].body;
 *     }
 *   }
 * });
 *
 * // Call init after custom components are defined
 * layerUI.init({
 *   appId:  'layer:///apps/staging/UUID'
 * });
 * ```
 *
 * @class layerUI.components.subcomponents.ConversationLastMessage
 * @extends layerUI.components.Component
 */'use strict';

var _base = require('../../../base');

var _base2 = _interopRequireDefault(_base);

var _component = require('../../../components/component');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerComponent)('layer-conversation-last-message', {
  properties: {

    /**
     * The layer.Message to be rendered
     *
     * @property {layer.Message} [item=null]
     */
    item: {
      set: function set(newValue, oldValue) {
        if (oldValue) oldValue.off(null, null, this);
        if (newValue) newValue.on('conversations:change', this.onRerender, this);
        this.onRender();
      }
    },

    /**
     * Provide a function to determine if the last message is rendered in the Conversation List.
     *
     * By default, only text/plain last-messages are rendered in the Conversation List.  A Message that is NOT rendered
     * is instead rendered using the MessageHandler's label: `(ICON) Image Message`
     *
     * ```javascript
     * listItem.canFullyRenderLastMessage = function(message) {
     *     return true; // Render all Last Messages
     * }
     * ```
     *
     * @property {Function} [canFullyRenderLastMessage=null]
     */
    canFullyRenderLastMessage: {}
  },
  methods: {

    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {},
    onRender: function onRender() {
      this.onRerender();
    },


    /**
     * Rerender this widget whenever the layer.Conversation has a change event reporting on a
     * new `lastMessage` property.
     *
     * Lookup a handler for the Message, and if one is found, see if `canFullyRenderLastMessage` allows it to be rendered.
     * If its allowed, append the Renderer as a child of this node; else set innerHTML to match the Handler's label.
     *
     * @method
     * @private
     * @param {Event} evt
     */
    onRerender: function onRerender(evt) {
      if (!evt || evt.hasProperty('lastMessage')) {
        var conversation = this.item;
        var message = conversation ? conversation.lastMessage : null;
        this.innerHTML = '';
        if (message && message.id == "layer:///messages/66320b84-ad65-4c73-8dc8-4df4566e2137") debugger;
        if (message) {
          var handler = _base2.default.getHandler(message, this);
          if (handler) {
            this.classList.add(handler.tagName);
            // Create the element specified by the handler and add it as a childNode.
            if (!this.canFullyRenderLastMessage || this.canFullyRenderLastMessage(message)) {
              var messageHandler = document.createElement(handler.tagName);
              messageHandler.parentComponent = this;
              messageHandler.message = message;
              this.appendChild(messageHandler);
            } else if (handler.label) {
              this.innerHTML = '<div class="layer-custom-mime-type">' + handler.label + '</div>';
            }
          }
        }
      }
    }
  }
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-conversation-last-message", "", "");
  layerUI.buildStyle("layer-conversation-last-message", "layer-conversation-last-message, .layer-custom-mime-type {\ndisplay: block;\nwhite-space: nowrap;\ntext-overflow: ellipsis;\noverflow: hidden;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15}],33:[function(require,module,exports){
/**
     * The Layer widget renders a title for a layer.Conversation.
     *
     * This is provided as a specialized component so that it can be easily redefined by your app to
     * provide your own Conversation titles:
     *
     * ```
     * layerUI.registerComponent('layer-conversation-title', {
     *    properties: {
     *      item: {
     *        set: function(value) {
     *           this.innerHTML = this.item.metadata.myCustomTitle;
     *        }
     *      }
     *    }
     * });
     *
     * // Call init after custom components are defined
     * layerUI.init({
     *   appId:  'layer:///apps/staging/UUID'
     * });
     * ```
     *
     * @class layerUI.components.subcomponents.ConversationTitle
     * @extends layerUI.components.Component
     */'use strict';

var _component = require('../../../components/component');

(0, _component.registerComponent)('layer-conversation-title', {
  properties: {

    /**
     * The layer.Conversation to be rendered.
     *
     * @property {layer.Conversation} [item=null]
     */
    item: {
      set: function set(newConversation, oldConversation) {
        if (oldConversation) oldConversation.off(null, null, this);
        if (newConversation) newConversation.on('conversations:change', this.onRerender, this);
        this.onRender();
      }
    }
  },
  methods: {

    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {},
    onRender: function onRender() {
      this.onRerender();
    },


    /**
     * Rerender the widget any time a new conversation is assigned or that conversation has a relevant change event.
     *
     * @method
     * @private
     * @param {Event} evt
     */
    onRerender: function onRerender(evt) {
      if (!evt || evt.hasProperty('metadata') || evt.hasProperty('participants')) {
        var conversation = this.item;

        // If no conversation, empty the widget
        if (!conversation) {
          this.innerHTML = '';
        } else {
          var title = conversation.metadata.conversationName || conversation.metadata.title;
          if (!title) {
            var userNames = conversation.participants.filter(function (user) {
              return !user.sessionOwner;
            }) // don't show the user their own name
            .filter(function (user) {
              return user.displayName;
            }) // don't show users who lack a name
            .map(function (user) {
              return user.displayName;
            }); // replace identity object with the name

            if (userNames.length) {
              title = userNames.join(', ').replace(/, ([^,]*)$/, ' and $1');
            } else {
              title = 'No Title';
            }
          }
          if (title !== this.innerHTML) this.innerHTML = title;
        }
      }
    }
  }
}); 


(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-conversation-title", "", "");
  layerUI.buildStyle("layer-conversation-title", "layer-conversation-title {\ndisplay: block;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15}],34:[function(require,module,exports){
/**
     * The Layer Date widget renders a date.
     *
     * This is provided as a specialized component so that it can be easily redefined by your app to
     * provide your own date formatting.  Note that most customization of date rendering can be accomplished instead
     * using layerUI.components.ConversationPanel.dateRenderer.
     *
     * ```
     * layerUI.registerComponent('layer-date', {
     *    properties: {
     *      date: {
     *        set: function(value) {
     *           // Render a random date value that is related to but not exactly the provided value
     *           var newDate = new Date(value);
     *           newDate.setHours(newDate.getHours() + Math.random() * 10);
     *           this.innerHTML = newDate.toISOString();
     *        }
     *      }
     *    }
     * });
     *
     * // Call init after custom components are defined
     * layerUI.init({
     *   appId:  'layer:///apps/staging/UUID'
     * });
     * ```
     *
     * @class layerUI.components.subcomponents.Date
     * @extends layerUI.components.Component
     */'use strict';

var _component = require('../../../components/component');

(0, _component.registerComponent)('layer-date', {
  properties: {

    /**
     * Date to be rendered
     *
     * @property {Date} [date=null]
     */
    date: {
      set: function set(value) {
        if (value) {
          if (this.dateRenderer) {
            this.value = this.dateRenderer(value);
          } else {
            var dateStr = value.toLocaleDateString();
            var timeStr = value.toLocaleTimeString();
            this.value = new Date().toLocaleDateString() === dateStr ? timeStr : dateStr + ' ' + timeStr;
          }
        } else {
          this.value = '';
        }
      }
    },

    /**
     * The actual rendered string.
     *
     * @property {String} [value='']
     */
    value: {
      set: function set(value) {
        this.innerHTML = value;
      }
    },

    /**
     * Provide property to override the function used to render a date for each Message Item.
     *
     * Note that changing this will not regenerate the list; this should be set when initializing a new List.
     *
     * ```javascript
     * dateItem.dateRenderer = function(date) {
     *    return date.toISOString();
     * };
     * ```
     *
     * @property {Function} [dateRender=null]
     */
    dateRenderer: {}
  }
}); 


(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-date", "", "");
  layerUI.buildStyle("layer-date", "layer-date {\ndisplay: block;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15}],35:[function(require,module,exports){
/**
 * The Layer Delete widget renders a deletion button.
 *
 * This is provided as a specialized component so that it can be easily redefined by your app to
 * provide your own deletion capability.
 *
 * Note that the `item` property can refer to any type of data that can be deleted, including layer.Message and layer.Conversation.
 *
 * ```
 * layerUI.registerComponent('layer-delete', {
 *    properties: {
 *      item: {}
 *    },
 *    methods: {
 *      onCreate: function() {
 *        this.addEventListener('click', this.onDeleteClick, this);
 *      },
 *      onDeleteClick: function() {
 *         alert('I'm sorry Dave, I can't do that');
 *      }
 *    }
 * });
 *
 * // Call init after custom components are defined
 * layerUI.init({
 *   appId:  'layer:///apps/staging/UUID'
 * });
 * ```
 *
 * @class layerUI.components.subcomponents.Delete
 * @extends layerUI.components.Component
 */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _component = require('../../../components/component');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerComponent)('layer-delete', {
  properties: {

    /**
     * Item to be deleted.
     *
     * @property {layer.Root} [item=null]
     */
    item: {},

    /**
     * Is deletion enabled for this item?
     *
     * @property {Boolean} [enabled=false]
     */
    enabled: {
      type: Boolean,
      set: function set(value) {
        // Note that IE11 doesn't propetly support classList.toggle()
        this.classList[value ? 'add' : 'remove']('layer-delete-enabled');
      }
    }
  },
  methods: {

    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {
      this.addEventListener('click', this.onDeleteClick, this);
    },


    /**
     * MIXIN HOOK: Called when the delete button is clicked..
     *
     * Triggers `layer-message-deleted` or `layer-conversation-deleted` allowing deletion to be handled elsewhere.
     *
     * @method
     * @param {Event} evt
     */
    onDeleteClick: function onDeleteClick(evt) {
      evt.preventDefault();
      evt.stopPropagation();
      if (this.enabled) {
        if (this.item instanceof _layerWebsdk2.default.Message) {
          /**
           * A request has been made through the UI to delete a Message.
           *
           * This event can be canceled to prevent the default deletion behavior:
           *
           * ```javascript
           * document.body.addEventListener('layer-message-deleted', function(evt) {
           *    evt.preventDefault();
           *    var message = evt.item;
           *    message.delete(layer.Constants.DELETION_MODE.MY_DEVICES);
           * });
           * ```
           *
           * @event layer-message-deleted
           */
          if (this.trigger('layer-message-deleted', { item: this.item })) {
            if (window.confirm('Are you sure you want to delete this message?')) {
              this.item.delete(_layerWebsdk2.default.Constants.DELETION_MODE.ALL);
            }
          }
        }

        /**
         * A request has been made through the UI to delete a Conversation.
         *
         * This event can be canceled to prevent the default deletion behavior:
         *
         * ```javascript
         * document.body.addEventListener('layer-conversation-deleted', function(evt) {
         *    evt.preventDefault();
         *    var conversation = evt.item;
         *    conversation.delete(layer.Constants.DELETION_MODE.MY_DEVICES);
         * });
         * ```
         *
         * @event layer-conversation-deleted
         */
        else if (this.trigger('layer-conversation-deleted', { item: this.item })) {
            if (window.confirm('Are you sure you want to delete this conversation?')) {
              this.item.delete(_layerWebsdk2.default.Constants.DELETION_MODE.ALL);
            }
          }
      }
    }
  }
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-delete", "&#x2715;", "");
  layerUI.buildStyle("layer-delete", "layer-delete {\ndisplay: none;\n}\nlayer-delete.layer-delete-enabled {\ndisplay: inline;\nwidth: 12px;\nheight: 12px;\nfont-size: 12px;\npadding: 4px 4px 6px 4px;\nmargin-right: 5px;\nborder: solid 1px transparent;\ncursor: default;\ntext-align: center;\ncursor: pointer;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"layer-websdk":79}],36:[function(require,module,exports){
/**
 * The Layer file upload button widget allows users to select a File to send.
 *
 * Its assumed that this button will be used within the layerUI.components.subcomponents.ComposeButtonPanel:
 *
 * ```
 * myConversationPanel.composeButtons = [
 *    document.createElement('layer-file-upload-button')
 * ];
 * ```
 *
 * If using it elsewhere, note that it triggers a `layer-file-selected` event that you would listen for to do your own processing.
 * If using it in the ComposeButtonPanel, this event will be received by the Composer and will not propagate any further:
 *
 * ```
 * document.body.addEventListener('layer-file-selected', function(evt) {
 *    var messageParts = evt.custom.parts;
 *    conversation.createMessage({ parts: messageParts }).send();
 * }
 * ```
 *
 * @class layerUI.components.subcomponents.FileUploadButton
 * @extends layerUI.components.Component
 */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _base = require('../../../base');

var _base2 = _interopRequireDefault(_base);

var _mainComponent = require('../../../mixins/main-component');

var _mainComponent2 = _interopRequireDefault(_mainComponent);

var _component = require('../../../components/component');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerComponent)('layer-file-upload-button', {
  mixins: [_mainComponent2.default],
  properties: {},
  methods: {

    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {
      var _this = this;

      this.nodes.input.id = _layerWebsdk2.default.Util.generateUUID();
      this.nodes.label.setAttribute('for', this.nodes.input.id);
      this.nodes.input.addEventListener('change', this.onChange.bind(this));

      // This causes test to fail by causing the click event to fire twice.
      // but without this, the click event is not received at all.
      this.addEventListener('click', function (evt) {
        if (evt.target !== _this.nodes.input) _this.nodes.input.click();
      });
    },


    /**
     * MIXIN HOOK: When the file input's value has changed, gather the data and trigger an event.
     *
     * If adding a mixin here to change behaviors on selecting a file, you can use `this.nodes.input.files` to access
     * the selected files.
     *
     * @method
     */
    onChange: function onChange() {
      var _this2 = this;

      var files = this.nodes.input.files;

      /* istanbul ignore next */
      var inputParts = Array.prototype.map.call(files, function (file) {
        return new _layerWebsdk2.default.MessagePart(file);
      });

      /**
       * This widget triggers a `layer-file-selected` event when the user selects files.
       * This event is captured and stopped from propagating by the layerUI.components.subcomponents.Composer.
       * If using it outside of the composer, this event can be used to receive the MessageParts generated
       * for the selected files.
       *
       * @event layer-file-selected
       * @param {Object} evt
       * @param {Object} evt.detail
       * @[aram {layer.MessagePart[]} evt.detail.parts
       */
      _base2.default.files.processAttachments(inputParts, function (parts) {
        _this2.trigger('layer-file-selected', { parts: parts });
      });
    }
  }
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-file-upload-button", "<label layer-id='label'>+</label><input layer-id='input' type='file'></input>", "");
  layerUI.buildStyle("layer-file-upload-button", "layer-file-upload-button {\ncursor: pointer;\ndisplay: flex;\nflex-direction: column;\njustify-content: center;\n}\nlayer-file-upload-button input {\nwidth: 0.1px;\nheight: 0.1px;\nopacity: 0;\noverflow: hidden;\nposition: absolute;\nz-index: -1;\n}\nlayer-file-upload-button label {\ndisplay: block;\npointer-events: none;\ntext-align: center;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../../../mixins/main-component":60,"layer-websdk":79}],37:[function(require,module,exports){
/**
 * The Layer Message Status widget renders a Message's sent/delivered/read status.
 *
 * This is provided as a specialized component so that it can be easily redefined by your app to
 * provide your own date formatting.  Note that most customization of message status rendering can be accomplished instead
 * using layerUI.components.ConversationPanel.messageStatusRenderer.
 *
 * ```
 * layerUI.registerComponent('layer-message-status', {
 *    properties: {
 *      message: {
 *        set: function(value) {
 *          if (newMessage) newMessage.on('messages:change', this.onRerender, this);
 *          this.onRerender();
 *        }
 *      }
 *    },
 *    methods: {
 *      onRerender: function() {
 *          var message = this.properties.message;
 *          this.innerHTML = 'Nobody wants to read your message';
 *      }
 *    }
 * });
 *
 * // Call init after custom components are defined
 * layerUI.init({
 *   appId:  'layer:///apps/staging/UUID'
 * });
 * ```
 *
 * @class layerUI.components.subcomponents.MessageStatus
 * @extends layerUI.components.Component
 */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _component = require('../../../components/component');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerComponent)('layer-message-status', {
  properties: {

    /**
     * Message whose status is to be rendered
     *
     * @property {layer.Message} [message=null]
     */
    item: {
      set: function set(newMessage, oldMessage) {
        if (oldMessage) oldMessage.off(null, null, this);
        if (newMessage) newMessage.on('messages:change', this.onRerender, this);
        this.onRender();
      }
    },

    /**
     * Provide property to override the function used to render a message status for each Message Item.
     *
     * Note that changing this will not trigger a rerender; this should be set during initialization.
     *
     * ```javascript
     * statusItem.messageStatusRenderer = function(message) {
     *    return message.readStatus === layer.Constants.RECIPIENT_STATE.ALL ? 'read' : 'processing...';
     * };
     * ```
     *
     * @property {Function} [messageStatusRenderer=null]
     */
    messageStatusRenderer: {}
  },
  methods: {

    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {},
    onRender: function onRender() {
      this.onRerender();
    },


    /**
     * There are many ways to render the status of a Message.
     *
     * See layerUI.components.ConversationPanel.messageStatusRenderer to customize this.
     *
     * @method
     * @private
     * @param {Event} evt
     */
    onRerender: function onRerender(evt) {
      if (this.item && (!evt || evt.hasProperty('recipientStatus') || evt.hasProperty('syncState'))) {
        var message = this.item;
        if (this.messageStatusRenderer) {
          this.innerHTML = this.messageStatusRenderer(message);
        } else {
          var text = '';
          if (message.isNew()) {
            text = '';
          } else if (message.isSaving() || message.isNew()) {
            text = 'pending';
          } else if (message instanceof _layerWebsdk2.default.Message.ChannelMessage || message.deliveryStatus === _layerWebsdk2.default.Constants.RECIPIENT_STATE.NONE) {
            text = 'sent';
          } else if (message.readStatus === _layerWebsdk2.default.Constants.RECIPIENT_STATE.NONE) {
            text = 'delivered';
          } else if (message.readStatus === _layerWebsdk2.default.Constants.RECIPIENT_STATE.ALL) {
            text = 'read';
          } else {
            var sessionOwnerId = message.getClient().user.id;
            var status = message.recipientStatus;
            var count = Object.keys(status).filter(function (identityId) {
              return identityId !== sessionOwnerId && status[identityId] === _layerWebsdk2.default.Constants.RECEIPT_STATE.READ;
            }).length;
            text = 'read by ' + count + ' participants';
          }
          this.innerHTML = text;
        }
      }
    }
  }
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-message-status", "", "");
  layerUI.buildStyle("layer-message-status", "layer-message-status {\ndisplay: inline;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"layer-websdk":79}],38:[function(require,module,exports){
/**
     * The Layer Presence widget renders an icon representing a user's status of Available, Away, Busy or Offline.
     *
     * The simplest way to customize this widget is to replace it with your own implementation of the `<layer-avatar />` tag.
     *
     * ```javascript
     * layerUI.registerComponent('layer-presence', {
     *    properties: {
     *      user: {
     *        set: function(value) {
     *           this.onRender();
     *           if (value) value.on('identity:changes', this.onRerender, this);
     *        }
     *      }
     *    },
     *    methods: {
     *      onRender: function() {
     *        this.onRerender();
     *      },
     *      onRerender: function() {
     *        this.className = 'my-presence-' + this.user.status;
     *      },
     *    }
     * });
     *
     * // Call init after custom components are defined
     * layerUI.init({
     *   appId:  'layer:///apps/staging/UUID'
     * });
     * ```
     *
     * @class layerUI.components.subcomponents.Presence
     * @extends layerUI.components.Component
     * @mixin layerUI.mixins.MainComponent
     */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _component = require('../../../components/component');

var _mainComponent = require('../../../mixins/main-component');

var _mainComponent2 = _interopRequireDefault(_mainComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _component.registerComponent)('layer-presence', {
  mixins: [_mainComponent2.default],
  events: ['layer-presence-click'],
  properties: {

    /**
     * User whose status is represented here
     *
     * Typically this only has one user represented with a layer.Identity.
     *
     * @property {layer.Identity}
     */
    item: {
      set: function set(value) {
        if (value && !(value instanceof _layerWebsdk2.default.Identity)) {
          var client = _layerWebsdk2.default.Client.getClient(value.clientId);
          if (client) {
            value = this.properties.item = client.getIdentity(value.id);
          } else {
            value = this.properties.item = null;
          }
        }
        if (value) value.on('identities:change', this.onRerender, this);
        this.onRender();
      }
    }
  },
  methods: {
    onCreate: function onCreate() {
      this.addEventListener('click', this.onClick.bind(this));
    },


    /**
     * Render new user.
     *
     * @method
     */
    onRender: function onRender() {
      this.onRerender();
    },


    /**
     * Render's changes in user status
     *
     * @method
     */
    onRerender: function onRerender(user) {
      this.className = 'layer-presence-' + (this.item ? this.item.status : 'unknown');
    },


    /**
     * The user clicked on this widget.
     *
     * Typically, you wouldn't respond to these, but if the user clicked on their OWN presence,
     * you may prompt them to change their status
     *
     * @method
     * @param {Event} evt
     */
    onClick: function onClick(evt) {
      evt.preventDefault();
      this.trigger('layer-presence-click', { item: this.item });
    }
  }
}); 


(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-presence", "", "");
  layerUI.buildStyle("layer-presence", "layer-presence {\ndisplay: inline-block;\nborder-radius: 30px;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../../../mixins/main-component":60,"layer-websdk":79}],39:[function(require,module,exports){
/**
 * The Layer file upload button widget allows users to select a File to send.
 *
 * Its assumed that this button will be used within the layerUI.components.subcomponents.ComposeButtonPanel.
 * If using it elsewhere, note that it triggers a `layer-send-click` event that you would listen for to do your own processing.
 * If using it in the ComposeButtonPanel, this event will be received and handled by the Composer and will not propagate any further.
 *
 * ```
 * document.body.addEventListener('layer-send-click', function(evt) {
 *    var messageParts = evt.custom.parts;
 *    conversation.createMessage({ parts: messageParts }).send();
 * }
 * ```
 *
 * A send button is added to a project as follows:
 *
 * ```
 * myConversationPanel.composeButtons = [
 *    document.createElement('layer-send-button')
 * ];
 * ```
 *
 * @class layerUI.components.subcomponents.SendButton
 * @extends layerUI.components.Component
 */'use strict';

var _component = require('../../../components/component');

var _mainComponent = require('../../../mixins/main-component');

var _mainComponent2 = _interopRequireDefault(_mainComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerComponent)('layer-send-button', {
  mixins: [_mainComponent2.default],
  properties: {
    text: {
      value: 'SEND',
      set: function set(value) {
        this.firstChild.innerHTML = value;
      }
    }
  },
  methods: {
    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {
      this.addEventListener('click', this.onClick.bind(this));
    },


    /**
     * MIXIN HOOK: Called whenever the button is clicked.
     *
     * @method
     * @param {Event} evt
     */
    onClick: function onClick(evt) {
      this.trigger('layer-send-click');
    }
  }
});

(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-send-button", "<div></div>", "");
  layerUI.buildStyle("layer-send-button", "layer-send-button {\ncursor: pointer;\ndisplay: flex;\nflex-direction: row;\nalign-items: center;\n}\nlayer-send-button div {\ntext-align: center;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../../../mixins/main-component":60}],40:[function(require,module,exports){
/**
     * The Layer Typing Indicator widget renders a short description of who is currently typing into the current Conversation.
     *
     * This is designed to go inside of the layerUI.Conversation widget.
     *
     * The simplest way to customize the behavior of this widget is using the `layer-typing-indicator-change` event.
     *
     * TODO: Provide a layerUI.components.ConversationPanel.typingIndicatorRenderer property
     *
     * @class layerUI.components.subcomponents.TypingIndicator
     * @extends layerUI.components.Component
     */'use strict';

var _component = require('../../../components/component');

(0, _component.registerComponent)('layer-typing-indicator', {
  properties: {
    /**
     * The Conversation whose typing indicator activity we are reporting on.
     *
     * @property {layer.Conversation} [conversation=null]
     */
    conversation: {
      set: function set(value) {
        if (value) {
          this.client = value.getClient();
          var state = this.client.getTypingState(value);
          this.onRerender({
            conversationId: value.id,
            typing: state.typing,
            paused: state.paused
          });
        } else {
          this.value = '';
        }
      }
    },

    /**
     * The Client we are connected with; we need it to receive typing indicator events from the WebSDK.
     *
     * This property is typically set indirectly by setting the layerUI.TypingIndicator.conversation.
     *
     * @property {layer.Client} [client=null]
     */
    client: {
      set: function set(newClient, oldClient) {
        if (oldClient) oldClient.off(null, null, this);
        if (newClient) newClient.on('typing-indicator-change', this.onRerender, this);
      }
    },

    /**
     * The value property is the text/html being rendered.
     *
     * @property {String} [value=""]
     */
    value: {
      set: function set(text) {
        this.nodes.panel.innerHTML = text || '';
        // classList.toggle doesn't work right in IE11
        this.classList[text ? 'add' : 'remove']('layer-typing-occuring');
      }
    }
  },
  methods: {

    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {},
    onRender: function onRender() {
      if (this.conversation && this.conversation.id) {
        var data = this.client.getTypingState(this.conversation.id);
        data.conversationId = this.conversation.id;
        this.onRerender(data);
      }
    },


    /**
     * Whenever there is a typing indicator event, rerender our UI
     *
     * @method onRerender
     * @param {layer.LayerEvent} evt
     */
    onRerender: function onRerender(evt) {
      // We receive typing indicator events for ALL Conversations; ignore them if they don't apply to the current Conversation
      if (evt.conversationId === this.conversation.id) {

        // Trigger an event so that the application can decide if it wants to handle the event itself.
        var customEvtResult = this.trigger('layer-typing-indicator-change', {
          typing: evt.typing,
          paused: evt.paused,
          widget: this
        });

        // If the app lets us handle the event, set the value of this widget to something appropriate
        if (customEvtResult) {
          var names = evt.typing.map(function (user) {
            return user.displayName;
          });
          switch (names.length) {
            case 0:
              this.value = '';
              break;
            case 1:
              this.value = names.join(', ') + ' is typing';
              break;
            default:
              this.value = names.join(', ').replace(/, ([^,]*)$/, ' and $1') + ' are typing';
          }
        }
      }
    }
  }
}); 

/**
 * Custom handler to use for rendering typing indicators.
 *
 * By calling `evt.preventDefault()` on the event you can provide your own custom typing indicator text to this widget:
 *
 * ```javascript
 * document.body.addEventListener('layer-typing-indicator-change', function(evt) {
 *    evt.preventDefault();
 *    var widget = evt.target;
 *    var typingUsers = evt.detail.typing;
 *    var pausedUsers = evt.detail.paused;
 *    var text = '';
 *    if (typingUsers.length) text = typingUsers.length + ' users are typing';
 *    if (pausedUsers.length && typingUsers.length) text += ' and ';
 *    if (pausedUsers.length) text += pausedUsers.length + ' users have paused typing';
 *    widget.value = text;
 * });
 * ```
 *
 * Note that as long as you have called `evt.preventDefault()` you can also just directly manipulate child domNodes of `evt.detail.widget`
 * if a plain textual message doesn't suffice.
 *
 * @event layer-typing-indicator-change
 * @param {Event} evt
 * @param {Object} evt.detail
 * @param {layer.Identity[]} evt.detail.typing
 * @param {layer.Identity[]} evt.detail.paused
 */


(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-typing-indicator", "<span class='layer-typing-message' layer-id='panel'></span>", "");
  layerUI.buildStyle("layer-typing-indicator", "layer-typing-indicator {\ndisplay: block;\n}\nlayer-typing-indicator span {\ndisplay: none;\n}\nlayer-typing-indicator.layer-typing-occuring span {\ndisplay: inline;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15}],41:[function(require,module,exports){
/**
 * The Layer Image MessageHandler renders a single MessagePart image, or an Atlas 3-message-part Image.
 *
 * One of the challenges in rendering images is that browser `<img />` tags do not follow EXIF data
 * for orientation, which results in sideways and upside down photos.  Furthermore, CSS rotation of the dom,
 * results in offsets and margins that vary based on the exact dimensions of the image, resulting
 * in some very ugly code to get anything remotely consistent.  This Component uses `blueimp-load-image`
 * to write the image to a Canvas, parse its EXIF data and orient it appropriately.
 *
 * As with all Message Handling, Message Height should be fixed at rendering time, and should not change asynchrnously
 * except in response to a user action.  Otherwise scroll positions get mucked and users get lost.
 * As a result, image heights should be fixed before any asynchronously loaded image has loaded.
 *
 * @class layerUI.handlers.message.Image
 * @extends layerUI.components.Component
 */'use strict';

var _loadImage = require('blueimp-load-image/js/load-image');

var _loadImage2 = _interopRequireDefault(_loadImage);

require('blueimp-load-image/js/load-image-orientation');

require('blueimp-load-image/js/load-image-meta');

require('blueimp-load-image/js/load-image-exif');

var _base = require('../../../base');

var _component = require('../../../components/component');

var _sizing = require('../../../utils/sizing');

var _sizing2 = _interopRequireDefault(_sizing);

var _messageHandler = require('../../../mixins/message-handler');

var _messageHandler2 = _interopRequireDefault(_messageHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerMessageComponent)('layer-message-image', {
  mixins: [_messageHandler2.default],
  properties: {
    label: {
      // TODO: Remove font awsome css classes!
      value: '<i class="fa fa-file-image-o layer-image-message-icon" aria-hidden="true"></i> Image message'
    },

    /**
     * The Message property provides the MessageParts we are going to render.
     *
     * @property {layer.Message} [message=null]
     */
    message: {
      set: function set(value) {

        // Extract our image, preview and metadata message parts
        this.properties.image = value.parts.filter(function (part) {
          return ['image/png', 'image/gif', 'image/jpeg'].indexOf(part.mimeType) !== -1;
        })[0];
        this.properties.preview = value.parts.filter(function (part) {
          return part.mimeType === 'image/jpeg+preview';
        })[0];
        var meta = value.parts.filter(function (part) {
          return part.mimeType === 'application/json+imageSize';
        })[0];
        if (meta) this.properties.meta = JSON.parse(meta.body);

        // If there is a preview and it doesn't have a body, fetch the preview body so we can pass it into the ImageManager.
        if (this.properties.preview && this.properties.image) {
          if (!this.properties.preview.body) {
            this.properties.preview.fetchContent();
            this.properties.preview.on('content-loaded', this.onRender, this);
          }
          // TODO: remove body test once all websdk changes are merged and url is gaurenteed to have a value if body has a value
          // If image does not have a url, call fetchStream to get an updated url
          if (!this.properties.image.url && !this.properties.image.body) this.properties.image.fetchStream();
        }

        // If there is no preview, only an image, we're going to pass it into the ImageManager so fetch its body
        else if (!this.properties.image.body) {
            this.properties.image.fetchContent();
            this.properties.image.on('content-loaded', this.onRender, this);
          }
      }
    }
  },
  methods: {
    handlesMessage: function handlesMessage(message) {
      // Get the Image Parts
      var imageParts = message.parts.filter(function (part) {
        return ['image/png', 'image/gif', 'image/jpeg'].indexOf(part.mimeType) !== -1;
      }).length;

      // Get the Preview Parts
      var previewParts = message.parts.filter(function (part) {
        return part.mimeType === 'image/jpeg+preview';
      }).length;

      // Get the Metadata Parts
      var metaParts = message.parts.filter(function (part) {
        return part.mimeType === 'application/json+imageSize';
      }).length;

      // We handle 1 part images or 3 part images.
      return message.parts.length === 1 && imageParts || message.parts.length === 3 && imageParts === 1 && previewParts === 1 && metaParts === 1;
    },


    /**
     * Constructor.
     *
     * @method onCreate
     * @private
     */
    onCreate: function onCreate() {
      this.addEventListener('click', this._handleClick.bind(this));
    },


    /**
     * If the user clicks the image, and we have a full image part with a url, open it.
     *
     * @method
     * @private
     * @param {Event} evt
     */
    _handleClick: function _handleClick(evt) {
      // Don't open images clicked within the Conversations List
      /* istanbul ignore next */
      if (this.parentNode.tagName !== 'LAYER-CONVERSATION-LAST-MESSAGE') {
        evt.preventDefault();
        if (this.properties.image && this.properties.image.url) window.open(this.properties.image.url);
      }
    },


    /**
     * Render the Message.
     *
     * Primarily, this method determines whether to call _renderCanvas on the preview or the image.
     *
     * @method
     * @private
     */
    onRender: function onRender() {
      var maxSizes = _base.settings.maxSizes;
      // TODO: Need to be able to customize this height, as well as the conditions (parentContainers) under which different sizes are applied.
      if (this.parentComponent && this.parentComponent.tagName === 'LAYER-NOTIFIER') maxSizes = { height: 140, width: maxSizes.width };
      this.properties.sizes = (0, _sizing2.default)(this.properties.meta, { width: maxSizes.width, height: maxSizes.height });
      this.style.height = _base.settings.verticalMessagePadding + this.properties.sizes.height + 'px';
      if (this.properties.preview && this.properties.preview.body) {
        this._renderCanvas(this.properties.preview.body);
      } else if (this.properties.image && this.properties.image.body) {
        this._renderCanvas(this.properties.image.body);
      }
    },


    /**
     * Parse the EXIF data, determine the orientation and then generate a Canvas with a correctly oriented Image.
     *
     * Canvas is added as a child node.
     *
     * @method
     * @private
     * @param {Blob} blob
     */
    _renderCanvas: function _renderCanvas(blob) {
      var _this = this;

      // Read the EXIF data
      _loadImage2.default.parseMetaData(blob, function (data) {
        var options = {
          canvas: true
        };

        if (data.imageHead && data.exif) {
          options.orientation = data.exif[0x0112] || 1;
        }
        options.maxWidth = options.minWidth = _this.properties.sizes.width;
        options.maxHeight = options.minHeight = _this.properties.sizes.height;

        // Write the image to a canvas with the specified orientation
        (0, _loadImage2.default)(blob, function (canvas) {
          while (_this.firstChild) {
            _this.removeChild(_this.firstChild);
          }if (canvas instanceof HTMLElement) {
            _this.appendChild(canvas);
          } else {
            console.error(canvas);
          }
        }, options);
      });
    }
  }
});

/*
 * Handle any Message that contains an IMage + Preview + Metadata or is just an Image
 */
// layerUI.registerMessageHandler({
//   tagName: 'layer-message-image',
//   label: '<i class="fa fa-file-image-o" aria-hidden="true"></i> Image message',
//   handlesMessage(message, container) {
//     // Get the Image Parts
//     const imageParts = message.parts.filter(part =>
//       ['image/png', 'image/gif', 'image/jpeg'].indexOf(part.mimeType) !== -1).length;

//     // Get the Preview Parts
//     const previewParts = message.parts.filter(part =>
//       part.mimeType === 'image/jpeg+preview').length;

//     // Get the Metadata Parts
//     const metaParts = message.parts.filter(part =>
//       part.mimeType === 'application/json+imageSize').length;

//     // We handle 1 part images or 3 part images.
//     return (message.parts.length === 1 && imageParts ||
//       message.parts.length === 3 && imageParts === 1 && previewParts === 1 && metaParts === 1);
//   },
// });


(function () {
  var layerUI = require('../../../base');
  layerUI.buildAndRegisterTemplate("layer-message-image", "", "");
  layerUI.buildStyle("layer-message-image", "layer-message-image {\ndisplay: flex;\nflex-direction: column;\nalign-items: center;\n}\nlayer-message-image canvas {\nwidth: 100%;\n}", "");
})();
},{"../../../base":14,"../../../components/component":15,"../../../mixins/message-handler":61,"../../../utils/sizing":66,"blueimp-load-image/js/load-image":73,"blueimp-load-image/js/load-image-exif":69,"blueimp-load-image/js/load-image-meta":70,"blueimp-load-image/js/load-image-orientation":71}],42:[function(require,module,exports){
/**
 * The Layer Plain Text MessageHandler renders a single text/plain message part.
 *
 * See layerUI.registerTextHandler for details on adding new text processing capabilities.
 *
 * @class layerUI.handlers.message.TextPlain
 * @extends layerUI.components.Component
 */'use strict';

var _component = require('../../components/component');

var _messageHandler = require('../../mixins/message-handler');

var _messageHandler2 = _interopRequireDefault(_messageHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerMessageComponent)('layer-message-text-plain', {
  mixins: [_messageHandler2.default],
  properties: {
    label: {
      label: 'Text'
    }
  },
  methods: {
    /**
     * This component can render any message that starts with text/plain message part
     *
     * @method
     */
    handlesMessage: function handlesMessage(message, container) {
      return message.parts[0].mimeType === 'text/plain';
    },


    /**
     * Replaces any html tags with escaped html tags so that the recipient
     * sees tags rather than rendered html.
     *
     * @method
     * @private
     */
    _fixHtml: function _fixHtml(body) {
      body = body.replace(/</g, '&lt;');
      body = body.replace(/>/g, '&gt;');
      return body;
    },


    /**
     * Format the text and render it.
     *
     * Iterates over all Text Handlers allowing each to modify the `text` property, as well as to append values to `afterText`
     *
     * Renders the results after all TextHandlers have run.
     *
     * @method
     */
    onRender: function onRender() {
      var _this = this;

      if (!layerUI.textHandlersOrdered) this._setupOrderedHandlers();

      var text = this.message.parts[0].body;
      var textData = {
        text: this._fixHtml(text),
        afterText: []
      };
      var afterText = '';

      layerUI.textHandlersOrdered.forEach(function (handler) {
        return handler(textData, _this.message);
      });

      if (textData.afterText.length) {
        var startDiv = '<div class="layer-message-text-plain-after-text">';
        afterText = startDiv + textData.afterText.join('</div>' + startDiv) + '</div>';
        this.classList.add('layer-message-text-plain-has-after-text');
      }
      this.innerHTML = textData.text + afterText;
    },


    /**
     * Order the Text handlers if they haven't previously been sorted.
     *
     * This is run as a method, but is treated more like a run-once static method.
     *
     * @method
     * @private
     */
    _setupOrderedHandlers: function _setupOrderedHandlers() {
      layerUI.textHandlersOrdered = Object.keys(layerUI.textHandlers).filter(function (handlerName) {
        return layerUI.textHandlers[handlerName].enabled;
      }).map(function (handlerName) {
        return layerUI.textHandlers[handlerName];
      }).sort(function (a, b) {
        if (a.order > b.order) return 1;
        if (b.order > a.order) return -1;
        return 0;
      }).map(function (handlerObj) {
        return handlerObj.handler;
      });
    }
  }
});
},{"../../components/component":15,"../../mixins/message-handler":61}],43:[function(require,module,exports){
/**
 * The Unknown MessageHandler renders unhandled content with a placeholder politely
 * suggesting that a developer should probably handle it.
 *
 * @class layerUI.handlers.message.Unknown
 * @extends layerUI.components.Component
 */'use strict';

var _component = require('../../components/component');

var _messageHandler = require('../../mixins/message-handler');

var _messageHandler2 = _interopRequireDefault(_messageHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerComponent)('layer-message-unknown', {
  mixins: [_messageHandler2.default],
  methods: {
    /**
     * Render a message that is both polite and mildly annoying.
     *
     * @method
     * @private
     */
    onRender: function onRender() {
      var mimeTypes = this.message.parts.map(function (part) {
        return part.mimeType;
      }).join(', ');
      this.innerHTML = 'Message with mimeTypes ' + mimeTypes + ' has been received but has no renderer';
    }
  }
});

// Do not register this handler
},{"../../components/component":15,"../../mixins/message-handler":61}],44:[function(require,module,exports){
/**
 * The Layer Video MessageHandler renders a single MessagePart Video, or an Atlas 3-message-part Video.
 *
 * As with all Message Handling, Message Height should be fixed at rendering time, and should not change asynchrnously
 * except in response to a user action.  Otherwise scroll positions get mucked and users get lost.
 * As a result, video heights should be fixed before any asynchronously loaded video or preview has loaded.
 *
 * @class layerUI.handlers.message.Video
 * @extends layerUI.components.Component
 */'use strict';

var _component = require('../../components/component');

var _sizing = require('../../utils/sizing');

var _sizing2 = _interopRequireDefault(_sizing);

var _base = require('../../base');

var _messageHandler = require('../../mixins/message-handler');

var _messageHandler2 = _interopRequireDefault(_messageHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerMessageComponent)('layer-message-video', {
  mixins: [_messageHandler2.default],
  template: '<video layer-id="video"></video>',
  properties: {
    label: {
      value: '<i class="fa fa-file-video-o layer-video-message-icon" aria-hidden="true"></i> Video message'
    },

    /**
     * The Message property provides the MessageParts we are going to render.
     *
     * @property {layer.Message} [message=null]
     */
    message: {
      set: function set(value) {

        // Extract our video, preview and metadata message parts
        this.properties.video = value.parts.filter(function (part) {
          return part.mimeType === 'video/mp4';
        })[0];
        this.properties.preview = value.parts.filter(function (part) {
          return part.mimeType === 'image/jpeg+preview';
        })[0];
        var meta = value.parts.filter(function (part) {
          return part.mimeType === 'application/json+imageSize';
        })[0];
        if (meta) this.properties.meta = JSON.parse(meta.body);

        this.properties.sizes = (0, _sizing2.default)(this.properties.meta, {
          width: _base.settings.maxSizes.width,
          height: _base.settings.maxSizes.height
        });

        if (!this.properties.video.url) this.properties.video.fetchStream();
        this.properties.video.on('url-loaded', this.onRender, this);

        if (this.properties.preview) {
          if (!this.properties.preview.url) this.properties.preview.fetchStream();
          this.properties.preview.on('url-loaded', this.onRender, this);
        }
      }
    }
  },
  methods: {
    handlesMessage: function handlesMessage(message, container) {
      var videoParts = message.parts.filter(function (part) {
        return part.mimeType === 'video/mp4';
      }).length;
      var previewParts = message.parts.filter(function (part) {
        return part.mimeType === 'image/jpeg+preview';
      }).length;
      var metaParts = message.parts.filter(function (part) {
        return part.mimeType === 'application/json+imageSize';
      }).length;
      return message.parts.length === 1 && videoParts || message.parts.length === 3 && videoParts === 1 && previewParts === 1 && metaParts === 1;
    },


    /**
     * Render the Message.
     *
     * Primarily, this method determines whether to call renderCanvas on the preview or the image.
     *
     * @method
     * @private
     */
    onRender: function onRender() {
      this.nodes.video.width = this.properties.sizes.width;
      this.nodes.video.height = this.properties.sizes.height;
      this.nodes.video.src = this.properties.video.url;
      if (this.properties.preview) {
        this.nodes.video.poster = this.properties.preview.url;
      }
      this.nodes.video.controls = true;
    }
  }
});
},{"../../base":14,"../../components/component":15,"../../mixins/message-handler":61,"../../utils/sizing":66}],45:[function(require,module,exports){
/**
 * The Layer Image TextHandler replaces all image URLs with image tags
 *
 * @class layerUI.handlers.text.Autolinker
 */'use strict';

var _autolinker = require('autolinker');

var _autolinker2 = _interopRequireDefault(_autolinker);

var _base = require('../../base');

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var autolinker = new _autolinker2.default({
  truncate: {
    length: 40,
    location: 'middle'
  },
  className: 'layer-parsed-url'
});

_base2.default.registerTextHandler({
  name: 'autolinker',
  order: 400,
  requiresEnable: true,
  handler: function handler(textData) {
    textData.text = autolinker.link(textData.text);
  }
});
},{"../../base":14,"autolinker":68}],46:[function(require,module,exports){
/**
     * The Layer Code Block TextHandler replaces all \`\`\` with code blocks, and all \` with inline code blocks.
     *
     * @class layerUI.handlers.text.CodeBlocks
     */'use strict';

var _base = require('../../base');

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_base2.default.registerTextHandler({
  name: 'code-blocks',
  order: 500,
  requiresEnable: true,
  handler: function handler(textData) {
    var text = textData.text.replace(/```[\s\S]*?```/g, function (block) {
      return '<pre class="code_block">' + block.substring(3, block.length - 3) + '</pre>';
    });

    // note .* means single line; [\s\S]* means multiline
    text = text.replace(/`.*?`/g, function (block) {
      return '<code>' + block.substring(1, block.length - 1) + '</code>';
    });
    textData.text = text;
  }
}); 
},{"../../base":14}],47:[function(require,module,exports){
/**
     * The Layer Emoji TextHandler replaces all :smile: and :-) with emoji images
     *
     * @class layerUI.handlers.text.Emoji
     */'use strict';

var _twemoji = require('twemoji');

var _twemoji2 = _interopRequireDefault(_twemoji);

var _setEmoji = require('remarkable-emoji/setEmoji');

var _setEmoji2 = _interopRequireDefault(_setEmoji);

var _base = require('../../base');

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_base2.default.registerTextHandler({
  base: location.protocol + '://twemoji.maxcdn.com/',
  name: 'emoji',
  order: 300,
  requiresEnable: true,
  handler: function handler(textData) {
    // Bug in RemarkableParser requires extra spacing around html tags to keep them away from the emoticon.
    var text = textData.text.replace(/<br\/>/g, ' <br/> ');

    // Parse it
    var parsed = (0, _setEmoji2.default)(text);

    // See if its an all-emoji line by replacing all emojis with empty strings
    // and seeing if there's anything left when we're done.
    var allEmojiLine = !_twemoji2.default.replace(parsed, function () {
      return '';
    }).match(/\S/);

    // Render the emoji images
    text = _twemoji2.default.parse((0, _setEmoji2.default)(text), {
      size: allEmojiLine ? '36x36' : '16x16',
      className: allEmojiLine ? 'emoji emoji-line' : 'emoji'
    });

    // Undo the extra spacing we added above
    text = text.replace(/ <br\/> /g, '<br/>');
    textData.text = text;
  }
}); 
},{"../../base":14,"remarkable-emoji/setEmoji":76,"twemoji":77}],48:[function(require,module,exports){
/**
 * The Layer Image TextHandler replaces all image URLs with image tags
 *
 * @class layerUI.handlers.text.Images
 */'use strict';

var _base = require('../../base');

var _base2 = _interopRequireDefault(_base);

var _isUrl = require('../../utils/is-url');

var _isUrl2 = _interopRequireDefault(_isUrl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


_base2.default.registerTextHandler({
  name: 'images',
  order: 100,
  requiresEnable: true,
  handler: function handler(textData) {
    var matches = textData.text.match((0, _isUrl2.default)(['png', 'jpg', 'jpeg', 'gif']));
    if (matches) {
      matches.forEach(function (match) {
        return textData.afterText.push('<img class="layer-parsed-image" src="' + match + '"></img>');
      });
    }
  }
});
},{"../../base":14,"../../utils/is-url":65}],49:[function(require,module,exports){
/**
     * The Layer Newline TextHandler replaces all newline characters with <br/> tags.
     *
     * Any newline character that appears within a code block should
     * NOT be replaced with a <br/> tag as the code block will render that as a visible
     * <br/> rather than go to the next line.
     *
     * @class layerUI.handlers.text.NewLine
     */'use strict';

var _base = require('../../base');

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_base2.default.registerTextHandler({
  name: 'newline',
  order: 600,
  requiresEnable: true,
  handler: function handler(textData) {
    var body = textData.text;
    var codeBlockIndices = [];
    var codeBlocks = [];
    var lastIndex = 0;
    while (lastIndex !== -1) {
      lastIndex = body.indexOf('```', lastIndex);
      if (lastIndex !== -1) {
        codeBlockIndices.push(lastIndex);
        lastIndex += 3;
      }
    }

    for (var i = 1; i < codeBlockIndices.length; i++) {
      codeBlocks.push([codeBlockIndices[i - 1], codeBlockIndices[i]]);
    }

    function isInCodeBlock(index) {
      return Boolean(codeBlocks.filter(function (block) {
        return index > block[0] && index < block[1];
      }).length);
    }

    body = body.replace(/\n/g, function (text, index) {
      if (isInCodeBlock(index)) {
        return text;
      } else {
        return '<br/>';
      }
    });
    textData.text = body;
  }
}); 
},{"../../base":14}],50:[function(require,module,exports){
/**
     * The Layer Youtube URL TextHandler replaces all youtube-like URLs with a video player.
     *
     * @class layerUI.handlers.text.Youtube
     */'use strict';

var _base = require('../../base');

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_base2.default.registerTextHandler({
  name: 'youtube',
  order: 200,
  requiresEnable: true,
  handler: function handler(textData) {
    var matches = textData.text.match(/https:\/\/(www\.)?(youtu\.be|youtube\.com)\/(watch\?.*?v=)?([a-zA-Z0-9-]+)/g);
    if (matches) {
      matches.forEach(function (match) {
        var videoId = void 0;
        var shortUrlMatches = match.match(/https:\/\/youtu\.be\/(.*)$/);
        if (shortUrlMatches) videoId = shortUrlMatches[1];
        if (!videoId) {
          var urlMatches = match.match(/https:\/\/www\.youtube\.com\/watch\?v=(.*)$/);
          if (urlMatches) videoId = urlMatches[1];
        }
        if (videoId) {
          textData.afterText.push('<iframe width="560" height="315" src="https://www.youtube.com/embed/' + videoId + '" frameborder="0" allowfullscreen></iframe>');
        }
      });
    }
  }
}); 
},{"../../base":14}],51:[function(require,module,exports){
(function (global){
'use strict';

/*
 * This file is used to create a browserified build with the following properties:
 *
 * * Initializes webcomponent-light polyfil
 * * Hooks up all methods/properties in the layerUI namespace
 * * Initializes and registers all widgets of this library
 *
 * Note that you may create your own build that includes:
 *
 * * webcomponent polyfil
 * * Hooks up all methods/properties in the layerUI namespace
 * * Pick and choose modules from the lib folder to include
 *
 * NOTE: JSDuck is picking up on LayerUI and defining it to be a class
 * which we don't want; do not let JSDuck parse this file.
 */'use strict';

/*
 * This file is used to create a browserified build with the following properties:
 *
 * * Initializes webcomponent-light polyfil
 * * Hooks up all methods/properties in the layerUI namespace
 * * Initializes and registers all widgets of this library
 *
 * Note that you may create your own build that includes:
 *
 * * webcomponent polyfil
 * * Hooks up all methods/properties in the layerUI namespace
 * * Pick and choose modules from the lib folder to include
 *
 * NOTE: JSDuck is picking up on LayerUI and defining it to be a class
 * which we don't want; do not let JSDuck parse this file.
 */

var LayerUI = require('./layer-ui');

// Load Adapters
require('./adapters/angular');
require('./adapters/backbone');
require('./adapters/react');

// Load Main Components
require('./components/conversation-list-panel/layer-conversations-list/layer-conversations-list');
require('./components/identities-list-panel/layer-identities-list/layer-identities-list');
require('./components/membership-list-panel/layer-membership-list/layer-membership-list');
require('./components/layer-conversation-panel/layer-conversation-panel');
require('./components/layer-notifier/layer-notifier');

// Load standard utilities
require('./components/subcomponents/layer-file-upload-button/layer-file-upload-button');
require('./components/subcomponents/layer-send-button/layer-send-button');
require('./handlers/message/layer-message-text-plain');
require('./handlers/message/layer-message-image/layer-message-image');
require('./handlers/message/layer-message-video');
require('./handlers/text/autolinker');
require('./handlers/text/code-blocks');
require('./handlers/text/emoji');
require('./handlers/text/images');
require('./handlers/text/newline');
require('./handlers/text/youtube');
require('./utils/date-separator');

LayerUI.files = require('./utils/files');
LayerUI.mixins = {
  MessageHandler: require('./mixins/message-handler'),
  HasQuery: require('./mixins/has-query'),
  MainComponent: require('./mixins/main-component'),
  List: require('./mixins/list'),
  ListItem: require('./mixins/list-item'),
  ListSelection: require('./mixins/list-selection'),
  ListItemSelection: require('./mixins/list-item-selection'),
  FocusOnKeydown: require('./mixins/focus-on-keydown')
};

// If we don't expose global.layerUI then custom templates can not load and call window.layerUI.registerTemplate()
module.exports = global.layerUI = LayerUI;

var LayerUI = require('./layer-ui');

// Load Adapters
require('./adapters/angular');
require('./adapters/backbone');
require('./adapters/react');

// Load Main Components
require('./components/conversation-list-panel/layer-conversations-list/layer-conversations-list');
require('./components/identities-list-panel/layer-identities-list/layer-identities-list');
require('./components/membership-list-panel/layer-membership-list/layer-membership-list');
require('./components/layer-conversation-panel/layer-conversation-panel');
require('./components/layer-notifier/layer-notifier');

// Load standard utilities
require('./components/subcomponents/layer-file-upload-button/layer-file-upload-button');
require('./components/subcomponents/layer-send-button/layer-send-button');
require('./handlers/message/layer-message-text-plain');
require('./handlers/message/layer-message-image/layer-message-image');
require('./handlers/message/layer-message-video');
require('./handlers/text/autolinker');
require('./handlers/text/code-blocks');
require('./handlers/text/emoji');
require('./handlers/text/images');
require('./handlers/text/newline');
require('./handlers/text/youtube');
require('./utils/date-separator');

LayerUI.files = require('./utils/files');
LayerUI.mixins = {
  MessageHandler: require('./mixins/message-handler'),
  HasQuery: require('./mixins/has-query'),
  MainComponent: require('./mixins/main-component'),
  List: require('./mixins/list'),
  ListItem: require('./mixins/list-item'),
  ListSelection: require('./mixins/list-selection'),
  ListItemSelection: require('./mixins/list-item-selection'),
  FocusOnKeydown: require('./mixins/focus-on-keydown')
};

// If we don't expose global.layerUI then custom templates can not load and call window.layerUI.registerTemplate()
module.exports = global.layerUI = LayerUI;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./adapters/angular":11,"./adapters/backbone":12,"./adapters/react":13,"./components/conversation-list-panel/layer-conversations-list/layer-conversations-list":18,"./components/identities-list-panel/layer-identities-list/layer-identities-list":19,"./components/layer-conversation-panel/layer-conversation-panel":21,"./components/layer-notifier/layer-notifier":22,"./components/membership-list-panel/layer-membership-list/layer-membership-list":24,"./components/subcomponents/layer-file-upload-button/layer-file-upload-button":36,"./components/subcomponents/layer-send-button/layer-send-button":39,"./handlers/message/layer-message-image/layer-message-image":41,"./handlers/message/layer-message-text-plain":42,"./handlers/message/layer-message-video":44,"./handlers/text/autolinker":45,"./handlers/text/code-blocks":46,"./handlers/text/emoji":47,"./handlers/text/images":48,"./handlers/text/newline":49,"./handlers/text/youtube":50,"./layer-ui":52,"./mixins/focus-on-keydown":54,"./mixins/has-query":55,"./mixins/list":59,"./mixins/list-item":57,"./mixins/list-item-selection":56,"./mixins/list-selection":58,"./mixins/main-component":60,"./mixins/message-handler":61,"./utils/date-separator":63,"./utils/files":64}],52:[function(require,module,exports){
'use strict';

require('webcomponents.js/webcomponents-lite');

var _base = require('./base');

var _base2 = _interopRequireDefault(_base);

var _component = require('./components/component');

require('./handlers/message/layer-message-unknown');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Import this if you want just a basic setup without any built-in widgets.
 *
 * Import index.js instead of you want a standard setup with standard widgets installed.
 */'use strict';

require('webcomponents.js/webcomponents-lite');

var _base = require('./base');

var _base2 = _interopRequireDefault(_base);

var _component = require('./components/component');

require('./handlers/message/layer-message-unknown');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Import this if you want just a basic setup without any built-in widgets.
 *
 * Import index.js instead of you want a standard setup with standard widgets installed.
 */

_base2.default.registerComponent = _component.registerComponent;

/**
 * Unregister a component.  Must be called before layerUI.init().
 *
 * Use this call to prevent a component from being registered with the document.
 * Currently this works only on components that have been already called with `layerUI.registerComponent`
 * but which have not yet been completed via a call to `layerUI.init()`.
 *
 * This is not typically needed, but allows you to defer creation of a widget, and then at some point later in your application lifecycle
 * define a replacement for that widget. You can not redefine an html tag that is registered with the document... but this prevents it from
 * being registered yet.
 */
_base2.default.unregisterComponent = _component.unregisterComponent;

_base2.default.init = function init() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  Object.keys(settings).forEach(function (name) {
    _base2.default.settings[name] = settings[name];
  });

  if (!_base2.default.settings.mixins) _base2.default.settings.mixins = [];

  // Register all widgets
  (0, _component.registerAll)();

  // Enable the text handlers
  _base2.default.settings.textHandlers.forEach(function (handlerName) {
    _base2.default.registerTextHandler({ name: handlerName });
  });
};

module.exports = _base2.default;

_base2.default.registerComponent = _component.registerComponent;

/**
 * Unregister a component.  Must be called before layerUI.init().
 *
 * Use this call to prevent a component from being registered with the document.
 * Currently this works only on components that have been already called with `layerUI.registerComponent`
 * but which have not yet been completed via a call to `layerUI.init()`.
 *
 * This is not typically needed, but allows you to defer creation of a widget, and then at some point later in your application lifecycle
 * define a replacement for that widget. You can not redefine an html tag that is registered with the document... but this prevents it from
 * being registered yet.
 */
_base2.default.unregisterComponent = _component.unregisterComponent;

_base2.default.init = function init() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  Object.keys(settings).forEach(function (name) {
    _base2.default.settings[name] = settings[name];
  });

  if (!_base2.default.settings.mixins) _base2.default.settings.mixins = [];

  // Register all widgets
  (0, _component.registerAll)();

  // Enable the text handlers
  _base2.default.settings.textHandlers.forEach(function (handlerName) {
    _base2.default.registerTextHandler({ name: handlerName });
  });
};

module.exports = _base2.default;
},{"./base":14,"./components/component":15,"./handlers/message/layer-message-unknown":43,"webcomponents.js/webcomponents-lite":78}],53:[function(require,module,exports){
/**
 * A helper mixin for Lists that render alternate text in the event that the list is Empty.
 *
 * @class layerUI.mixins.EmptyList
 */'use strict';


module.exports = {
  properties: {
    /**
         * If the query has no data and is not loading data, this should be true.
         *
         * @property {Boolean} [isEmptyList=false]
         * @readonly
         */
    isEmptyList: {
      value: false,
      set: function set(value) {
        this.nodes.emptyNode.style.display = value ? '' : 'none';
      }
    },

    /**
     * A dom node to render when there are no messages in the list.
     *
     * Could just be a message "Empty Conversation".  Or you can add interactive widgets.
     *
     * @property {HTMLElement} [emptyNode=null]
     */
    emptyNode: {
      set: function set(value) {
        this.nodes.emptyNode.innerHTML = '';
        if (value) this.nodes.emptyNode.appendChild(value);
      }
    }
  },
  methods: {
    onRender: function onRender() {
      this.nodes.emptyNode.style.display = this.isEmptyList ? '' : 'none';
      if (this.emptyNode) this.nodes.emptyNode.appendChild(this.emptyNode);
    },


    /**
     * Call this on any Query change events.
     *
     * @method onRerender
     * @private
     * @param {Event} evt
     */
    onRerender: function onRerender() {
      var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.query.isDestroyed) {
        this.isEmptyList = false;
      } else {
        this.isEmptyList = evt.type !== 'reset' && this.query.data.length === 0;
      }
    }
  }
};
},{}],54:[function(require,module,exports){
/**
 * A helper mixin for any widget that wants to refocus when keyboard input is received.
 *
 * Any class using this mixin must provide an `onKeyDown` method.
 *
 * @class layerUI.mixins.FocusOnKeydown
 */'use strict';


module.exports = {
  methods: {
    onCreate: function onCreate() {
      this.addEventListener('keydown', this._onKeyDown.bind(this));

      // Typically the defaultIndex is -1, but IE11 uses 0.
      // We must be focusable to receive keyboard input
      /* istanbul ignore next */
      var defaultIndex = document.head ? document.head.tabIndex : null;
      if (this.tabIndex === '' || this.tabIndex === -1 || this.tabIndex === defaultIndex) {
        this.tabIndex = -1;
      }
    },


    /**
     * Focus on compose bar if key is pressed within this panel.
     *
     * Unless the focus is on an input or textarea, in which case, let the user type.
     *
     * @method _onKeyDown
     * @param {Event} evt
     * @private
     */
    _onKeyDown: function _onKeyDown(evt) {
      var keyCode = evt.keyCode;
      var metaKey = evt.metaKey;
      var ctrlKey = evt.ctrlKey;
      if (metaKey || ctrlKey) return;

      /* istanbul ignore next */
      if (keyCode >= 65 && keyCode <= 90 || // a-z
      keyCode >= 48 && keyCode <= 57 || // 0-9
      keyCode >= 97 && keyCode <= 111 || // NUMPAD
      keyCode >= 186 && keyCode <= 191 || // Puncuation
      [32, 219, 220, 222].indexOf(keyCode) !== -1) {
        // Punctuation
        if (['INPUT', 'TEXTAREA'].indexOf(document.activeElement.tagName) === -1) {
          this.onKeyDown();
        }
      }
    }
  }
};
},{}],55:[function(require,module,exports){
/**
 * A Mixin for main components that can receive or generate a Query
 *
 * @class layerUI.mixins.HasQuery
 */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


module.exports = {
  properties: {

    /**
     * The Client is needed in order for the list to get a Query from a queryId
     *
     * @property {layer.Client} [client=null]
     */
    client: {
      set: function set(value) {
        if (value) {
          if (this.queryId) {
            this.query = value.getQuery(this.queryId);
          }
          if (this.properties._isMainComponent && this.useGeneratedQuery) {
            this._setupGeneratedQuery();
          }
        }
      }
    },

    /**
     * The ID for the layer.Query providing the items to render.
     *
     * Note that you can directly set the `query` property as well.
     *
     * Leaving this and the query properties empty will cause a layer.Query to be generated for you.
     *
     * @property {String} [queryId='']
     */
    queryId: {
      set: function set(value) {
        if (value && value.indexOf('layer:///') !== 0) this.properties.queryId = '';
        if (this.client) {
          this.query = this.queryId ? this.client.getQuery(this.queryId) : null;
        }
      }
    },

    /**
     * A layer.Query provides the items to render.
     *
     * Suggested practices:
     *
     * * If your not using this query elsewhere in your app, let this widget generate its own Query
     * * If setting this from an html template, use layerUI.mixins.List.queryId instead.
     *
     * @property {layer.Query} [query=null]
     */
    query: {
      set: function set(newValue, oldValue) {
        if (oldValue) oldValue.off(null, null, this);
        if (newValue instanceof _layerWebsdk2.default.Query) {
          this._updateQuery();
        } else {
          this.properties.query = null;
        }

        // If there is an oldQuery that we didn't generate, its up to the app to destroy it when it is done.
        if (this.properties._isMainComponent && this.hasGeneratedQuery) {
          this.hasGeneratedQuery = false;
          oldValue.destroy();
        }
      }
    },

    /**
     * The Query was generated internally, not passed in as an attribute or property.
     *
     * @property {Boolean} [hasGeneratedQuery=false]
     * @readonly
     */
    hasGeneratedQuery: {
      value: false,
      type: Boolean
    },

    /**
     * Does this widget generate its own query or should that behavior be prevented?
     *
     * If your providing your own Query, its a good practice to insure that a Query is NOT generated by the widget
     * as that Query will promptly fire, and consume your user's bandwidth.
     *
     * @property {Boolean } [useGeneratedQuery=true]
     */
    useGeneratedQuery: {
      value: true,
      type: Boolean
    },

    /**
     * How many items to page in each time we page the Query.
     *
     * @property {Number} [pageSize=50]
     */
    pageSize: {
      value: 50
    }
  },
  methods: {

    /**
     * A Component typically expects a Query as an input... or it needs to create its own.
     *
     * This method tests to see if it expects or has a Query, and creates one if needed.
     *
     * @method
     * @private
     */
    _setupGeneratedQuery: function _setupGeneratedQuery() {
      // Warning: Do not call the query getter via `this.query` as it may cause an infinite loop
      if (this._queryModel && !this.properties.query && this.client && !this.client.isDestroyed) {
        this.query = this.client.createQuery({
          model: this._queryModel,
          dataType: _layerWebsdk2.default.Query.InstanceDataType,
          paginationWindow: this.pageSize || 50
        });
        this.hasGeneratedQuery = true;
      }
    },


    /**
     * Any time we get a new Query assigned, wire it up.
     *
     * @method _updateQuery
     * @private
     */
    _updateQuery: function _updateQuery() {
      this.client = this.query.client;
      this.onRender();
      this.query.on('change', this.onRerender, this);
    }
  }
};
},{"layer-websdk":79}],56:[function(require,module,exports){
/**
 * A List Item Mixin that add an `isSelected` property to a List.
 *
 * Also listens for `click` events to update the `selectedId` property,
 * and triggers a selection events.
 *
 * @class layerUI.mixins.ListSelection
 */'use strict';



module.exports = {
  properties: {
    isSelected: {
      type: Boolean,
      set: function set(value) {
        this.toggleClass('layer-selected-item', value);
        this.onSelection(value);
      }
    }
  },
  methods: {
    /**
     * MIXIN HOOK: Each time a an item's selection state changes, this will be called.
     *
     * @method onSelection
     * @param {Boolean} isSelected
     */
    onSelection: function onSelection(isSelected) {
      // No-op
    }
  }
};
},{}],57:[function(require,module,exports){
/**
 * A List Item Mixin that provides common properties, shortcuts and code.
 *
 * This Mixin requires a template that provides a `layer-list-item` class
 *
 * @class layerUI.mixins.ListItem
 */'use strict';



module.exports = {
  properties: {
    /**
     * Is this component a List Item
     *
     * @private
     * @readonly
     * @property {Boolean} [_isListItem=true]
     */
    _isListItem: {
      value: true
    },

    /**
     * A custom DOM node added by your application; this is not the prior List Item.
     *
     * You can set this to a DOM Node or html string
     *
     * @property {HTMLElement | String} [customNodeAbove=null]
     */
    customNodeAbove: {
      set: function set(node) {
        if (this.properties._customNodeAbove) this.removeChild(this.properties._customNodeAbove);
        if (node && typeof node === 'string') {
          var tmp = node;
          node = document.createElement('div');
          node.innerHTML = tmp;
          this.properties.customNodeAbove = node;
        }
        if (node) {
          this.insertBefore(node, this.querySelector('.layer-list-item'));
        } else {
          this.properties.customNodeAbove = null;
        }
        this.properties._customNodeAbove = node;
      }
    },

    /**
     * A custom DOM node added by your application; this is not the prior List Item.
     *
     * You can set this to a DOM Node or html string
     *
     * @property {HTMLElement | String} [customNodeBelow=null]
     */
    customNodeBelow: {
      set: function set(node) {
        if (this.properties._customNodeBelow) this.removeChild(this.properties._customNodeBelow);
        if (node && typeof node === 'string') {
          var tmp = node;
          node = document.createElement('div');
          node.innerHTML = tmp;
          this.properties.customNodeBelow = node;
        }
        if (node) {
          this.appendChild(node);
        } else {
          this.properties.customNodeBelow = null;
        }
        this.properties._customNodeBelow = node;
      }
    },

    /**
     * Shortcut to the `.layer-list-item` node
     *
     * @property {HTMLElement} [innerNode=null]
     * @private
     */
    innerNode: {},

    /**
     * Sets whether this widget is the first in a series of layerUI.MessageItem set.
     *
     * @property {Boolean} [firstInSeries=false]
     */
    firstInSeries: {
      type: Boolean,
      value: false,
      set: function set(value) {
        this.toggleClass('layer-list-item-first', value);
      }
    },

    /**
     * Sets whether this widget is the last in a series of layerUI.MessageItem set.
     *
     * @property {Boolean} [lastInSeries=false]
     */
    lastInSeries: {
      type: Boolean,
      value: false,
      set: function set(value) {
        this.toggleClass('layer-list-item-last', value);
      }
    },

    /**
     * The item of data in a list of data that this List Item will render.
     *
     * @property {layer.Root} [item=null]
     */
    item: {
      set: function set(newItem, oldItem) {
        var _this = this;

        // Disconnect from any previous Message we were rendering; not currently used.
        if (oldItem) oldItem.off(null, null, this);

        // Any changes to the Message should trigger a rerender
        if (newItem) newItem.on(newItem.constructor.eventPrefix + ':change', this.onRerender, this);
        Object.keys(this.nodes).forEach(function (nodeName) {
          _this.nodes[nodeName].item = newItem;
        });
        this.onRender();
      }
    }
  },
  methods: {
    onCreate: function onCreate() {
      this.innerNode = this.querySelector('.layer-list-item');
    },


    onRender: {
      conditional: function onCanRender() {
        return Boolean(this.item);
      }
    },

    /**
     * Adds the CSS class to this list item's outer node.
     *
     * @method addClass
     * @param {String} className
     */
    addClass: function addClass(className) {
      this.classList.add(className);
    },


    /**
     * Removes the CSS class from this list item's outer node.
     *
     * @method removeClass
     * @param {String} className
     */
    removeClass: function removeClass(className) {
      this.classList.remove(className);
    },


    /**
     * Toggles the CSS class of this list item's outer node.
     *
     * @method toggleClass
     * @param {String} className
     * @param {Boolean} [add=true]
     */
    toggleClass: function toggleClass(className) {
      var add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.classList[add ? 'add' : 'remove'](className);
    }
  }
};
},{}],58:[function(require,module,exports){
/**
 * A List Mixin that add a `selectedId` property to a List.
 *
 * Also listens for `click` events to update the `selectedId` property,
 * and triggers selection events.
 *
 * @class layerUI.mixins.ListSelection
 */'use strict';


module.exports = {
  properties: {

    /**
     * Get/Set the selected Conversation by ID.
     *
     * ```javascript
     * list.selectedId = myConversation.id;
     * ```
     *
     * Or if using a templating engine:
     *
     * ```html
     * <layer-conversations-list selected-id={{selectedConversation.id}}></layer-conversations-list>
     * ```
     *
     * The above code will set the selected Conversation and render the conversation as selected.
     *
     * @property {String} [selectedId='']
     */
    selectedId: {
      set: function set(newId, oldId) {
        if (oldId) {
          var node = this.querySelector('#' + this._getItemId(oldId));
          if (node) node.isSelected = false;
        }

        if (newId) {
          var _node = this.querySelector('#' + this._getItemId(newId));
          if (_node) _node.isSelected = true;
        }
      }
    }
  },
  methods: {
    onCreate: function onCreate() {
      this.addEventListener('click', this._onClick.bind(this));
    },


    /**
     * User has selected something in the Conversation List that didn't handle that click event.
     *
     * Find the Conversation Item selected and generate a `layer-conversation-selected` event.
     * Click events do NOT bubble up; they must either be handled by the layerUI.components.ConversationsListPanel.Item.Conversation or
     * they are treated as a selection event.
     *
     * Listening to `layer-conversation-selected` you will still receive the original click event
     * in case you wish to process that futher; see `originalEvent` below.
     *
     * Calling `evt.preventDefault()` will prevent selection from occuring.
     *
     * @method _onClick
     * @private
     * @param {Event} evt
     */
    _onClick: function _onClick(evt) {
      var target = evt.target;
      while (target && target !== this && !target._isListItem) {
        target = target.parentNode;
      }

      if (target.item && target._isListItem) {
        evt.preventDefault();
        evt.stopPropagation();
        if (this.trigger(this._selectedItemEventName, { item: target.item, originalEvent: evt })) {
          this.selectedId = target.item.id;
        }
      }
      this.onClick(evt);
    },


    /**
     * MIXIN HOOK: Each time a Conversation is Clicked, you can hook into that by providing an onClick method.
     *
     * Note that prior to this call, `evt.preventDefault()` and `evt.stopPropagation()` were already called.
     *
     * @method onClick
     * @param {Event} evt
     */
    onClick: function onClick(evt) {
      // No-op
    },


    /*
     * Any time an item is generated, see if it needs to be set as selected.
     */
    onGenerateListItem: function onGenerateListItem(widget) {
      if (widget.item.id === this.selectedId) widget.isSelected = true;
    }
  }
};
},{}],59:[function(require,module,exports){
/**
    * A List Mixin that provides common list patterns
    *
    * @class layerUI.mixins.List
    * @mixin layerUI.mixins.HasQuery
    */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _component = require('../components/component');

var _hasQuery = require('./has-query');

var _hasQuery2 = _interopRequireDefault(_hasQuery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = {
  mixins: [_hasQuery2.default],
  properties: {
    /**
     * Lists have some special behaviors; its useful to be able to test if a component is in fact a list.
     *
     * @property {Boolean} [_isList=true]
     * @private
     * @readonly
     */
    _isList: {
      value: true
    },

    /**
     * Set/get state related to whether the Query data is loading data from the server.
     *
     * This is managed by the app, and is updated any time the layer.Query changes state.
     *
     * You could set this as well if you need to indicate some activity outside of the layer.Query:
     *
     * ```
     * widget.isDataLoading = true;
     * ```
     *
     * @property {Boolean} [isDataLoading=false]
     */
    isDataLoading: {
      set: function set(value) {
        this.classList[value ? 'add' : 'remove']('layer-loading-data');
      }
    },

    /**
     * Any time we are about to render an object, call any provided onRenderListItem function to see if there
     * are nodes to be inserted before/after the User Item.
     *
     * ```javascript
     * userList.onRenderListItem = function(widget, dataArray, index, isTopItemNew) {
     *     var conversation = widget.item;
     *     var priorConversation = dataArray[index - 1];
     *     if (index > 0 && conversation.metadata.category !== priorConversation.metadata.category) {
     *        widget.customNodeAbove = '<div class="my-separator">' + widget.user.metadata.category + '</div>';
     *     }
     * });
     * ```
     *
     * Typical actions on receiving a widget is to set its customNodeAbove and/or customNodeBelow to either a DOM node or an HTML String.
     *
     * @property {Function} [onRenderListItem=null]      Function to call on each rendered item.
     * @property {layer.Root} onRenderListItem.widget    Current user/message/conversation/list-item widget that has been created from the Query.
     * @property {layer.Root[]} onRenderListItem.items   Full set of users/messages/conversations have been/will be rendered
     * @property {Number} onRenderListItem.index         Index of the user/message/conversation in the items array
     * @property {Boolean} onRenderListItem.isTopItemNew If the top item is index 0, and its newly added rather than just affected by changes
     *           around it, this is often useful to know.
     */
    onRenderListItem: {
      type: Function
    },

    /**
     * How many items to page in each time we page the Query.
     *
     * @property {Number} [pageSize=50]
     */
    pageSize: {
      value: 50
    },

    /**
     * A throttler is used to prevent excessive scroll events.
     *
     * This timeout indicates how frequently scroll events are allowed to fire in miliseconds.
     * This value should not need to be tinkered with.
     *
     * @property {Number} [throttlerTimeout=66]
     */
    throttlerTimeout: {
      value: 66
    },

    state: {
      set: function set(newState) {
        Array.prototype.slice.call(this.childNodes).forEach(function (node) {
          node.state = newState;
        });
      }
    },

    /**
     * String, Regular Expression or Function for filtering Conversations.
     *
     * Defaults to filtering by comparing input against things like Conversation.metadata.conversationName, or Identity.displayName, etc.
     * Provide your own Function to change this behavior
     *
     * @property {String|RegEx|Function} [filter='']
     */
    filter: {
      set: function set(value) {
        this._runFilter();
      }
    }
  },
  methods: {
    onCreate: function onCreate() {
      if (!this.id) this.id = _layerWebsdk2.default.Util.generateUUID();
      this.properties.listData = [];
      this.addEventListener('scroll', this._onScroll.bind(this));
      this.onRender();
    },


    /**
     * The _onScroll method throttles calls to the handleScroll method.
     *
     * @method _onScroll
     * @param {Event} evt
     * @private
     */
    _onScroll: function _onScroll(evt) {
      if (this.properties.isSelfScrolling) {
        evt.preventDefault();
      } else {
        this._throttler(this._handleScroll.bind(this));
      }
    },


    /**
     * Simple throttler to avoid too many events while scrolling.
     *
     * Not at this time safe for handling multiple types of events at the same time.
     *
     * @method _throttler
     * @private
     */
    _throttler: function _throttler(callback) {
      var _this = this;

      if (!this.properties.throttleTimeout) {
        this.properties.throttleTimeout = setTimeout(function () {
          _this.properties.throttleTimeout = null;
          callback();
        }, this.throttlerTimeout);
      }
    },


    /**
     * Any time we get a new Query assigned, wire it up.
     *
     * @method _updateQuery
     * @private
     */
    _updateQuery: function _updateQuery() {
      this.query.on('change:property', this._runFilter, this);
    },


    /**
     * If the user scrolls to the bottom of the list, page the Query.
     *
     * @method _handleScroll
     * @private
     */
    _handleScroll: function _handleScroll() {
      if (this.scrollTop >= this.scrollHeight - this.clientHeight - 20 && this.scrollTop > 0) {
        this.query.update({ paginationWindow: this.query.paginationWindow + this.pageSize });
        this.isDataLoading = this.properties.query.isFiring;
      }
    },


    /**
     * Scroll the list to the specified Y position.
     *
     * @method scrollTo
     * @param {Number} position
     */
    scrollTo: function scrollTo(position) {
      if (position === this.scrollTop) return;
      this.scrollTop = position;
    },
    onRender: function onRender() {
      var _this2 = this;

      // Reset the query to initial state by cloning the template
      Array.prototype.slice.call(this.childNodes).forEach(function (node) {
        if (node._isListItem) _this2.removeChild(node);
      });

      // Render any data in the query
      if (this.query && this.query.size) {
        this.onRerender({ type: 'data', data: this.query.data, inRender: true });
      }
    },


    onRerender: {
      mode: _component.registerComponent.MODES.BEFORE,
      value: function value() {
        var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (this.query.isDestroyed) {
          this._renderResetData(evt);
        } else {
          this._processQueryEvt(evt);
        }
      }
    },

    /**
     * Generate a document fragment with all the newly added Users.
     *
     * @method _generateFragment
     * @private
     */
    _generateFragment: function _generateFragment(data, fragment) {
      var _this3 = this;

      if (!fragment) fragment = document.createDocumentFragment();
      data.forEach(function (item, index) {
        _this3._generateFragmentItem(item, fragment);
      }, this);
      return fragment;
    },


    /**
     * Generate a unique but consistent DOM ID for each layerUI.mixins.ListItem.
     *
     * @method _getItemId
     * @param {String} itemId
     * @private
     */
    _getItemId: function _getItemId(itemId) {
      return 'list-item-' + this.id + '-' + itemId.replace(/[^a-zA-Z0-9-_]/g, '-').replace(/-+/g, '-');
    },


    /**
     * Generate an list-item for one query result.
     *
     * @method _generateFragmentItem
     * @private
     */
    _generateFragmentItem: function _generateFragmentItem(item, fragment) {
      var itemInstance = item instanceof _layerWebsdk2.default.Root ? item : this.client.getObject(item.id);
      if (itemInstance) {
        var widget = this._generateItem(itemInstance);
        widget.parentComponent = this;
        widget.setAttribute('layer-item-id', item.id.replace(/^layer:\/\/\//, '').replace(/\//g, '_'));
        if (widget) {
          this.onGenerateListItem(widget);
          fragment.appendChild(widget);
        }
      }
    },


    /**
     * MIXIN HOOK: Each time a List Item is generated, call this so that listeners can use this.
     *
     * This is intended for Mixins to hook into; apps wanting to do processing on rendered
     * items should use `onRenderListItem`.
     *
     * @method
     * @param {layerUI.mixins.ListItem} widget
     */
    onGenerateListItem: function onGenerateListItem(widget) {
      // No-op
    },


    /**
     * Find the widgets associated with each affected item and feed it to processAffectedWidgets.
     *
     * @method _gatherAndProcessAffectedItems
     * @private
     */
    _gatherAndProcessAffectedItems: function _gatherAndProcessAffectedItems(affectedItems, isTopItemNew) {
      var _this4 = this;

      if (affectedItems.length) {
        var itemIds = affectedItems.map(function (item) {
          return _this4._getItemId(item.id);
        });
        var affectedWidgets = this.querySelectorAllArray('#' + itemIds.join(', #'));
        this._processAffectedWidgets(affectedWidgets, isTopItemNew);
      }
    },


    /**
     * For all newly added items, as well as items near them,
     * call onRenderListItem and _processAffectedWidgetsCustom to udpate
     * any rendering state needed.
     *
     * widgets are assumed to be sequential within the list.
     *
     * @method _processAffectedWidgets
     * @private
     */
    _processAffectedWidgets: function _processAffectedWidgets(widgets, isTopItemNew) {
      var _this5 = this;

      // Get the index of our first widget within listData
      var firstIndex = void 0;
      for (var i = 0; i < this.properties.listData.length; i++) {
        if (widgets.length && widgets[0].item.id === this.properties.listData[i].id) {
          firstIndex = i;
          break;
        }
      }

      // Do our internal processing of these widgets
      this._processAffectedWidgetsCustom(widgets, firstIndex, isTopItemNew);

      // Allow external processing of the widgets
      widgets.forEach(function (widget, index) {
        if (_this5.properties.onRenderListItem) {
          try {
            _this5.properties.onRenderListItem(widget, _this5.properties.listData, firstIndex + index, isTopItemNew);
          } catch (err) {
            console.error('Error in onRenderListItem for ' + widget.item.id + '; ' + err);
          }
        }
      }, this);
    },


    /**
     * Lists should override this to provide custom behaviors on newly added/affected items.
     *
     * @method _processAffectedWidgetsCustom
     * @private
     * @param {layerUI.mixins.ListItem} widgets
     * @param {Number} firstIndex - Index in the listData array of the first item in the widgets array
     * @param {Boolean} isTopItemNew - If the top item is index 0 and its a new item rather than an "affected" item, this is true.
     */
    _processAffectedWidgetsCustom: function _processAffectedWidgetsCustom(widgets, firstIndex, isTopItemNew) {},


    /**
     * Call this on any Query change events.
     *
     * TODO: This should work on the MessageList which is in Reverse Order
     *
     * @method _processQueryEvt
     * @private
     * @param {Event} evt
     */
    _processQueryEvt: function _processQueryEvt(evt) {
      switch (evt.type) {
        case 'data':
          this._renderPagedData(evt);
          break;
        case 'insert':
          this._renderInsertedData(evt);
          break;
        case 'remove':
          this._renderWithoutRemovedData(evt);
          break;
        case 'reset':
          this._renderResetData(evt);
          break;
        case 'move':
          this._renderMovedData(evt);
      }
    },


    /**
     * The query has been reset of all data, perhaps its now got a new predicate.
     *
     * Clear all data and list state
     *
     * @method _renderResetData
     * @private
     */
    _renderResetData: function _renderResetData(evt) {
      this.properties.listData = [];
      this.scrollTo(0);
      this.onRender();
    },


    /**
     * The query results have had an element move from one position to another.
     *
     * We need to update our list to reflect that change.
     *
     * @method _renderMovedData
     * @private
     */
    _renderMovedData: function _renderMovedData(evt) {
      var oldIndex = evt.fromIndex;
      var newIndex = evt.toIndex;
      var moveNode = this.childNodes[oldIndex];
      this.removeChild(moveNode);
      this.insertBefore(moveNode, this.childNodes[newIndex]);
      if (!evt.inRender) this.onRerender();
    },


    /**
     * Data has been removed from the query; remove that data from our UI.
     *
     * Calls _gatherAndProcessAffectedItems on 3 items prior and 3 items after the removed item.
     *
     * @method _renderWithoutRemovedData
     * @private
     */
    _renderWithoutRemovedData: function _renderWithoutRemovedData(evt) {
      this.properties.listData = [].concat(this.properties.query.data);
      var removeIndex = evt.index;
      var affectedItems = this.properties.listData.slice(Math.max(0, removeIndex - 3), removeIndex + 3);
      var listItem = this.querySelector('#' + this._getItemId(evt.target.id));
      if (listItem) this.removeChild(listItem);

      this._gatherAndProcessAffectedItems(affectedItems, false);
    },


    /**
     * Data has been inserted into the results; insert it into our UI list.
     *
     * @method _renderInsertedData
     * @private
     */
    _renderInsertedData: function _renderInsertedData(evt) {
      this.properties.listData = [].concat(this.properties.query.data);
      var insertIndex = evt.index;
      var affectedItems = this.properties.listData.slice(Math.max(0, insertIndex - 3), insertIndex + 4);
      var fragment = this._generateFragment([evt.target]);
      this.insertBefore(fragment, this.childNodes[insertIndex]);
      this._gatherAndProcessAffectedItems(affectedItems, insertIndex === 0);
    },


    /**
     * A new page of data has been loaded by the query; insert it into our results.
     *
     * @method _renderPagedData
     * @private
     */
    _renderPagedData: function _renderPagedData(evt) {
      var affectedItems = this.properties.listData.slice(this.properties.listData.length - 3, this.properties.listData.length).concat(evt.data);
      this.properties.listData = [].concat(this.properties.query.data);
      var fragment = this._generateFragment(evt.data);

      this.insertBefore(fragment, this.nodes.loadIndicator);

      // isTopItemNew is true if there wasn't any prior data... data length == event length
      this._gatherAndProcessAffectedItems(affectedItems, evt.data.length === this.properties.query.data.length);
      this.isDataLoading = this.properties.query.isFiring;
      if (!evt.inRender) this.onRerender();
    },


    /**
     * Run the filter on all Identity Items.
     *
     * @method _runFilter
     * @private
     */
    _runFilter: function _runFilter() {
      if (!this.filter) {
        this.querySelectorAllArray('.layer-item-filtered').forEach(function (item) {
          return item.removeClass('layer-item-filtered');
        });
      } else {
        for (var i = 0; i < this.childNodes.length; i++) {
          var listItem = this.childNodes[i];
          if (listItem.item instanceof _layerWebsdk2.default.Root) {
            listItem._runFilter(this.filter);
          }
        }
      }
    }
  }
}; 
},{"../components/component":15,"./has-query":55,"layer-websdk":79}],60:[function(require,module,exports){
/**
 * A Mixin for main components (not needed for subcomponents) that provides common properties, shortcuts and code.
 *
 * @class layerUI.mixins.MainComponent
 */'use strict';

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _base = require('../base');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


module.exports = {
  properties: {
    /**
     * Is this component a Main Component (high level for use by third party apps).
     *
     * Used by adapters to find components to adapt.
     * @private
     * @readonly
     * @property {Boolean} [_isMainComponent=true]
     */
    _isMainComponent: {
      value: true
    },

    /**
     * An App ID can be provided as a property; this allows the app to find its Client.
     *
     * App IDs are typically provided via:
     *
     * ```
     * layerUI.init(({ appId: myAppId })
     * ```
     *
     * The only time one would use this property
     * is if building an app that used multiple App IDs.
     *
     * @property {String} [appId=""]
     */
    appId: {
      order: 1,
      set: function set(value) {
        if (value && value.indexOf('layer:///') === 0) {
          var client = _layerWebsdk2.default.Client.getClient(value);
          if (!client) throw new Error('You must create a layer.Client with your appId before creating this component');
          this.client = client;
        }
      }
    },

    /**
     * The layer.Client can be passed in via the `client` property or the `appId` property.
     *
     * App IDs are typically provided via:
     *
     * ```
     * layerUI.init(({ appId: myAppId })
     * ```
     *
     * The only time one would use this property
     * is if building an app that used multiple Clients.
     *
     * @property {layer.Client} [client=null]
     */
    client: {
      order: 2,
      set: function set(value) {
        var _this = this;

        if (value) {
          value.on('destroy', function (evt) {
            if (evt.target === value) _this.properties.client = null;
          }, this);
        }
      }
    }
  },
  methods: {
    onCreate: function onCreate() {
      if (_base.settings.appId) this.appId = _base.settings.appId;
      var useSafariCss = navigator.vendor && navigator.vendor.indexOf('Apple') > -1;
      if (useSafariCss) this.classList.add('safari');
    }
  }
};
},{"../base":14,"layer-websdk":79}],61:[function(require,module,exports){
/**
    * A Message Handler Mixin that provides common properties and behaviors for implementing a Card.
    *
    * ```
    * import MessageHandler from 'layer-ui-web/lib/mixins/message-handler';
    * layerUI.registerComponent('sample-message-handler', {
    *     mixins: [MessageHandler],
    *     methods: {
    *         onCreate() {
    *            // If using a template, your dom nodes will already be setup,
    *            // and you can wire up UI event handlers here.
    *            // Do any DOM creation/manipulation that does not depend upon the message here.
    *         },
    *
    *         onSent() {
    *           // If you are rendering messages before they are sent, and need special processing of them once they ARE sent,
    *           // put your special processing in here
    *         },
    *
    *         // Your onRender method is called once the message property is set.
    *         onRender() {
    *            // DOM Manipulation Here
    *         },
    *
    *         // Your onRerender method is called by onRender, and called any time the Message
    *         // changes; all dynamic rendering goes in onRerender.
    *         onRerender() {
    *             // DOM Manipulation Here
    *         }
    *     }
    * });
    *
    * // If a template is needed, register a template for your component using a String;
    * // Note that layer-id will allow you to access these nodes directly as this.nodes.description
    * // or this.nodes.checkox
    * layerUI.buildAndRegisterTemplate('sample-message-handler', '<label layer-id="label">Approve Purchase</label>' +
    *    '<input type="checkbox" layer-id="checkbox" /><div layer-id="description"></div>');
    *
    * // OR Register a template for your component using a <template /> DOM node:
    * layerUI.registerTemplate('sample-message-handler', myTemplateNode);
    * ```
    *
    * If you need to add side effects to setting the `message` property, you can add a message setter; it will be
    * called before the MessageHandlerMixin's message setter:
    *
    * ```
    * layerUI.registerComponent('sample-message-handler', {
    *   mixins: [MessageHandler],
    *   properties: {
    *     message: {
    *       setter: function(value) {
    *         this.properties.data = value.parts[0].body;
    *       }
    *     }
    *   },
    *   methods: {
    *     onRender: function() {
    *       this.innerHTML = this.properties.data;
    *     }
    *   }
    * });
    * ```
    *
    * @class layerUI.mixins.MessageHandler
    */'use strict';

var _component = require('../components/component');

module.exports = {
  properties: {
    /**
     * The layer.Message to be rendered.
     *
     * @property {layer.Message} message
     */
    message: {
      mode: _component.registerComponent.MODES.AFTER,
      set: function set() {
        this.onRender();
        this.message.on('messages:change', this.onRerender, this);
        if (this.message.isNew()) this.message.once('messages:sent', this.onSent, this);
      }
    }
  },
  methods: {

    /**
     * Your onRender method is called once the message property is set.
     *
     * Any call to onRender will also call onRerender
     * which may handle some more dynamic rendering.
     *
     * @method onRender
     */
    onRender: {
      conditional: function onCanRender() {
        return Boolean(this.message && !this.message.isDestroyed);
      },
      mode: _component.registerComponent.MODES.AFTER,
      value: function onRender() {
        this.onRerender();
      }
    },

    /**
     * Your onRerender method handles any dynamic rendering.
     *
     * It should be called when:
     *
     * * Your layer.Message is first rendered
     * * Your layer.Message triggers any `messages:change` events
     * * Any outside events that influence rendering occur (though this is in your control)
     *
     * @method onRerender
     */
    onRerender: function onRerender() {},


    /**
     * Your onSent method will be called if you rendered the message prior to sending it.
     *
     * Use this if there is any change to your message that need to be made after its been sent.
     *
     * @method onSent
     */
    onSent: function onSent() {}
  }
}; 
},{"../components/component":15}],62:[function(require,module,exports){
/**
 * A helper mixin for Lists that render alternate text in the event that the list is Empty.
 *
 * @class layerUI.mixins.StateManager
 */"use strict";


module.exports = {
  properties: {
    /**
     * This state property enables your application to  expose application state to the widget.
     *
     * A flux app for example, might pass its state and actions into this property in order
     * to make it available to all widgets of the DOM subtree.
     *
     * ```
     * widget.state = {
     *   reduxState: {
     *      a: this.props.a,
     *      b: this.props.b
     *   },
     *   reduxActions: {
     *      action1: this.props.actions.action1,
     *      action2: this.props.actions.action2
     *   }
     * };
     * ```
     *
     * Which can then be accessed from within any widget using:
     *
     * ```
     * this.state.reduxActions.action1();
     * ```
     *
     * Note that state properties are propagated during the `onAfterCreate` event, and as such, may not yet be set in `onCreate`
     * nor in `onAfterCreate`.  Subcomponents may not see the state until after the first `onRender` call.
     *
     * TODO: Prevent subcomponent `onRender` from calling without `state`; must handle case where `state` property is unused.
     *
     * @property {Object} state
     */
    state: {
      propagateToChildren: true,
      set: function set(newState) {
        if (this.onRenderState) this.onRenderState();
      }
    }
  }
};
},{}],63:[function(require,module,exports){
/**
                                                       * Use this module to put a date separator between Messages from different dates in your Messages List.
                                                       *
                                                       * ```
                                                       * conversationPanel.onRenderListItem = layerUI.utils.dateSeparator;
                                                       * ```
                                                       *
                                                       * Or if you have multiple `onRenderListItem` handlers:
                                                       *
                                                       * ```
                                                       * conversationPanel.onRenderListItem = function(widget, messages, index, isTopItem) {
                                                       *     layerUI.utils.dateSeparator(widget, messages, index);
                                                       *     handler2(widget, messages, index, isTopItem);
                                                       *     handler3(widget, messages, index, isTopItem);
                                                       * }
                                                       * ```
                                                       *
                                                       * Date separators come as `<div class='layer-list-item-separator-date'><span>DATE</span></div>`
                                                       *
                                                       * @class layerUI.utils.DateSeparator
                                                       */'use strict';

var _base = require('../base');

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dateClassName = 'layer-list-item-separator-date'; 


module.exports = _base.utils.dateSeparator = function (widget, messages, index) {
  var message = widget.item;
  var needsBoundary = index === 0 || message.sentAt.toDateString() !== messages[index - 1].sentAt.toDateString();

  if (needsBoundary) {
    var options = { weekday: 'long', year: 'numeric', month: 'short', day: '2-digit' };
    var dateStr = messages[index].sentAt.toLocaleDateString(undefined, options);
    _base2.default.addListItemSeparator(widget, '<span>' + dateStr + '</span>', dateClassName, true);
  } else {
    _base2.default.addListItemSeparator(widget, '', dateClassName, true);
  }
};
},{"../base":14}],64:[function(require,module,exports){
/**
 * This is a utility class which you can use to watch for user dragging and dropping
 * files from their file system into your app as part of a "Send Attached Message" action.
 *
 * ```
 * var dropWatcher = new layerUI.files.DragAndDropFileWatcher({
 *   node: dropBoxNode,
 *   callback: sendAttachment,
 *   allowDocumentDrop: false
 * });
 * function sendAttachment(messageParts) {
 *    currentConversation.createMessage({ parts: messageParts }).send();
 * }
 *
 * // If you finish with this component, call destroy to unsubscribe from all events and remove all pointers
 * dropWatcher.destroy();
 * ```
 *
 * @class layerUI.utils.files.DragAndDropFileWatcher
 * @param {Object} options
 * @param {HTMLElement|String} options.node - The dom node (or dom node ID) to watch for files/file-drag events
 * @param {Function} options.callback - The function to call when a file is dropped
 * @param {layer.MessagePart[]} options.callback.parts - The MessageParts representing the dropped files, which you can modify and send.
 * @param {Boolean} [options.allowDocumentDrop=false] - By default, this utility adds an event handler to prevent the browser from navigating away from your
 *         app to view a file dropped in some other part of your app. If you need to handle this event yourself, set this to true.
 */'use strict';

var _loadImage = require('blueimp-load-image/js/load-image');

var _loadImage2 = _interopRequireDefault(_loadImage);

require('blueimp-load-image/js/load-image-orientation');

require('blueimp-load-image/js/load-image-meta');

require('blueimp-load-image/js/load-image-exif');

var _layerWebsdk = require('layer-websdk');

var _layerWebsdk2 = _interopRequireDefault(_layerWebsdk);

var _base = require('../base');

var _base2 = _interopRequireDefault(_base);

var _sizing = require('./sizing');

var _sizing2 = _interopRequireDefault(_sizing);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Files = {};
module.exports = Files;

window.loadImage = _loadImage2.default;


Files.DragAndDropFileWatcher = function DragAndDropFileWatcher(options) {
  this.node = typeof options.node === 'string' ? document.getElementById(options.node) : options.node;
  this.callback = options.callback;
  this.allowDocumentDrop = Boolean(options.allowDocumentDrop);

  this.onDragOverBound = this.onDragOver.bind(this);
  this.onDragEndBound = this.onDragEnd.bind(this);
  this.onFileDropBound = this.onFileDrop.bind(this);
  this.ignoreDropBound = this.ignoreDrop.bind(this);

  // Tells the browser that we *can* drop on this target
  this.node.addEventListener('dragover', this.onDragOverBound, false);
  this.node.addEventListener('dragenter', this.onDragOverBound, false);

  this.node.addEventListener('dragend', this.onDragEndBound, false);
  this.node.addEventListener('dragleave', this.onDragEndBound, false);

  this.node.addEventListener('drop', this.onFileDropBound, false);

  if (!this.allowDocumentDrop) {
    document.addEventListener('drop', this.ignoreDropBound, false);
    document.addEventListener('dragenter', this.ignoreDropBound, false);
    document.addEventListener('dragover', this.ignoreDropBound, false);
  }
};

/**
 * Destroy this component, in particular, remove any handling of any events.
 *
 * @method
 */
Files.DragAndDropFileWatcher.prototype.destroy = function destroy() {
  this.node.removeEventListener('dragover', this.onDragOverBound, false);
  this.node.removeEventListener('dragenter', this.onDragOverBound, false);

  this.node.removeEventListener('dragend', this.onDragEndBound, false);
  this.node.removeEventListener('dragleave', this.onDragEndBound, false);

  this.node.removeEventListener('drop', this.onFileDropBound, false);

  if (!this.allowDocumentDrop) {
    document.removeEventListener('drop', this.ignoreDropBound, false);
    document.removeEventListener('dragenter', this.ignoreDropBound, false);
    document.removeEventListener('dragover', this.ignoreDropBound, false);
  }
  delete this.node;
  delete this.callback;
};

/**
 * Whatever it is that the browser wants to do by default with this file,
 * prevent it.  Why? Well, one of the more annoying thing it may do
 * is navigate away from your app to show this file.
 *
 * @method
 * @private
 */
Files.DragAndDropFileWatcher.prototype.ignoreDrop = function ignoreDrop(evt) {
  if (evt.preventDefault) {
    evt.preventDefault();
    evt.stopPropagation();
  }
  return false;
};

/**
 * On hovering with a file, add a css class
 *
 * @method
 * @private
 */
Files.DragAndDropFileWatcher.prototype.onDragOver = function onDragOver(evt) {
  this.node.classList.add('layer-file-drag-and-drop-hover');
  evt.preventDefault();
  return false;
};

/**
 * On un-hovering with a file, remove a css class
 *
 * @method
 * @private
 */
Files.DragAndDropFileWatcher.prototype.onDragEnd = function onDragEnd(evt) {
  this.node.classList.remove('layer-file-drag-and-drop-hover');
};

/**
 * On file drop, generate an array of Message Parts and pass it on to app.
 *
 * @method
 * @private
 */
Files.DragAndDropFileWatcher.prototype.onFileDrop = function onFileDrop(evt) {
  this.onDragEnd();

  // stops the browser from redirecting off to the image.
  if (evt.preventDefault) {
    evt.preventDefault();
    evt.stopPropagation();
  }

  var dt = evt.dataTransfer;
  var parts = Array.prototype.map.call(dt.files, function (file) {
    return new _layerWebsdk2.default.MessagePart(file);
  });

  Files.processAttachments(parts, this.callback);
  return false;
};

/**
 * Adds data to your message.
 *
 * Given an array of Message Parts, determines if it needs to generate image or video
 * previews and metadata message parts before calling your callback.
 *
 * @method processAttachments
 * @param {layer.MessagePart[]} parts    Input MessagParts, presumably an array of one element
 * @param {Function} callback            Callback on completion; may be called synchronously
 * @param {layer.MessagePart[]} callback.parts  The MessageParts to send in your Message
 */
Files.processAttachments = function processAttachments(parts, callback) {
  // TODO: Need a way to register additional handlers; currently relies on the callback for additional handling.
  parts.forEach(function (part) {
    if (['image/gif', 'image/png', 'image/jpeg'].indexOf(part.mimeType) !== -1) {
      Files.generateImageMessageParts(part, callback);
    } else if (part.mimeType === 'video/mp4') {
      Files.generateVideoMessageParts(part, callback);
    } else if (callback) {
      callback([part]);
    }
  });
};

Files.generateImageMessageParts = function generateImageMessageParts(part, callback) {
  // First part is the original image; the rest of the code is for generating the other 2 parts of the 3 part Image
  var parts = [part];
  var orientation = 0;

  // STEP 1: Determine the correct orientation for the image
  _loadImage2.default.parseMetaData(part.body, onParseMetadata);

  function onParseMetadata(data) {
    var options = {
      canvas: true
    };

    if (data.imageHead && data.exif) {
      orientation = options.orientation = data.exif[0x0112] || orientation;
    }

    // STEP 2: Write the image to a canvas with the specified orientation
    (0, _loadImage2.default)(part.body, onWriteImage, options);
  }

  function onWriteImage(srcCanvas) {
    // STEP 3: Scale the image down to Preview Size
    var originalSize = {
      width: srcCanvas.width,
      height: srcCanvas.height
    };

    var size = (0, _sizing2.default)(originalSize, _base2.default.settings.maxSizes);
    var canvas = document.createElement('canvas');
    canvas.width = size.width;
    canvas.height = size.height;
    var context = canvas.getContext('2d');

    // context.scale(size.width, size.height);
    context.fillStyle = context.strokeStyle = 'white';
    context.fillRect(0, 0, size.width, size.height);
    context.drawImage(srcCanvas, 0, 0, size.width, size.height);

    // STEP 4: Turn the canvas into a jpeg image for our Preview Image
    var binStr = atob(canvas.toDataURL('image/jpeg').split(',')[1]);
    var len = binStr.length;
    var arr = new Uint8Array(len);

    for (var i = 0; i < len; i++) {
      arr[i] = binStr.charCodeAt(i);
    }
    var blob = new Blob([arr], { type: 'image/jpeg' });

    // STEP 5: Create our Preview Message Part
    parts.push(new _layerWebsdk2.default.MessagePart({
      body: blob,
      mimeType: 'image/jpeg+preview'
    }));

    // STEP 6: Create the Metadata Message Part
    parts.push(new _layerWebsdk2.default.MessagePart({
      mimeType: 'application/json+imageSize',
      body: JSON.stringify({
        orientation: orientation,
        width: originalSize.width,
        height: originalSize.height,
        previewWidth: canvas.width,
        previewHeight: canvas.height
      })
    }));
    callback(parts);
  }
};

Files.generateVideoMessageParts = function generateVideoMessageParts(part, callback) {
  var parts = [part];
  var video = document.createElement('video');

  video.addEventListener('loadedmetadata', function () {
    var originalSize = {
      width: video.videoWidth,
      height: video.videoHeight
    };

    var size = (0, _sizing2.default)(originalSize, _base2.default.settings.maxSizes);

    var canvas = document.createElement('canvas');
    canvas.width = size.width;
    canvas.height = size.height;
    var context = canvas.getContext('2d');
    context.drawImage(video, 0, 0, canvas.width, canvas.height);

    var binStr = atob(canvas.toDataURL('image/jpeg').split(',')[1]);
    var len = binStr.length;
    var arr = new Uint8Array(len);

    for (var i = 0; i < len; i++) {
      arr[i] = binStr.charCodeAt(i);
    }

    parts.push(new _layerWebsdk2.default.MessagePart({
      body: new Blob([arr], { type: 'image/jpeg' }),
      mimeType: 'image/jpeg+preview'
    }));

    parts.push(new _layerWebsdk2.default.MessagePart({
      mimeType: 'application/json+imageSize',
      body: '{"orientation":0, "width":' + originalSize.width + ', "height":' + originalSize.height + '}'
    }));

    callback(parts);
  });

  video.src = URL.createObjectURL(part.body);
};
},{"../base":14,"./sizing":66,"blueimp-load-image/js/load-image":73,"blueimp-load-image/js/load-image-exif":69,"blueimp-load-image/js/load-image-meta":70,"blueimp-load-image/js/load-image-orientation":71,"layer-websdk":79}],65:[function(require,module,exports){
'use strict';

/*
 * isURL returns a Regular Expression that can be used to test if a string is a URL ending in any of the specified extensions.
 *
 * @class layerUI.utils.isURL
 * @singleton
 */

module.exports = function isURL(extensions) {
  var resource = '?';

  /* istanbul ignore else */
  if (extensions) resource = '.(' + extensions.join('|') + ')';

  // Taken from https://gist.github.com/dperini/729294
  return new RegExp(
  // protocol identifier
  '(?:(?:https?|ftp)://)' +
  // user:pass authentication
  '(?:\\S+(?::\\S*)?@)?' + '(?:' +
  // IP address exclusion
  // private & local networks
  '(?!(?:10|127)(?:\\.\\d{1,3}){3})' + '(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})' + '(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})' +
  // IP address dotted notation octets
  // excludes loopback network 0.0.0.0
  // excludes reserved space >= 224.0.0.0
  // excludes network & broacast addresses
  // (first & last IP address of each class)
  '(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])' + '(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}' + '(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))' + '|' +
  // host name
  '(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)' +
  // domain name
  '(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*' +
  // TLD identifier
  '(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))' +
  // TLD may end with dot
  '\\.?' + ')' +
  // port number
  '(?::\\d{2,5})?' +
  // resource path
  '(?:[/?#]\\S*)' + resource, 'igm');
};
},{}],66:[function(require,module,exports){
"use strict";

// NOTE: dimensions must contains width and height properties.
module.exports = function (dimensions, maxSizes) {

  if (!dimensions) return maxSizes;

  var size = {
    width: dimensions.previewWidth || dimensions.width,
    height: dimensions.previewHeight || dimensions.height
  };

  // Scale dimensions down to our maximum sizes if needed
  if (size.width > maxSizes.width) {
    var width = size.width;
    size.width = maxSizes.width;
    size.height = size.height * maxSizes.width / width;
  }
  if (size.height > maxSizes.height) {
    var height = size.height;
    size.height = maxSizes.height;
    size.width = size.width * maxSizes.height / height;
  }

  // Return scaled sizes
  return {
    width: Math.round(size.width),
    height: Math.round(size.height)
  };
};
},{}],67:[function(require,module,exports){
(function (window) {
    var requestAnimFrame = (function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function(callback){window.setTimeout(callback,1000/60);};})();

    var easeInOutQuad = function (t, b, c, d) {
        t /= d/2;
        if (t < 1) return c/2*t*t + b;
        t--;
        return -c/2 * (t*(t-2) - 1) + b;
    };

    var animatedScrollTo = function (element, to, duration, callback) {
        var start = element.scrollTop,
        change = to - start,
        animationStart = +new Date();
        var animating = true;
        var lastpos = null;

        var animateScroll = function() {
            if (!animating) {
                return;
            }
            requestAnimFrame(animateScroll);
            var now = +new Date();
            var val = Math.floor(easeInOutQuad(now - animationStart, start, change, duration));
            if (lastpos) {
                if (lastpos === element.scrollTop) {
                    lastpos = val;
                    element.scrollTop = val;
                } else {
                    animating = false;
                }
            } else {
                lastpos = val;
                element.scrollTop = val;
            }
            if (now > animationStart + duration) {
                element.scrollTop = to;
                animating = false;
                if (callback) { callback(); }
            }
        };
        requestAnimFrame(animateScroll);
        return function cancel() {
            animating = false;
        };
    };

    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = animatedScrollTo;
    } else {
        window.animatedScrollTo = animatedScrollTo;
    }
})(window);

},{}],68:[function(require,module,exports){
/*!
 * Autolinker.js
 * 1.4.2
 *
 * Copyright(c) 2017 Gregory Jacobs <greg@greg-jacobs.com>
 * MIT License
 *
 * https://github.com/gregjacobs/Autolinker.js
 */
;(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.Autolinker = factory();
  }
}(this, function() {
/**
 * @class Autolinker
 * @extends Object
 *
 * Utility class used to process a given string of text, and wrap the matches in
 * the appropriate anchor (&lt;a&gt;) tags to turn them into links.
 *
 * Any of the configuration options may be provided in an Object (map) provided
 * to the Autolinker constructor, which will configure how the {@link #link link()}
 * method will process the links.
 *
 * For example:
 *
 *     var autolinker = new Autolinker( {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *
 *     var html = autolinker.link( "Joe went to www.yahoo.com" );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 *
 *
 * The {@link #static-link static link()} method may also be used to inline
 * options into a single call, which may be more convenient for one-off uses.
 * For example:
 *
 *     var html = Autolinker.link( "Joe went to www.yahoo.com", {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 *
 *
 * ## Custom Replacements of Links
 *
 * If the configuration options do not provide enough flexibility, a {@link #replaceFn}
 * may be provided to fully customize the output of Autolinker. This function is
 * called once for each URL/Email/Phone#/Hashtag/Mention (Twitter, Instagram)
 * match that is encountered.
 *
 * For example:
 *
 *     var input = "...";  // string with URLs, Email Addresses, Phone #s, Hashtags, and Mentions (Twitter, Instagram)
 *
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *
 *             switch( match.getType() ) {
 *                 case 'url' :
 *                     console.log( "url: ", match.getUrl() );
 *
 *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {
 *                         var tag = match.buildTag();  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes
 *                         tag.setAttr( 'rel', 'nofollow' );
 *                         tag.addClass( 'external-link' );
 *
 *                         return tag;
 *
 *                     } else {
 *                         return true;  // let Autolinker perform its normal anchor tag replacement
 *                     }
 *
 *                 case 'email' :
 *                     var email = match.getEmail();
 *                     console.log( "email: ", email );
 *
 *                     if( email === "my@own.address" ) {
 *                         return false;  // don't auto-link this particular email address; leave as-is
 *                     } else {
 *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)
 *                     }
 *
 *                 case 'phone' :
 *                     var phoneNumber = match.getPhoneNumber();
 *                     console.log( phoneNumber );
 *
 *                     return '<a href="http://newplace.to.link.phone.numbers.to/">' + phoneNumber + '</a>';
 *
 *                 case 'hashtag' :
 *                     var hashtag = match.getHashtag();
 *                     console.log( hashtag );
 *
 *                     return '<a href="http://newplace.to.link.hashtag.handles.to/">' + hashtag + '</a>';
 *
 *                 case 'mention' :
 *                     var mention = match.getMention();
 *                     console.log( mention );
 *
 *                     return '<a href="http://newplace.to.link.mention.to/">' + mention + '</a>';
 *             }
 *         }
 *     } );
 *
 *
 * The function may return the following values:
 *
 * - `true` (Boolean): Allow Autolinker to replace the match as it normally
 *   would.
 * - `false` (Boolean): Do not replace the current match at all - leave as-is.
 * - Any String: If a string is returned from the function, the string will be
 *   used directly as the replacement HTML for the match.
 * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify
 *   an HTML tag before writing out its HTML text.
 *
 * @constructor
 * @param {Object} [cfg] The configuration options for the Autolinker instance,
 *   specified in an Object (map).
 */
var Autolinker = function( cfg ) {
	cfg = cfg || {};

	this.version = Autolinker.version;

	this.urls = this.normalizeUrlsCfg( cfg.urls );
	this.email = typeof cfg.email === 'boolean' ? cfg.email : true;
	this.phone = typeof cfg.phone === 'boolean' ? cfg.phone : true;
	this.hashtag = cfg.hashtag || false;
	this.mention = cfg.mention || false;
	this.newWindow = typeof cfg.newWindow === 'boolean' ? cfg.newWindow : true;
	this.stripPrefix = this.normalizeStripPrefixCfg( cfg.stripPrefix );
	this.stripTrailingSlash = typeof cfg.stripTrailingSlash === 'boolean' ? cfg.stripTrailingSlash : true;

	// Validate the value of the `mention` cfg
	var mention = this.mention;
	if( mention !== false && mention !== 'twitter' && mention !== 'instagram' ) {
		throw new Error( "invalid `mention` cfg - see docs" );
	}

	// Validate the value of the `hashtag` cfg
	var hashtag = this.hashtag;
	if( hashtag !== false && hashtag !== 'twitter' && hashtag !== 'facebook' && hashtag !== 'instagram' ) {
		throw new Error( "invalid `hashtag` cfg - see docs" );
	}

	this.truncate = this.normalizeTruncateCfg( cfg.truncate );
	this.className = cfg.className || '';
	this.replaceFn = cfg.replaceFn || null;
	this.context = cfg.context || this;

	this.htmlParser = null;
	this.matchers = null;
	this.tagBuilder = null;
};



/**
 * Automatically links URLs, Email addresses, Phone Numbers, Twitter handles,
 * Hashtags, and Mentions found in the given chunk of HTML. Does not link URLs
 * found within HTML tags.
 *
 * For instance, if given the text: `You should go to http://www.yahoo.com`,
 * then the result will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
 *
 * Example:
 *
 *     var linkedText = Autolinker.link( "Go to google.com", { newWindow: false } );
 *     // Produces: "Go to <a href="http://google.com">google.com</a>"
 *
 * @static
 * @param {String} textOrHtml The HTML or text to find matches within (depending
 *   on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #mention},
 *   {@link #hashtag}, and {@link #mention} options are enabled).
 * @param {Object} [options] Any of the configuration options for the Autolinker
 *   class, specified in an Object (map). See the class description for an
 *   example call.
 * @return {String} The HTML text, with matches automatically linked.
 */
Autolinker.link = function( textOrHtml, options ) {
	var autolinker = new Autolinker( options );
	return autolinker.link( textOrHtml );
};



/**
 * Parses the input `textOrHtml` looking for URLs, email addresses, phone
 * numbers, username handles, and hashtags (depending on the configuration
 * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}
 * objects describing those matches (without making any replacements).
 *
 * Note that if parsing multiple pieces of text, it is slightly more efficient
 * to create an Autolinker instance, and use the instance-level {@link #parse}
 * method.
 *
 * Example:
 *
 *     var matches = Autolinker.parse( "Hello google.com, I am asdf@asdf.com", {
 *         urls: true,
 *         email: true
 *     } );
 *
 *     console.log( matches.length );           // 2
 *     console.log( matches[ 0 ].getType() );   // 'url'
 *     console.log( matches[ 0 ].getUrl() );    // 'google.com'
 *     console.log( matches[ 1 ].getType() );   // 'email'
 *     console.log( matches[ 1 ].getEmail() );  // 'asdf@asdf.com'
 *
 * @static
 * @param {String} textOrHtml The HTML or text to find matches within
 *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},
 *   {@link #hashtag}, and {@link #mention} options are enabled).
 * @param {Object} [options] Any of the configuration options for the Autolinker
 *   class, specified in an Object (map). See the class description for an
 *   example call.
 * @return {Autolinker.match.Match[]} The array of Matches found in the
 *   given input `textOrHtml`.
 */
Autolinker.parse = function( textOrHtml, options ) {
	var autolinker = new Autolinker( options );
	return autolinker.parse( textOrHtml );
};


/**
 * @static
 * @property {String} version (readonly)
 *
 * The Autolinker version number in the form major.minor.patch
 *
 * Ex: 0.25.1
 */
Autolinker.version = '1.4.2';


Autolinker.prototype = {
	constructor : Autolinker,  // fix constructor property

	/**
	 * @cfg {Boolean/Object} [urls]
	 *
	 * `true` if URLs should be automatically linked, `false` if they should not
	 * be. Defaults to `true`.
	 *
	 * Examples:
	 *
	 *     urls: true
	 *
	 *     // or
	 *
	 *     urls: {
	 *         schemeMatches : true,
	 *         wwwMatches    : true,
	 *         tldMatches    : true
	 *     }
	 *
	 * As shown above, this option also accepts an Object form with 3 properties
	 * to allow for more customization of what exactly gets linked. All default
	 * to `true`:
	 *
	 * @cfg {Boolean} [urls.schemeMatches] `true` to match URLs found prefixed
	 *   with a scheme, i.e. `http://google.com`, or `other+scheme://google.com`,
	 *   `false` to prevent these types of matches.
	 * @cfg {Boolean} [urls.wwwMatches] `true` to match urls found prefixed with
	 *   `'www.'`, i.e. `www.google.com`. `false` to prevent these types of
	 *   matches. Note that if the URL had a prefixed scheme, and
	 *   `schemeMatches` is true, it will still be linked.
	 * @cfg {Boolean} [urls.tldMatches] `true` to match URLs with known top
	 *   level domains (.com, .net, etc.) that are not prefixed with a scheme or
	 *   `'www.'`. This option attempts to match anything that looks like a URL
	 *   in the given text. Ex: `google.com`, `asdf.org/?page=1`, etc. `false`
	 *   to prevent these types of matches.
	 */

	/**
	 * @cfg {Boolean} [email=true]
	 *
	 * `true` if email addresses should be automatically linked, `false` if they
	 * should not be.
	 */

	/**
	 * @cfg {Boolean} [phone=true]
	 *
	 * `true` if Phone numbers ("(555)555-5555") should be automatically linked,
	 * `false` if they should not be.
	 */

	/**
	 * @cfg {Boolean/String} [hashtag=false]
	 *
	 * A string for the service name to have hashtags (ex: "#myHashtag")
	 * auto-linked to. The currently-supported values are:
	 *
	 * - 'twitter'
	 * - 'facebook'
	 * - 'instagram'
	 *
	 * Pass `false` to skip auto-linking of hashtags.
	 */

	/**
	 * @cfg {String/Boolean} [mention=false]
	 *
	 * A string for the service name to have mentions (ex: "@myuser")
	 * auto-linked to. The currently supported values are:
	 *
	 * - 'twitter'
	 * - 'instagram'
	 *
	 * Defaults to `false` to skip auto-linking of mentions.
	 */

	/**
	 * @cfg {Boolean} [newWindow=true]
	 *
	 * `true` if the links should open in a new window, `false` otherwise.
	 */

	/**
	 * @cfg {Boolean/Object} [stripPrefix]
	 *
	 * `true` if 'http://' (or 'https://') and/or the 'www.' should be stripped
	 * from the beginning of URL links' text, `false` otherwise. Defaults to
	 * `true`.
	 *
	 * Examples:
	 *
	 *     stripPrefix: true
	 *
	 *     // or
	 *
	 *     stripPrefix: {
	 *         scheme : true,
	 *         www    : true
	 *     }
	 *
	 * As shown above, this option also accepts an Object form with 2 properties
	 * to allow for more customization of what exactly is prevented from being
	 * displayed. Both default to `true`:
	 *
	 * @cfg {Boolean} [stripPrefix.scheme] `true` to prevent the scheme part of
	 *   a URL match from being displayed to the user. Example:
	 *   `'http://google.com'` will be displayed as `'google.com'`. `false` to
	 *   not strip the scheme. NOTE: Only an `'http://'` or `'https://'` scheme
	 *   will be removed, so as not to remove a potentially dangerous scheme
	 *   (such as `'file://'` or `'javascript:'`)
	 * @cfg {Boolean} [stripPrefix.www] www (Boolean): `true` to prevent the
	 *   `'www.'` part of a URL match from being displayed to the user. Ex:
	 *   `'www.google.com'` will be displayed as `'google.com'`. `false` to not
	 *   strip the `'www'`.
	 */

	/**
	 * @cfg {Boolean} [stripTrailingSlash=true]
	 *
	 * `true` to remove the trailing slash from URL matches, `false` to keep
	 *  the trailing slash.
	 *
	 *  Example when `true`: `http://google.com/` will be displayed as
	 *  `http://google.com`.
	 */

	/**
	 * @cfg {Number/Object} [truncate=0]
	 *
	 * ## Number Form
	 *
	 * A number for how many characters matched text should be truncated to
	 * inside the text of a link. If the matched text is over this number of
	 * characters, it will be truncated to this length by adding a two period
	 * ellipsis ('..') to the end of the string.
	 *
	 * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file'
	 * truncated to 25 characters might look something like this:
	 * 'yahoo.com/some/long/pat..'
	 *
	 * Example Usage:
	 *
	 *     truncate: 25
	 *
	 *
	 *  Defaults to `0` for "no truncation."
	 *
	 *
	 * ## Object Form
	 *
	 * An Object may also be provided with two properties: `length` (Number) and
	 * `location` (String). `location` may be one of the following: 'end'
	 * (default), 'middle', or 'smart'.
	 *
	 * Example Usage:
	 *
	 *     truncate: { length: 25, location: 'middle' }
	 *
	 * @cfg {Number} [truncate.length=0] How many characters to allow before
	 *   truncation will occur. Defaults to `0` for "no truncation."
	 * @cfg {"end"/"middle"/"smart"} [truncate.location="end"]
	 *
	 * - 'end' (default): will truncate up to the number of characters, and then
	 *   add an ellipsis at the end. Ex: 'yahoo.com/some/long/pat..'
	 * - 'middle': will truncate and add the ellipsis in the middle. Ex:
	 *   'yahoo.com/s..th/to/a/file'
	 * - 'smart': for URLs where the algorithm attempts to strip out unnecessary
	 *   parts first (such as the 'www.', then URL scheme, hash, etc.),
	 *   attempting to make the URL human-readable before looking for a good
	 *   point to insert the ellipsis if it is still too long. Ex:
	 *   'yahoo.com/some..to/a/file'. For more details, see
	 *   {@link Autolinker.truncate.TruncateSmart}.
	 */

	/**
	 * @cfg {String} className
	 *
	 * A CSS class name to add to the generated links. This class will be added
	 * to all links, as well as this class plus match suffixes for styling
	 * url/email/phone/hashtag/mention links differently.
	 *
	 * For example, if this config is provided as "myLink", then:
	 *
	 * - URL links will have the CSS classes: "myLink myLink-url"
	 * - Email links will have the CSS classes: "myLink myLink-email", and
	 * - Phone links will have the CSS classes: "myLink myLink-phone"
	 * - Hashtag links will have the CSS classes: "myLink myLink-hashtag"
	 * - Mention links will have the CSS classes: "myLink myLink-mention myLink-[type]"
	 *   where [type] is either "instagram" or "twitter"
	 */

	/**
	 * @cfg {Function} replaceFn
	 *
	 * A function to individually process each match found in the input string.
	 *
	 * See the class's description for usage.
	 *
	 * The `replaceFn` can be called with a different context object (`this`
	 * reference) using the {@link #context} cfg.
	 *
	 * This function is called with the following parameter:
	 *
	 * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which
	 *   can be used to retrieve information about the match that the `replaceFn`
	 *   is currently processing. See {@link Autolinker.match.Match} subclasses
	 *   for details.
	 */

	/**
	 * @cfg {Object} context
	 *
	 * The context object (`this` reference) to call the `replaceFn` with.
	 *
	 * Defaults to this Autolinker instance.
	 */


	/**
	 * @property {String} version (readonly)
	 *
	 * The Autolinker version number in the form major.minor.patch
	 *
	 * Ex: 0.25.1
	 */

	/**
	 * @private
	 * @property {Autolinker.htmlParser.HtmlParser} htmlParser
	 *
	 * The HtmlParser instance used to skip over HTML tags, while finding text
	 * nodes to process. This is lazily instantiated in the {@link #getHtmlParser}
	 * method.
	 */

	/**
	 * @private
	 * @property {Autolinker.matcher.Matcher[]} matchers
	 *
	 * The {@link Autolinker.matcher.Matcher} instances for this Autolinker
	 * instance.
	 *
	 * This is lazily created in {@link #getMatchers}.
	 */

	/**
	 * @private
	 * @property {Autolinker.AnchorTagBuilder} tagBuilder
	 *
	 * The AnchorTagBuilder instance used to build match replacement anchor tags.
	 * Note: this is lazily instantiated in the {@link #getTagBuilder} method.
	 */


	/**
	 * Normalizes the {@link #urls} config into an Object with 3 properties:
	 * `schemeMatches`, `wwwMatches`, and `tldMatches`, all Booleans.
	 *
	 * See {@link #urls} config for details.
	 *
	 * @private
	 * @param {Boolean/Object} urls
	 * @return {Object}
	 */
	normalizeUrlsCfg : function( urls ) {
		if( urls == null ) urls = true;  // default to `true`

		if( typeof urls === 'boolean' ) {
			return { schemeMatches: urls, wwwMatches: urls, tldMatches: urls };

		} else {  // object form
			return {
				schemeMatches : typeof urls.schemeMatches === 'boolean' ? urls.schemeMatches : true,
				wwwMatches    : typeof urls.wwwMatches === 'boolean'    ? urls.wwwMatches    : true,
				tldMatches    : typeof urls.tldMatches === 'boolean'    ? urls.tldMatches    : true
			};
		}
	},


	/**
	 * Normalizes the {@link #stripPrefix} config into an Object with 2
	 * properties: `scheme`, and `www` - both Booleans.
	 *
	 * See {@link #stripPrefix} config for details.
	 *
	 * @private
	 * @param {Boolean/Object} stripPrefix
	 * @return {Object}
	 */
	normalizeStripPrefixCfg : function( stripPrefix ) {
		if( stripPrefix == null ) stripPrefix = true;  // default to `true`

		if( typeof stripPrefix === 'boolean' ) {
			return { scheme: stripPrefix, www: stripPrefix };

		} else {  // object form
			return {
				scheme : typeof stripPrefix.scheme === 'boolean' ? stripPrefix.scheme : true,
				www    : typeof stripPrefix.www === 'boolean'    ? stripPrefix.www    : true
			};
		}
	},


	/**
	 * Normalizes the {@link #truncate} config into an Object with 2 properties:
	 * `length` (Number), and `location` (String).
	 *
	 * See {@link #truncate} config for details.
	 *
	 * @private
	 * @param {Number/Object} truncate
	 * @return {Object}
	 */
	normalizeTruncateCfg : function( truncate ) {
		if( typeof truncate === 'number' ) {
			return { length: truncate, location: 'end' };

		} else {  // object, or undefined/null
			return Autolinker.Util.defaults( truncate || {}, {
				length   : Number.POSITIVE_INFINITY,
				location : 'end'
			} );
		}
	},


	/**
	 * Parses the input `textOrHtml` looking for URLs, email addresses, phone
	 * numbers, username handles, and hashtags (depending on the configuration
	 * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}
	 * objects describing those matches (without making any replacements).
	 *
	 * This method is used by the {@link #link} method, but can also be used to
	 * simply do parsing of the input in order to discover what kinds of links
	 * there are and how many.
	 *
	 * Example usage:
	 *
	 *     var autolinker = new Autolinker( {
	 *         urls: true,
	 *         email: true
	 *     } );
	 *
	 *     var matches = autolinker.parse( "Hello google.com, I am asdf@asdf.com" );
	 *
	 *     console.log( matches.length );           // 2
	 *     console.log( matches[ 0 ].getType() );   // 'url'
	 *     console.log( matches[ 0 ].getUrl() );    // 'google.com'
	 *     console.log( matches[ 1 ].getType() );   // 'email'
	 *     console.log( matches[ 1 ].getEmail() );  // 'asdf@asdf.com'
	 *
	 * @param {String} textOrHtml The HTML or text to find matches within
	 *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},
	 *   {@link #hashtag}, and {@link #mention} options are enabled).
	 * @return {Autolinker.match.Match[]} The array of Matches found in the
	 *   given input `textOrHtml`.
	 */
	parse : function( textOrHtml ) {
		var htmlParser = this.getHtmlParser(),
		    htmlNodes = htmlParser.parse( textOrHtml ),
		    anchorTagStackCount = 0,  // used to only process text around anchor tags, and any inner text/html they may have;
		    matches = [];

		// Find all matches within the `textOrHtml` (but not matches that are
		// already nested within <a> tags)
		for( var i = 0, len = htmlNodes.length; i < len; i++ ) {
			var node = htmlNodes[ i ],
			    nodeType = node.getType();

			if( nodeType === 'element' && node.getTagName() === 'a' ) {  // Process HTML anchor element nodes in the input `textOrHtml` to find out when we're within an <a> tag
				if( !node.isClosing() ) {  // it's the start <a> tag
					anchorTagStackCount++;
				} else {  // it's the end </a> tag
					anchorTagStackCount = Math.max( anchorTagStackCount - 1, 0 );  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0
				}

			} else if( nodeType === 'text' && anchorTagStackCount === 0 ) {  // Process text nodes that are not within an <a> tag
				var textNodeMatches = this.parseText( node.getText(), node.getOffset() );

				matches.push.apply( matches, textNodeMatches );
			}
		}


		// After we have found all matches, remove subsequent matches that
		// overlap with a previous match. This can happen for instance with URLs,
		// where the url 'google.com/#link' would match '#link' as a hashtag.
		matches = this.compactMatches( matches );

		// And finally, remove matches for match types that have been turned
		// off. We needed to have all match types turned on initially so that
		// things like hashtags could be filtered out if they were really just
		// part of a URL match (for instance, as a named anchor).
		matches = this.removeUnwantedMatches( matches );

		return matches;
	},


	/**
	 * After we have found all matches, we need to remove subsequent matches
	 * that overlap with a previous match. This can happen for instance with
	 * URLs, where the url 'google.com/#link' would match '#link' as a hashtag.
	 *
	 * @private
	 * @param {Autolinker.match.Match[]} matches
	 * @return {Autolinker.match.Match[]}
	 */
	compactMatches : function( matches ) {
		// First, the matches need to be sorted in order of offset
		matches.sort( function( a, b ) { return a.getOffset() - b.getOffset(); } );

		for( var i = 0; i < matches.length - 1; i++ ) {
			var match = matches[ i ],
			    endIdx = match.getOffset() + match.getMatchedText().length;

			// Remove subsequent matches that overlap with the current match
			while( i + 1 < matches.length && matches[ i + 1 ].getOffset() <= endIdx ) {
				matches.splice( i + 1, 1 );
			}
		}

		return matches;
	},


	/**
	 * Removes matches for matchers that were turned off in the options. For
	 * example, if {@link #hashtag hashtags} were not to be matched, we'll
	 * remove them from the `matches` array here.
	 *
	 * @private
	 * @param {Autolinker.match.Match[]} matches The array of matches to remove
	 *   the unwanted matches from. Note: this array is mutated for the
	 *   removals.
	 * @return {Autolinker.match.Match[]} The mutated input `matches` array.
	 */
	removeUnwantedMatches : function( matches ) {
		var remove = Autolinker.Util.remove;

		if( !this.hashtag ) remove( matches, function( match ) { return match.getType() === 'hashtag'; } );
		if( !this.email )   remove( matches, function( match ) { return match.getType() === 'email'; } );
		if( !this.phone )   remove( matches, function( match ) { return match.getType() === 'phone'; } );
		if( !this.mention ) remove( matches, function( match ) { return match.getType() === 'mention'; } );
		if( !this.urls.schemeMatches ) {
			remove( matches, function( m ) { return m.getType() === 'url' && m.getUrlMatchType() === 'scheme'; } );
		}
		if( !this.urls.wwwMatches ) {
			remove( matches, function( m ) { return m.getType() === 'url' && m.getUrlMatchType() === 'www'; } );
		}
		if( !this.urls.tldMatches ) {
			remove( matches, function( m ) { return m.getType() === 'url' && m.getUrlMatchType() === 'tld'; } );
		}

		return matches;
	},


	/**
	 * Parses the input `text` looking for URLs, email addresses, phone
	 * numbers, username handles, and hashtags (depending on the configuration
	 * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}
	 * objects describing those matches.
	 *
	 * This method processes a **non-HTML string**, and is used to parse and
	 * match within the text nodes of an HTML string. This method is used
	 * internally by {@link #parse}.
	 *
	 * @private
	 * @param {String} text The text to find matches within (depending on if the
	 *   {@link #urls}, {@link #email}, {@link #phone},
	 *   {@link #hashtag}, and {@link #mention} options are enabled). This must be a non-HTML string.
	 * @param {Number} [offset=0] The offset of the text node within the
	 *   original string. This is used when parsing with the {@link #parse}
	 *   method to generate correct offsets within the {@link Autolinker.match.Match}
	 *   instances, but may be omitted if calling this method publicly.
	 * @return {Autolinker.match.Match[]} The array of Matches found in the
	 *   given input `text`.
	 */
	parseText : function( text, offset ) {
		offset = offset || 0;
		var matchers = this.getMatchers(),
		    matches = [];

		for( var i = 0, numMatchers = matchers.length; i < numMatchers; i++ ) {
			var textMatches = matchers[ i ].parseMatches( text );

			// Correct the offset of each of the matches. They are originally
			// the offset of the match within the provided text node, but we
			// need to correct them to be relative to the original HTML input
			// string (i.e. the one provided to #parse).
			for( var j = 0, numTextMatches = textMatches.length; j < numTextMatches; j++ ) {
				textMatches[ j ].setOffset( offset + textMatches[ j ].getOffset() );
			}

			matches.push.apply( matches, textMatches );
		}
		return matches;
	},


	/**
	 * Automatically links URLs, Email addresses, Phone numbers, Hashtags,
	 * and Mentions (Twitter, Instagram) found in the given chunk of HTML. Does not link
	 * URLs found within HTML tags.
	 *
	 * For instance, if given the text: `You should go to http://www.yahoo.com`,
	 * then the result will be `You should go to
	 * &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
	 *
	 * This method finds the text around any HTML elements in the input
	 * `textOrHtml`, which will be the text that is processed. Any original HTML
	 * elements will be left as-is, as well as the text that is already wrapped
	 * in anchor (&lt;a&gt;) tags.
	 *
	 * @param {String} textOrHtml The HTML or text to autolink matches within
	 *   (depending on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #hashtag}, and {@link #mention} options are enabled).
	 * @return {String} The HTML, with matches automatically linked.
	 */
	link : function( textOrHtml ) {
		if( !textOrHtml ) { return ""; }  // handle `null` and `undefined`

		var matches = this.parse( textOrHtml ),
			newHtml = [],
			lastIndex = 0;

		for( var i = 0, len = matches.length; i < len; i++ ) {
			var match = matches[ i ];

			newHtml.push( textOrHtml.substring( lastIndex, match.getOffset() ) );
			newHtml.push( this.createMatchReturnVal( match ) );

			lastIndex = match.getOffset() + match.getMatchedText().length;
		}
		newHtml.push( textOrHtml.substring( lastIndex ) );  // handle the text after the last match

		return newHtml.join( '' );
	},


	/**
	 * Creates the return string value for a given match in the input string.
	 *
	 * This method handles the {@link #replaceFn}, if one was provided.
	 *
	 * @private
	 * @param {Autolinker.match.Match} match The Match object that represents
	 *   the match.
	 * @return {String} The string that the `match` should be replaced with.
	 *   This is usually the anchor tag string, but may be the `matchStr` itself
	 *   if the match is not to be replaced.
	 */
	createMatchReturnVal : function( match ) {
		// Handle a custom `replaceFn` being provided
		var replaceFnResult;
		if( this.replaceFn ) {
			replaceFnResult = this.replaceFn.call( this.context, match );  // Autolinker instance is the context
		}

		if( typeof replaceFnResult === 'string' ) {
			return replaceFnResult;  // `replaceFn` returned a string, use that

		} else if( replaceFnResult === false ) {
			return match.getMatchedText();  // no replacement for the match

		} else if( replaceFnResult instanceof Autolinker.HtmlTag ) {
			return replaceFnResult.toAnchorString();

		} else {  // replaceFnResult === true, or no/unknown return value from function
			// Perform Autolinker's default anchor tag generation
			var anchorTag = match.buildTag();  // returns an Autolinker.HtmlTag instance

			return anchorTag.toAnchorString();
		}
	},


	/**
	 * Lazily instantiates and returns the {@link #htmlParser} instance for this
	 * Autolinker instance.
	 *
	 * @protected
	 * @return {Autolinker.htmlParser.HtmlParser}
	 */
	getHtmlParser : function() {
		var htmlParser = this.htmlParser;

		if( !htmlParser ) {
			htmlParser = this.htmlParser = new Autolinker.htmlParser.HtmlParser();
		}

		return htmlParser;
	},


	/**
	 * Lazily instantiates and returns the {@link Autolinker.matcher.Matcher}
	 * instances for this Autolinker instance.
	 *
	 * @protected
	 * @return {Autolinker.matcher.Matcher[]}
	 */
	getMatchers : function() {
		if( !this.matchers ) {
			var matchersNs = Autolinker.matcher,
			    tagBuilder = this.getTagBuilder();

			var matchers = [
				new matchersNs.Hashtag( { tagBuilder: tagBuilder, serviceName: this.hashtag } ),
				new matchersNs.Email( { tagBuilder: tagBuilder } ),
				new matchersNs.Phone( { tagBuilder: tagBuilder } ),
				new matchersNs.Mention( { tagBuilder: tagBuilder, serviceName: this.mention } ),
				new matchersNs.Url( { tagBuilder: tagBuilder, stripPrefix: this.stripPrefix, stripTrailingSlash: this.stripTrailingSlash } )
			];

			return ( this.matchers = matchers );

		} else {
			return this.matchers;
		}
	},


	/**
	 * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it
	 * if it does not yet exist.
	 *
	 * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that
	 * Autolinker would normally generate, and then allow for modifications before returning it. For example:
	 *
	 *     var html = Autolinker.link( "Test google.com", {
	 *         replaceFn : function( match ) {
	 *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance
	 *             tag.setAttr( 'rel', 'nofollow' );
	 *
	 *             return tag;
	 *         }
	 *     } );
	 *
	 *     // generated html:
	 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
	 *
	 * @return {Autolinker.AnchorTagBuilder}
	 */
	getTagBuilder : function() {
		var tagBuilder = this.tagBuilder;

		if( !tagBuilder ) {
			tagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder( {
				newWindow   : this.newWindow,
				truncate    : this.truncate,
				className   : this.className
			} );
		}

		return tagBuilder;
	}

};


// Autolinker Namespaces

Autolinker.match = {};
Autolinker.matcher = {};
Autolinker.htmlParser = {};
Autolinker.truncate = {};

/*global Autolinker */
/*jshint eqnull:true, boss:true */
/**
 * @class Autolinker.Util
 * @singleton
 *
 * A few utility methods for Autolinker.
 */
Autolinker.Util = {

	/**
	 * @property {Function} abstractMethod
	 *
	 * A function object which represents an abstract method.
	 */
	abstractMethod : function() { throw "abstract"; },


	/**
	 * @private
	 * @property {RegExp} trimRegex
	 *
	 * The regular expression used to trim the leading and trailing whitespace
	 * from a string.
	 */
	trimRegex : /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	/**
	 * Assigns (shallow copies) the properties of `src` onto `dest`.
	 *
	 * @param {Object} dest The destination object.
	 * @param {Object} src The source object.
	 * @return {Object} The destination object (`dest`)
	 */
	assign : function( dest, src ) {
		for( var prop in src ) {
			if( src.hasOwnProperty( prop ) ) {
				dest[ prop ] = src[ prop ];
			}
		}

		return dest;
	},


	/**
	 * Assigns (shallow copies) the properties of `src` onto `dest`, if the
	 * corresponding property on `dest` === `undefined`.
	 *
	 * @param {Object} dest The destination object.
	 * @param {Object} src The source object.
	 * @return {Object} The destination object (`dest`)
	 */
	defaults : function( dest, src ) {
		for( var prop in src ) {
			if( src.hasOwnProperty( prop ) && dest[ prop ] === undefined ) {
				dest[ prop ] = src[ prop ];
			}
		}

		return dest;
	},


	/**
	 * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.
	 *
	 * @param {Function} superclass The constructor function for the superclass.
	 * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the
	 *   special property `constructor`, which will be used as the new subclass's constructor function.
	 * @return {Function} The new subclass function.
	 */
	extend : function( superclass, protoProps ) {
		var superclassProto = superclass.prototype;

		var F = function() {};
		F.prototype = superclassProto;

		var subclass;
		if( protoProps.hasOwnProperty( 'constructor' ) ) {
			subclass = protoProps.constructor;
		} else {
			subclass = function() { superclassProto.constructor.apply( this, arguments ); };
		}

		var subclassProto = subclass.prototype = new F();  // set up prototype chain
		subclassProto.constructor = subclass;  // fix constructor property
		subclassProto.superclass = superclassProto;

		delete protoProps.constructor;  // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there
		Autolinker.Util.assign( subclassProto, protoProps );

		return subclass;
	},


	/**
	 * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the
	 * end of the string (by default, two periods: '..'). If the `str` length does not exceed
	 * `len`, the string will be returned unchanged.
	 *
	 * @param {String} str The string to truncate and add an ellipsis to.
	 * @param {Number} truncateLen The length to truncate the string at.
	 * @param {String} [ellipsisChars=...] The ellipsis character(s) to add to the end of `str`
	 *   when truncated. Defaults to '...'
	 */
	ellipsis : function( str, truncateLen, ellipsisChars ) {
		var ellipsisLength;

		if( str.length > truncateLen ) {
			if(ellipsisChars == null) {
			  ellipsisChars = '&hellip;';
			  ellipsisLength = 3;
			} else {
			  ellipsisLength = ellipsisChars.length;
			}

			str = str.substring( 0, truncateLen - ellipsisLength ) + ellipsisChars;
		}
		return str;
	},


	/**
	 * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).
	 *
	 * @param {Array} arr The array to find an element of.
	 * @param {*} element The element to find in the array, and return the index of.
	 * @return {Number} The index of the `element`, or -1 if it was not found.
	 */
	indexOf : function( arr, element ) {
		if( Array.prototype.indexOf ) {
			return arr.indexOf( element );

		} else {
			for( var i = 0, len = arr.length; i < len; i++ ) {
				if( arr[ i ] === element ) return i;
			}
			return -1;
		}
	},


	/**
	 * Removes array elements based on a filtering function. Mutates the input
	 * array.
	 *
	 * Using this instead of the ES5 Array.prototype.filter() function, to allow
	 * Autolinker compatibility with IE8, and also to prevent creating many new
	 * arrays in memory for filtering.
	 *
	 * @param {Array} arr The array to remove elements from. This array is
	 *   mutated.
	 * @param {Function} fn A function which should return `true` to
	 *   remove an element.
	 * @return {Array} The mutated input `arr`.
	 */
	remove : function( arr, fn ) {
		for( var i = arr.length - 1; i >= 0; i-- ) {
			if( fn( arr[ i ] ) === true ) {
				arr.splice( i, 1 );
			}
		}
	},


	/**
	 * Performs the functionality of what modern browsers do when `String.prototype.split()` is called
	 * with a regular expression that contains capturing parenthesis.
	 *
	 * For example:
	 *
	 *     // Modern browsers:
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]
	 *
	 *     // Old IE (including IE8):
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]
	 *
	 * This method emulates the functionality of modern browsers for the old IE case.
	 *
	 * @param {String} str The string to split.
	 * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting
	 *   character(s) will be spliced into the array, as in the "modern browsers" example in the
	 *   description of this method.
	 *   Note #1: the supplied regular expression **must** have the 'g' flag specified.
	 *   Note #2: for simplicity's sake, the regular expression does not need
	 *   to contain capturing parenthesis - it will be assumed that any match has them.
	 * @return {String[]} The split array of strings, with the splitting character(s) included.
	 */
	splitAndCapture : function( str, splitRegex ) {
		if( !splitRegex.global ) throw new Error( "`splitRegex` must have the 'g' flag set" );

		var result = [],
		    lastIdx = 0,
		    match;

		while( match = splitRegex.exec( str ) ) {
			result.push( str.substring( lastIdx, match.index ) );
			result.push( match[ 0 ] );  // push the splitting char(s)

			lastIdx = match.index + match[ 0 ].length;
		}
		result.push( str.substring( lastIdx ) );

		return result;
	},


	/**
	 * Trims the leading and trailing whitespace from a string.
	 *
	 * @param {String} str The string to trim.
	 * @return {String}
	 */
	trim : function( str ) {
		return str.replace( this.trimRegex, '' );
	}

};

/*global Autolinker */
/*jshint boss:true */
/**
 * @class Autolinker.HtmlTag
 * @extends Object
 *
 * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.
 *
 * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use
 * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.
 *
 * ## Examples
 *
 * Example instantiation:
 *
 *     var tag = new Autolinker.HtmlTag( {
 *         tagName : 'a',
 *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },
 *         innerHtml : 'Google'
 *     } );
 *
 *     tag.toAnchorString();  // <a href="http://google.com" class="external-link">Google</a>
 *
 *     // Individual accessor methods
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 *
 *
 * Using mutator methods (which may be used in combination with instantiation config properties):
 *
 *     var tag = new Autolinker.HtmlTag();
 *     tag.setTagName( 'a' );
 *     tag.setAttr( 'href', 'http://google.com' );
 *     tag.addClass( 'external-link' );
 *     tag.setInnerHtml( 'Google' );
 *
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 *
 *     tag.toAnchorString();  // <a href="http://google.com" class="external-link">Google</a>
 *
 *
 * ## Example use within a {@link Autolinker#replaceFn replaceFn}
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( match ) {
 *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text
 *             tag.setAttr( 'rel', 'nofollow' );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 *
 *
 * ## Example use with a new tag for the replacement
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( match ) {
 *             var tag = new Autolinker.HtmlTag( {
 *                 tagName : 'button',
 *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },
 *                 innerHtml : 'Load URL: ' + match.getAnchorText()
 *             } );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <button title="Load URL: http://google.com">Load URL: google.com</button>
 */
Autolinker.HtmlTag = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {String} tagName
	 *
	 * The tag name. Ex: 'a', 'button', etc.
	 *
	 * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toAnchorString}
	 * is executed.
	 */

	/**
	 * @cfg {Object.<String, String>} attrs
	 *
	 * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the
	 * values are the attribute values.
	 */

	/**
	 * @cfg {String} innerHtml
	 *
	 * The inner HTML for the tag.
	 *
	 * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym
	 * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}
	 * if you prefer, but this one is recommended.
	 */

	/**
	 * @cfg {String} innerHTML
	 *
	 * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version
	 * for acronym names.
	 */


	/**
	 * @protected
	 * @property {RegExp} whitespaceRegex
	 *
	 * Regular expression used to match whitespace in a string of CSS classes.
	 */
	whitespaceRegex : /\s+/,


	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration properties for this class, in an Object (map)
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );

		this.innerHtml = this.innerHtml || this.innerHTML;  // accept either the camelCased form or the fully capitalized acronym
	},


	/**
	 * Sets the tag name that will be used to generate the tag with.
	 *
	 * @param {String} tagName
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setTagName : function( tagName ) {
		this.tagName = tagName;
		return this;
	},


	/**
	 * Retrieves the tag name.
	 *
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName || "";
	},


	/**
	 * Sets an attribute on the HtmlTag.
	 *
	 * @param {String} attrName The attribute name to set.
	 * @param {String} attrValue The attribute value to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttr : function( attrName, attrValue ) {
		var tagAttrs = this.getAttrs();
		tagAttrs[ attrName ] = attrValue;

		return this;
	},


	/**
	 * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.
	 *
	 * @param {String} attrName The attribute name to retrieve.
	 * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.
	 */
	getAttr : function( attrName ) {
		return this.getAttrs()[ attrName ];
	},


	/**
	 * Sets one or more attributes on the HtmlTag.
	 *
	 * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttrs : function( attrs ) {
		var tagAttrs = this.getAttrs();
		Autolinker.Util.assign( tagAttrs, attrs );

		return this;
	},


	/**
	 * Retrieves the attributes Object (map) for the HtmlTag.
	 *
	 * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.
	 */
	getAttrs : function() {
		return this.attrs || ( this.attrs = {} );
	},


	/**
	 * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setClass : function( cssClass ) {
		return this.setAttr( 'class', cssClass );
	},


	/**
	 * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to add.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	addClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    newClasses = cssClass.split( whitespaceRegex ),
		    newClass;

		while( newClass = newClasses.shift() ) {
			if( indexOf( classes, newClass ) === -1 ) {
				classes.push( newClass );
			}
		}

		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},


	/**
	 * Convenience method to remove one or more CSS classes from the HtmlTag.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to remove.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	removeClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    removeClasses = cssClass.split( whitespaceRegex ),
		    removeClass;

		while( classes.length && ( removeClass = removeClasses.shift() ) ) {
			var idx = indexOf( classes, removeClass );
			if( idx !== -1 ) {
				classes.splice( idx, 1 );
			}
		}

		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},


	/**
	 * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when
	 * there are multiple.
	 *
	 * @return {String}
	 */
	getClass : function() {
		return this.getAttrs()[ 'class' ] || "";
	},


	/**
	 * Convenience method to check if the tag has a CSS class or not.
	 *
	 * @param {String} cssClass The CSS class to check for.
	 * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.
	 */
	hasClass : function( cssClass ) {
		return ( ' ' + this.getClass() + ' ' ).indexOf( ' ' + cssClass + ' ' ) !== -1;
	},


	/**
	 * Sets the inner HTML for the tag.
	 *
	 * @param {String} html The inner HTML to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setInnerHtml : function( html ) {
		this.innerHtml = html;

		return this;
	},


	/**
	 * Retrieves the inner HTML for the tag.
	 *
	 * @return {String}
	 */
	getInnerHtml : function() {
		return this.innerHtml || "";
	},


	/**
	 * Override of superclass method used to generate the HTML string for the tag.
	 *
	 * @return {String}
	 */
	toAnchorString : function() {
		var tagName = this.getTagName(),
		    attrsStr = this.buildAttrsStr();

		attrsStr = ( attrsStr ) ? ' ' + attrsStr : '';  // prepend a space if there are actually attributes

		return [ '<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>' ].join( "" );
	},


	/**
	 * Support method for {@link #toAnchorString}, returns the string space-separated key="value" pairs, used to populate
	 * the stringified HtmlTag.
	 *
	 * @protected
	 * @return {String} Example return: `attr1="value1" attr2="value2"`
	 */
	buildAttrsStr : function() {
		if( !this.attrs ) return "";  // no `attrs` Object (map) has been set, return empty string

		var attrs = this.getAttrs(),
		    attrsArr = [];

		for( var prop in attrs ) {
			if( attrs.hasOwnProperty( prop ) ) {
				attrsArr.push( prop + '="' + attrs[ prop ] + '"' );
			}
		}
		return attrsArr.join( " " );
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.RegexLib
 * @singleton
 *
 * Builds and stores a library of the common regular expressions used by the
 * Autolinker utility.
 *
 * Other regular expressions may exist ad-hoc, but these are generally the
 * regular expressions that are shared between source files.
 */
Autolinker.RegexLib = (function() {

	/**
	 * The string form of a regular expression that would match all of the
	 * alphabetic ("letter") chars in the unicode character set when placed in a
	 * RegExp character class (`[]`). This includes all international alphabetic
	 * characters.
	 *
	 * These would be the characters matched by unicode regex engines `\p{L}`
	 * escape ("all letters").
	 *
	 * Taken from the XRegExp library: http://xregexp.com/
	 * Specifically: http://xregexp.com/v/3.0.0/unicode-categories.js
	 *
	 * @private
	 * @type {String}
	 */
	var alphaCharsStr = 'A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC';

	/**
	 * The string form of a regular expression that would match all of the
	 * decimal number chars in the unicode character set when placed in a RegExp
	 * character class (`[]`).
	 *
	 * These would be the characters matched by unicode regex engines `\p{Nd}`
	 * escape ("all decimal numbers")
	 *
	 * Taken from the XRegExp library: http://xregexp.com/
	 * Specifically: http://xregexp.com/v/3.0.0/unicode-categories.js
	 *
	 * @private
	 * @type {String}
	 */
	var decimalNumbersStr = '0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19';


	// See documentation below
	var alphaNumericCharsStr = alphaCharsStr + decimalNumbersStr;


	// See documentation below
	var domainNameRegex = new RegExp( '[' + alphaNumericCharsStr + '.\\-]*[' + alphaNumericCharsStr + '\\-]' );

	return {

		/**
		 * The string form of a regular expression that would match all of the
		 * letters and decimal number chars in the unicode character set when placed
		 * in a RegExp character class (`[]`).
		 *
		 * These would be the characters matched by unicode regex engines `[\p{L}\p{Nd}]`
		 * escape ("all letters and decimal numbers")
		 *
		 * @property {String} alphaNumericCharsStr
		 */
		alphaNumericCharsStr : alphaNumericCharsStr,

		/**
		 * The string form of a regular expression that would match all of the
		 * letters and in the unicode character set when placed
		 * in a RegExp character class (`[]`).
		 *
		 * These would be the characters matched by unicode regex engines `[\p{L}]`
		 * escape ("all letters")
		 *
		 * @property {String} alphaCharsStr
		 */
		alphaCharsStr : alphaCharsStr,

		/**
		 * A regular expression to match domain names of a URL or email address.
		 * Ex: 'google', 'yahoo', 'some-other-company', etc.
		 *
		 * @property {RegExp} domainNameRegex
		 */
		domainNameRegex : domainNameRegex,

	};


}() );

/*global Autolinker */
/*jshint sub:true */
/**
 * @protected
 * @class Autolinker.AnchorTagBuilder
 * @extends Object
 *
 * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is
 * found.
 *
 * Normally this class is instantiated, configured, and used internally by an
 * {@link Autolinker} instance, but may actually be used indirectly in a
 * {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag}
 * instances which may be modified before returning from the
 * {@link Autolinker#replaceFn replaceFn}. For example:
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( match ) {
 *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance
 *             tag.setAttr( 'rel', 'nofollow' );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 */
Autolinker.AnchorTagBuilder = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Boolean} newWindow
	 * @inheritdoc Autolinker#newWindow
	 */

	/**
	 * @cfg {Object} truncate
	 * @inheritdoc Autolinker#truncate
	 */

	/**
	 * @cfg {String} className
	 * @inheritdoc Autolinker#className
	 */


	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		cfg = cfg || {};

		this.newWindow = cfg.newWindow;
		this.truncate = cfg.truncate;
		this.className = cfg.className;
	},


	/**
	 * Generates the actual anchor (&lt;a&gt;) tag to use in place of the
	 * matched text, via its `match` object.
	 *
	 * @param {Autolinker.match.Match} match The Match instance to generate an
	 *   anchor tag from.
	 * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.
	 */
	build : function( match ) {
		return new Autolinker.HtmlTag( {
			tagName   : 'a',
			attrs     : this.createAttrs( match ),
			innerHtml : this.processAnchorText( match.getAnchorText() )
		} );
	},


	/**
	 * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;)
	 *   tag being generated.
	 *
	 * @protected
	 * @param {Autolinker.match.Match} match The Match instance to generate an
	 *   anchor tag from.
	 * @return {Object} A key/value Object (map) of the anchor tag's attributes.
	 */
	createAttrs : function( match ) {
		var attrs = {
			'href' : match.getAnchorHref()  // we'll always have the `href` attribute
		};

		var cssClass = this.createCssClass( match );
		if( cssClass ) {
			attrs[ 'class' ] = cssClass;
		}
		if( this.newWindow ) {
			attrs[ 'target' ] = "_blank";
			attrs[ 'rel' ] = "noopener noreferrer";
		}

		if( this.truncate ) {
			if( this.truncate.length && this.truncate.length < match.getAnchorText().length ) {
				attrs[ 'title' ] = match.getAnchorHref();
			}
		}

		return attrs;
	},


	/**
	 * Creates the CSS class that will be used for a given anchor tag, based on
	 * the `matchType` and the {@link #className} config.
	 *
	 * Example returns:
	 *
	 * - ""                                      // no {@link #className}
	 * - "myLink myLink-url"                     // url match
	 * - "myLink myLink-email"                   // email match
	 * - "myLink myLink-phone"                   // phone match
	 * - "myLink myLink-hashtag"                 // hashtag match
	 * - "myLink myLink-mention myLink-twitter"  // mention match with Twitter service
	 *
	 * @private
	 * @param {Autolinker.match.Match} match The Match instance to generate an
	 *   anchor tag from.
	 * @return {String} The CSS class string for the link. Example return:
	 *   "myLink myLink-url". If no {@link #className} was configured, returns
	 *   an empty string.
	 */
	createCssClass : function( match ) {
		var className = this.className;

		if( !className ) {
			return "";

		} else {
			var returnClasses = [ className ],
				cssClassSuffixes = match.getCssClassSuffixes();

			for( var i = 0, len = cssClassSuffixes.length; i < len; i++ ) {
				returnClasses.push( className + '-' + cssClassSuffixes[ i ] );
			}
			return returnClasses.join( ' ' );
		}
	},


	/**
	 * Processes the `anchorText` by truncating the text according to the
	 * {@link #truncate} config.
	 *
	 * @private
	 * @param {String} anchorText The anchor tag's text (i.e. what will be
	 *   displayed).
	 * @return {String} The processed `anchorText`.
	 */
	processAnchorText : function( anchorText ) {
		anchorText = this.doTruncate( anchorText );

		return anchorText;
	},


	/**
	 * Performs the truncation of the `anchorText` based on the {@link #truncate}
	 * option. If the `anchorText` is longer than the length specified by the
	 * {@link #truncate} option, the truncation is performed based on the
	 * `location` property. See {@link #truncate} for details.
	 *
	 * @private
	 * @param {String} anchorText The anchor tag's text (i.e. what will be
	 *   displayed).
	 * @return {String} The truncated anchor text.
	 */
	doTruncate : function( anchorText ) {
		var truncate = this.truncate;
		if( !truncate || !truncate.length ) return anchorText;

		var truncateLength = truncate.length,
			truncateLocation = truncate.location;

		if( truncateLocation === 'smart' ) {
			return Autolinker.truncate.TruncateSmart( anchorText, truncateLength );

		} else if( truncateLocation === 'middle' ) {
			return Autolinker.truncate.TruncateMiddle( anchorText, truncateLength );

		} else {
			return Autolinker.truncate.TruncateEnd( anchorText, truncateLength );
		}
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.htmlParser.HtmlParser
 * @extends Object
 *
 * An HTML parser implementation which simply walks an HTML string and returns an array of
 * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.
 *
 * Autolinker uses this to only link URLs/emails/mentions within text nodes, effectively ignoring / "walking
 * around" HTML tags.
 */
Autolinker.htmlParser.HtmlParser = Autolinker.Util.extend( Object, {

	/**
	 * @private
	 * @property {RegExp} htmlRegex
	 *
	 * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and
	 * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.
	 *
	 * Capturing groups:
	 *
	 * 1. The "!DOCTYPE" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.
	 * 2. If it is an end tag, this group will have the '/'.
	 * 3. If it is a comment tag, this group will hold the comment text (i.e.
	 *    the text inside the `&lt;!--` and `--&gt;`.
	 * 4. The tag name for a tag without attributes (other than the &lt;!DOCTYPE&gt; tag)
	 * 5. The tag name for a tag with attributes (other than the &lt;!DOCTYPE&gt; tag)
	 */
	htmlRegex : (function() {
		var commentTagRegex = /!--([\s\S]+?)--/,
		    tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,
		    attrNameRegex = /[^\s"'>\/=\x00-\x1F\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char
		    attrValueRegex = /(?:"[^"]*?"|'[^']*?'|[^'"=<>`\s]+)/, // double quoted, single quoted, or unquoted attribute values
		    nameEqualsValueRegex = attrNameRegex.source + '(?:\\s*=\\s*' + attrValueRegex.source + ')?';  // optional '=[value]'

		return new RegExp( [
			// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">)
			'(?:',
				'<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag

					// Zero or more attributes following the tag name
					'(?:',
						'\\s+',  // one or more whitespace chars before an attribute

						// Either:
						// A. attr="value", or
						// B. "value" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">)
						'(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')',
					')*',
				'>',
			')',

			'|',

			// All other HTML tags (i.e. tags that are not <!DOCTYPE>)
			'(?:',
				'<(/)?',  // Beginning of a tag or comment. Either '<' for a start tag, or '</' for an end tag.
				          // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.

					'(?:',
						commentTagRegex.source,  // *** Capturing Group 3 - A Comment Tag's Text

						'|',

						// Handle tag without attributes.
						// Doing this separately from a tag that has attributes
						// to fix a regex time complexity issue seen with the
						// example in https://github.com/gregjacobs/Autolinker.js/issues/172
						'(?:',
							// *** Capturing Group 4 - The tag name for a tag without attributes
							'(' + tagNameRegex.source + ')',

							'\\s*/?',  // any trailing spaces and optional '/' before the closing '>'
						')',

						'|',

						// Handle tag with attributes
						// Doing this separately from a tag with no attributes
						// to fix a regex time complexity issue seen with the
						// example in https://github.com/gregjacobs/Autolinker.js/issues/172
						'(?:',
							// *** Capturing Group 5 - The tag name for a tag with attributes
							'(' + tagNameRegex.source + ')',

							'\\s+',  // must have at least one space after the tag name to prevent ReDoS issue (issue #172)

							// Zero or more attributes following the tag name
							'(?:',
								'(?:\\s+|\\b)',        // any number of whitespace chars before an attribute. NOTE: Using \s* here throws Chrome into an infinite loop for some reason, so using \s+|\b instead
								nameEqualsValueRegex,  // attr="value" (with optional ="value" part)
							')*',

							'\\s*/?',  // any trailing spaces and optional '/' before the closing '>'
						')',
					')',
				'>',
			')'
		].join( "" ), 'gi' );
	} )(),

	/**
	 * @private
	 * @property {RegExp} htmlCharacterEntitiesRegex
	 *
	 * The regular expression that matches common HTML character entities.
	 *
	 * Ignoring &amp; as it could be part of a query string -- handling it separately.
	 */
	htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,


	/**
	 * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes}
	 * to represent the HTML structure of the input string.
	 *
	 * @param {String} html The HTML to parse.
	 * @return {Autolinker.htmlParser.HtmlNode[]}
	 */
	parse : function( html ) {
		var htmlRegex = this.htmlRegex,
		    currentResult,
		    lastIndex = 0,
		    textAndEntityNodes,
		    nodes = [];  // will be the result of the method

		while( ( currentResult = htmlRegex.exec( html ) ) !== null ) {
			var tagText = currentResult[ 0 ],
			    commentText = currentResult[ 3 ], // if we've matched a comment
			    tagName = currentResult[ 1 ] || currentResult[ 4 ] || currentResult[ 5 ],  // The <!DOCTYPE> tag (ex: "!DOCTYPE"), or another tag (ex: "a" or "img")
			    isClosingTag = !!currentResult[ 2 ],
			    offset = currentResult.index,
			    inBetweenTagsText = html.substring( lastIndex, offset );

			// Push TextNodes and EntityNodes for any text found between tags
			if( inBetweenTagsText ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( lastIndex, inBetweenTagsText );
				nodes.push.apply( nodes, textAndEntityNodes );
			}

			// Push the CommentNode or ElementNode
			if( commentText ) {
				nodes.push( this.createCommentNode( offset, tagText, commentText ) );
			} else {
				nodes.push( this.createElementNode( offset, tagText, tagName, isClosingTag ) );
			}

			lastIndex = offset + tagText.length;
		}

		// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.
		if( lastIndex < html.length ) {
			var text = html.substring( lastIndex );

			// Push TextNodes and EntityNodes for any text found between tags
			if( text ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( lastIndex, text );

				// Note: the following 3 lines were previously:
				//   nodes.push.apply( nodes, textAndEntityNodes );
				// but this was causing a "Maximum Call Stack Size Exceeded"
				// error on inputs with a large number of html entities.
				textAndEntityNodes.forEach( function( node ) {
					nodes.push( node );
				} );
			}
		}

		return nodes;
	},


	/**
	 * Parses text and HTML entity nodes from a given string. The input string
	 * should not have any HTML tags (elements) within it.
	 *
	 * @private
	 * @param {Number} offset The offset of the text node match within the
	 *   original HTML string.
	 * @param {String} text The string of text to parse. This is from an HTML
	 *   text node.
	 * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to
	 *   represent the {@link Autolinker.htmlParser.TextNode TextNodes} and
	 *   {@link Autolinker.htmlParser.EntityNode EntityNodes} found.
	 */
	parseTextAndEntityNodes : function( offset, text ) {
		var nodes = [],
		    textAndEntityTokens = Autolinker.Util.splitAndCapture( text, this.htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array

		// Every even numbered token is a TextNode, and every odd numbered token is an EntityNode
		// For example: an input `text` of "Test &quot;this&quot; today" would turn into the
		//   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]
		for( var i = 0, len = textAndEntityTokens.length; i < len; i += 2 ) {
			var textToken = textAndEntityTokens[ i ],
			    entityToken = textAndEntityTokens[ i + 1 ];

			if( textToken ) {
				nodes.push( this.createTextNode( offset, textToken ) );
				offset += textToken.length;
			}
			if( entityToken ) {
				nodes.push( this.createEntityNode( offset, entityToken ) );
				offset += entityToken.length;
			}
		}
		return nodes;
	},


	/**
	 * Factory method to create an {@link Autolinker.htmlParser.CommentNode CommentNode}.
	 *
	 * @private
	 * @param {Number} offset The offset of the match within the original HTML
	 *   string.
	 * @param {String} tagText The full text of the tag (comment) that was
	 *   matched, including its &lt;!-- and --&gt;.
	 * @param {String} commentText The full text of the comment that was matched.
	 */
	createCommentNode : function( offset, tagText, commentText ) {
		return new Autolinker.htmlParser.CommentNode( {
			offset : offset,
			text   : tagText,
			comment: Autolinker.Util.trim( commentText )
		} );
	},


	/**
	 * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.
	 *
	 * @private
	 * @param {Number} offset The offset of the match within the original HTML
	 *   string.
	 * @param {String} tagText The full text of the tag (element) that was
	 *   matched, including its attributes.
	 * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would
	 *   be passed to this method as "img".
	 * @param {Boolean} isClosingTag `true` if it's a closing tag, false
	 *   otherwise.
	 * @return {Autolinker.htmlParser.ElementNode}
	 */
	createElementNode : function( offset, tagText, tagName, isClosingTag ) {
		return new Autolinker.htmlParser.ElementNode( {
			offset  : offset,
			text    : tagText,
			tagName : tagName.toLowerCase(),
			closing : isClosingTag
		} );
	},


	/**
	 * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.
	 *
	 * @private
	 * @param {Number} offset The offset of the match within the original HTML
	 *   string.
	 * @param {String} text The text that was matched for the HTML entity (such
	 *   as '&amp;nbsp;').
	 * @return {Autolinker.htmlParser.EntityNode}
	 */
	createEntityNode : function( offset, text ) {
		return new Autolinker.htmlParser.EntityNode( { offset: offset, text: text } );
	},


	/**
	 * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.
	 *
	 * @private
	 * @param {Number} offset The offset of the match within the original HTML
	 *   string.
	 * @param {String} text The text that was matched.
	 * @return {Autolinker.htmlParser.TextNode}
	 */
	createTextNode : function( offset, text ) {
		return new Autolinker.htmlParser.TextNode( { offset: offset, text: text } );
	}

} );

/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.htmlParser.HtmlNode
 *
 * Represents an HTML node found in an input string. An HTML node is one of the
 * following:
 *
 * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents
 *    HTML tags.
 * 2. A {@link Autolinker.htmlParser.CommentNode CommentNode}, which represents
 *    HTML comments.
 * 3. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text
 *    outside or within HTML tags.
 * 4. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents
 *    one of the known HTML entities that Autolinker looks for. This includes
 *    common ones such as &amp;quot; and &amp;nbsp;
 */
Autolinker.htmlParser.HtmlNode = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Number} offset (required)
	 *
	 * The offset of the HTML node in the original text that was parsed.
	 */
	offset : undefined,

	/**
	 * @cfg {String} text (required)
	 *
	 * The text that was matched for the HtmlNode.
	 *
	 * - In the case of an {@link Autolinker.htmlParser.ElementNode ElementNode},
	 *   this will be the tag's text.
	 * - In the case of an {@link Autolinker.htmlParser.CommentNode CommentNode},
	 *   this will be the comment's text.
	 * - In the case of a {@link Autolinker.htmlParser.TextNode TextNode}, this
	 *   will be the text itself.
	 * - In the case of a {@link Autolinker.htmlParser.EntityNode EntityNode},
	 *   this will be the text of the HTML entity.
	 */
	text : undefined,


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance,
	 * specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );

		if( this.offset == null ) throw new Error( '`offset` cfg required' );
		if( this.text == null ) throw new Error( '`text` cfg required' );
	},


	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,


	/**
	 * Retrieves the {@link #offset} of the HtmlNode. This is the offset of the
	 * HTML node in the original string that was parsed.
	 *
	 * @return {Number}
	 */
	getOffset : function() {
		return this.offset;
	},


	/**
	 * Retrieves the {@link #text} for the HtmlNode.
	 *
	 * @return {String}
	 */
	getText : function() {
		return this.text;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.CommentNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents an HTML comment node that has been parsed by the
 * {@link Autolinker.htmlParser.HtmlParser}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.CommentNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * @cfg {String} comment (required)
	 *
	 * The text inside the comment tag. This text is stripped of any leading or
	 * trailing whitespace.
	 */
	comment : '',


	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'comment';
	},


	/**
	 * Returns the comment inside the comment tag.
	 *
	 * @return {String}
	 */
	getComment : function() {
		return this.comment;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.ElementNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.ElementNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * @cfg {String} tagName (required)
	 *
	 * The name of the tag that was matched.
	 */
	tagName : '',

	/**
	 * @cfg {Boolean} closing (required)
	 *
	 * `true` if the element (tag) is a closing tag, `false` if its an opening
	 * tag.
	 */
	closing : false,


	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'element';
	},


	/**
	 * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag,
	 * returns "img".
	 *
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName;
	},


	/**
	 * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt;
	 * returns `false`, while &lt;/div&gt; returns `true`.
	 *
	 * @return {Boolean}
	 */
	isClosing : function() {
		return this.closing;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.EntityNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText}
 * method.
 *
 * Note that this class will only be returned from the HtmlParser for the set of
 * checked HTML entity nodes  defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.EntityNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'entity';
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.TextNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.TextNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'text';
	}

} );
/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.match.Match
 *
 * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a
 * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.
 *
 * For example:
 *
 *     var input = "...";  // string with URLs, Email Addresses, and Mentions (Twitter, Instagram)
 *
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *
 *             switch( match.getType() ) {
 *                 case 'url' :
 *                     console.log( "url: ", match.getUrl() );
 *
 *                 case 'email' :
 *                     console.log( "email: ", match.getEmail() );
 *
 *                 case 'mention' :
 *                     console.log( "mention: ", match.getMention() );
 *             }
 *         }
 *     } );
 *
 * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.
 */
Autolinker.match.Match = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Autolinker.AnchorTagBuilder} tagBuilder (required)
	 *
	 * Reference to the AnchorTagBuilder instance to use to generate an anchor
	 * tag for the Match.
	 */

	/**
	 * @cfg {String} matchedText (required)
	 *
	 * The original text that was matched by the {@link Autolinker.matcher.Matcher}.
	 */

	/**
	 * @cfg {Number} offset (required)
	 *
	 * The offset of where the match was made in the input string.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		if( cfg.tagBuilder == null ) throw new Error( '`tagBuilder` cfg required' );
		if( cfg.matchedText == null ) throw new Error( '`matchedText` cfg required' );
		if( cfg.offset == null ) throw new Error( '`offset` cfg required' );

		this.tagBuilder = cfg.tagBuilder;
		this.matchedText = cfg.matchedText;
		this.offset = cfg.offset;
	},


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,


	/**
	 * Returns the original text that was matched.
	 *
	 * @return {String}
	 */
	getMatchedText : function() {
		return this.matchedText;
	},


	/**
	 * Sets the {@link #offset} of where the match was made in the input string.
	 *
	 * A {@link Autolinker.matcher.Matcher} will be fed only HTML text nodes,
	 * and will therefore set an original offset that is relative to the HTML
	 * text node itself. However, we want this offset to be relative to the full
	 * HTML input string, and thus if using {@link Autolinker#parse} (rather
	 * than calling a {@link Autolinker.matcher.Matcher} directly), then this
	 * offset is corrected after the Matcher itself has done its job.
	 *
	 * @param {Number} offset
	 */
	setOffset : function( offset ) {
		this.offset = offset;
	},


	/**
	 * Returns the offset of where the match was made in the input string. This
	 * is the 0-based index of the match.
	 *
	 * @return {Number}
	 */
	getOffset : function() {
		return this.offset;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @abstract
	 * @return {String}
	 */
	getAnchorHref : Autolinker.Util.abstractMethod,


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @abstract
	 * @return {String}
	 */
	getAnchorText : Autolinker.Util.abstractMethod,


	/**
	 * Returns the CSS class suffix(es) for this match.
	 *
	 * A CSS class suffix is appended to the {@link Autolinker#className} in
	 * the {@link Autolinker.AnchorTagBuilder} when a match is translated into
	 * an anchor tag.
	 *
	 * For example, if {@link Autolinker#className} was configured as 'myLink',
	 * and this method returns `[ 'url' ]`, the final class name of the element
	 * will become: 'myLink myLink-url'.
	 *
	 * The match may provide multiple CSS class suffixes to be appended to the
	 * {@link Autolinker#className} in order to facilitate better styling
	 * options for different match criteria. See {@link Autolinker.match.Mention}
	 * for an example.
	 *
	 * By default, this method returns a single array with the match's
	 * {@link #getType type} name, but may be overridden by subclasses.
	 *
	 * @return {String[]}
	 */
	getCssClassSuffixes : function() {
		return [ this.getType() ];
	},


	/**
	 * Builds and returns an {@link Autolinker.HtmlTag} instance based on the
	 * Match.
	 *
	 * This can be used to easily generate anchor tags from matches, and either
	 * return their HTML string, or modify them before doing so.
	 *
	 * Example Usage:
	 *
	 *     var tag = match.buildTag();
	 *     tag.addClass( 'cordova-link' );
	 *     tag.setAttr( 'target', '_system' );
	 *
	 *     tag.toAnchorString();  // <a href="http://google.com" class="cordova-link" target="_system">Google</a>
	 */
	buildTag : function() {
		return this.tagBuilder.build( this );
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.match.Email
 * @extends Autolinker.match.Match
 *
 * Represents a Email match found in an input string which should be Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Email = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} email (required)
	 *
	 * The email address that was matched.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		if( !cfg.email ) throw new Error( '`email` cfg required' );

		this.email = cfg.email;
	},


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'email';
	},


	/**
	 * Returns the email address that was matched.
	 *
	 * @return {String}
	 */
	getEmail : function() {
		return this.email;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'mailto:' + this.email;
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return this.email;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.match.Hashtag
 * @extends Autolinker.match.Match
 *
 * Represents a Hashtag match found in an input string which should be
 * Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more
 * details.
 */
Autolinker.match.Hashtag = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} serviceName
	 *
	 * The service to point hashtag matches to. See {@link Autolinker#hashtag}
	 * for available values.
	 */

	/**
	 * @cfg {String} hashtag (required)
	 *
	 * The Hashtag that was matched, without the '#'.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		// TODO: if( !serviceName ) throw new Error( '`serviceName` cfg required' );
		if( !cfg.hashtag ) throw new Error( '`hashtag` cfg required' );

		this.serviceName = cfg.serviceName;
		this.hashtag = cfg.hashtag;
	},


	/**
	 * Returns the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'hashtag';
	},


	/**
	 * Returns the configured {@link #serviceName} to point the Hashtag to.
	 * Ex: 'facebook', 'twitter'.
	 *
	 * @return {String}
	 */
	getServiceName : function() {
		return this.serviceName;
	},


	/**
	 * Returns the matched hashtag, without the '#' character.
	 *
	 * @return {String}
	 */
	getHashtag : function() {
		return this.hashtag;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		var serviceName = this.serviceName,
		    hashtag = this.hashtag;

		switch( serviceName ) {
			case 'twitter' :
				return 'https://twitter.com/hashtag/' + hashtag;
			case 'facebook' :
				return 'https://www.facebook.com/hashtag/' + hashtag;
			case 'instagram' :
				return 'https://instagram.com/explore/tags/' + hashtag;

			default :  // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.
				throw new Error( 'Unknown service name to point hashtag to: ', serviceName );
		}
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return '#' + this.hashtag;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.match.Phone
 * @extends Autolinker.match.Match
 *
 * Represents a Phone number match found in an input string which should be
 * Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more
 * details.
 */
Autolinker.match.Phone = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @protected
	 * @property {String} number (required)
	 *
	 * The phone number that was matched, without any delimiter characters.
	 *
	 * Note: This is a string to allow for prefixed 0's.
	 */

	/**
	 * @protected
	 * @property  {Boolean} plusSign (required)
	 *
	 * `true` if the matched phone number started with a '+' sign. We'll include
	 * it in the `tel:` URL if so, as this is needed for international numbers.
	 *
	 * Ex: '+1 (123) 456 7879'
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		if( !cfg.number ) throw new Error( '`number` cfg required' );
		if( cfg.plusSign == null ) throw new Error( '`plusSign` cfg required' );

		this.number = cfg.number;
		this.plusSign = cfg.plusSign;
	},


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'phone';
	},


	/**
	 * Returns the phone number that was matched as a string, without any
	 * delimiter characters.
	 *
	 * Note: This is a string to allow for prefixed 0's.
	 *
	 * @return {String}
	 */
	getNumber: function() {
		return this.number;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'tel:' + ( this.plusSign ? '+' : '' ) + this.number;
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return this.matchedText;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.match.Mention
 * @extends Autolinker.match.Match
 *
 * Represents a Mention match found in an input string which should be Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Mention = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} serviceName
	 *
	 * The service to point mention matches to. See {@link Autolinker#mention}
	 * for available values.
	 */

	/**
	 * @cfg {String} mention (required)
	 *
	 * The Mention that was matched, without the '@' character.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		if( !cfg.serviceName ) throw new Error( '`serviceName` cfg required' );
		if( !cfg.mention ) throw new Error( '`mention` cfg required' );

		this.mention = cfg.mention;
		this.serviceName = cfg.serviceName;
	},


	/**
	 * Returns the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'mention';
	},


	/**
	 * Returns the mention, without the '@' character.
	 *
	 * @return {String}
	 */
	getMention : function() {
		return this.mention;
	},


	/**
	 * Returns the configured {@link #serviceName} to point the mention to.
	 * Ex: 'instagram', 'twitter'.
	 *
	 * @return {String}
	 */
	getServiceName : function() {
		return this.serviceName;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		switch( this.serviceName ) {
			case 'twitter' :
				return 'https://twitter.com/' + this.mention;
			case 'instagram' :
				return 'https://instagram.com/' + this.mention;

			default :  // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.
				throw new Error( 'Unknown service name to point mention to: ', this.serviceName );
		}
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return '@' + this.mention;
	},


	/**
	 * Returns the CSS class suffixes that should be used on a tag built with
	 * the match. See {@link Autolinker.match.Match#getCssClassSuffixes} for
	 * details.
	 *
	 * @return {String[]}
	 */
	getCssClassSuffixes : function() {
		var cssClassSuffixes = Autolinker.match.Match.prototype.getCssClassSuffixes.call( this ),
		    serviceName = this.getServiceName();

		if( serviceName ) {
			cssClassSuffixes.push( serviceName );
		}
		return cssClassSuffixes;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.match.Url
 * @extends Autolinker.match.Match
 *
 * Represents a Url match found in an input string which should be Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Url = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} url (required)
	 *
	 * The url that was matched.
	 */

	/**
	 * @cfg {"scheme"/"www"/"tld"} urlMatchType (required)
	 *
	 * The type of URL match that this class represents. This helps to determine
	 * if the match was made in the original text with a prefixed scheme (ex:
	 * 'http://www.google.com'), a prefixed 'www' (ex: 'www.google.com'), or
	 * was matched by a known top-level domain (ex: 'google.com').
	 */

	/**
	 * @cfg {Boolean} protocolUrlMatch (required)
	 *
	 * `true` if the URL is a match which already has a protocol (i.e.
	 * 'http://'), `false` if the match was from a 'www' or known TLD match.
	 */

	/**
	 * @cfg {Boolean} protocolRelativeMatch (required)
	 *
	 * `true` if the URL is a protocol-relative match. A protocol-relative match
	 * is a URL that starts with '//', and will be either http:// or https://
	 * based on the protocol that the site is loaded under.
	 */

	/**
	 * @cfg {Object} stripPrefix (required)
	 *
	 * The Object form of {@link Autolinker#cfg-stripPrefix}.
	 */

	/**
	 * @cfg {Boolean} stripTrailingSlash (required)
	 * @inheritdoc Autolinker#cfg-stripTrailingSlash
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		if( cfg.urlMatchType !== 'scheme' && cfg.urlMatchType !== 'www' && cfg.urlMatchType !== 'tld' ) throw new Error( '`urlMatchType` cfg must be one of: "scheme", "www", or "tld"' );
		if( !cfg.url ) throw new Error( '`url` cfg required' );
		if( cfg.protocolUrlMatch == null ) throw new Error( '`protocolUrlMatch` cfg required' );
		if( cfg.protocolRelativeMatch == null ) throw new Error( '`protocolRelativeMatch` cfg required' );
		if( cfg.stripPrefix == null ) throw new Error( '`stripPrefix` cfg required' );
		if( cfg.stripTrailingSlash == null ) throw new Error( '`stripTrailingSlash` cfg required' );

		this.urlMatchType = cfg.urlMatchType;
		this.url = cfg.url;
		this.protocolUrlMatch = cfg.protocolUrlMatch;
		this.protocolRelativeMatch = cfg.protocolRelativeMatch;
		this.stripPrefix = cfg.stripPrefix;
		this.stripTrailingSlash = cfg.stripTrailingSlash;
	},


	/**
	 * @private
	 * @property {RegExp} schemePrefixRegex
	 *
	 * A regular expression used to remove the 'http://' or 'https://' from
	 * URLs.
	 */
	schemePrefixRegex: /^(https?:\/\/)?/i,

	/**
	 * @private
	 * @property {RegExp} wwwPrefixRegex
	 *
	 * A regular expression used to remove the 'www.' from URLs.
	 */
	wwwPrefixRegex: /^(https?:\/\/)?(www\.)?/i,

	/**
	 * @private
	 * @property {RegExp} protocolRelativeRegex
	 *
	 * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes
	 * of {@link #getAnchorText}. A protocol-relative URL is, for example, "//yahoo.com"
	 */
	protocolRelativeRegex : /^\/\//,

	/**
	 * @private
	 * @property {Boolean} protocolPrepended
	 *
	 * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the
	 * {@link #url} did not have a protocol)
	 */
	protocolPrepended : false,


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'url';
	},


	/**
	 * Returns a string name for the type of URL match that this class
	 * represents.
	 *
	 * This helps to determine if the match was made in the original text with a
	 * prefixed scheme (ex: 'http://www.google.com'), a prefixed 'www' (ex:
	 * 'www.google.com'), or was matched by a known top-level domain (ex:
	 * 'google.com').
	 *
	 * @return {"scheme"/"www"/"tld"}
	 */
	getUrlMatchType : function() {
		return this.urlMatchType;
	},


	/**
	 * Returns the url that was matched, assuming the protocol to be 'http://' if the original
	 * match was missing a protocol.
	 *
	 * @return {String}
	 */
	getUrl : function() {
		var url = this.url;

		// if the url string doesn't begin with a protocol, assume 'http://'
		if( !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended ) {
			url = this.url = 'http://' + url;

			this.protocolPrepended = true;
		}

		return url;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		var url = this.getUrl();

		return url.replace( /&amp;/g, '&' );  // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		var anchorText = this.getMatchedText();

		if( this.protocolRelativeMatch ) {
			// Strip off any protocol-relative '//' from the anchor text
			anchorText = this.stripProtocolRelativePrefix( anchorText );
		}
		if( this.stripPrefix.scheme ) {
			anchorText = this.stripSchemePrefix( anchorText );
		}
		if( this.stripPrefix.www ) {
			anchorText = this.stripWwwPrefix( anchorText );
		}
		if( this.stripTrailingSlash ) {
			anchorText = this.removeTrailingSlash( anchorText );  // remove trailing slash, if there is one
		}

		return anchorText;
	},


	// ---------------------------------------

	// Utility Functionality

	/**
	 * Strips the scheme prefix (such as "http://" or "https://") from the given
	 * `url`.
	 *
	 * @private
	 * @param {String} url The text of the anchor that is being generated, for
	 *   which to strip off the url scheme.
	 * @return {String} The `url`, with the scheme stripped.
	 */
	stripSchemePrefix : function( url ) {
		return url.replace( this.schemePrefixRegex, '' );
	},


	/**
	 * Strips the 'www' prefix from the given `url`.
	 *
	 * @private
	 * @param {String} url The text of the anchor that is being generated, for
	 *   which to strip off the 'www' if it exists.
	 * @return {String} The `url`, with the 'www' stripped.
	 */
	stripWwwPrefix : function( url ) {
		return url.replace( this.wwwPrefixRegex, '$1' );  // leave any scheme ($1), it one exists
	},


	/**
	 * Strips any protocol-relative '//' from the anchor text.
	 *
	 * @private
	 * @param {String} text The text of the anchor that is being generated, for which to strip off the
	 *   protocol-relative prefix (such as stripping off "//")
	 * @return {String} The `anchorText`, with the protocol-relative prefix stripped.
	 */
	stripProtocolRelativePrefix : function( text ) {
		return text.replace( this.protocolRelativeRegex, '' );
	},


	/**
	 * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.
	 *
	 * @private
	 * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing
	 *   slash ('/') that may exist.
	 * @return {String} The `anchorText`, with the trailing slash removed.
	 */
	removeTrailingSlash : function( anchorText ) {
		if( anchorText.charAt( anchorText.length - 1 ) === '/' ) {
			anchorText = anchorText.slice( 0, -1 );
		}
		return anchorText;
	}

} );
// NOTE: THIS IS A GENERATED FILE
// To update with the latest TLD list, run `gulp update-tld-list`

/*global Autolinker */
Autolinker.tldRegex = /(?:xn--vermgensberatung-pwb|xn--vermgensberater-ctb|xn--clchc0ea0b2g2a9gcd|xn--w4r85el8fhu5dnra|northwesternmutual|travelersinsurance|vermögensberatung|xn--3oq18vl8pn36a|xn--5su34j936bgsg|xn--bck1b9a5dre4c|xn--mgbai9azgqp6j|xn--mgberp4a5d4ar|xn--xkc2dl3a5ee0h|vermögensberater|xn--fzys8d69uvgm|xn--mgba7c0bbn0a|xn--xkc2al3hye2a|americanexpress|kerryproperties|sandvikcoromant|xn--i1b6b1a6a2e|xn--kcrx77d1x4a|xn--lgbbat1ad8j|xn--mgba3a4f16a|xn--mgbc0a9azcg|xn--nqv7fs00ema|afamilycompany|americanfamily|bananarepublic|cancerresearch|cookingchannel|kerrylogistics|weatherchannel|xn--54b7fta0cc|xn--6qq986b3xl|xn--80aqecdr1a|xn--b4w605ferd|xn--fiq228c5hs|xn--jlq61u9w7b|xn--mgba3a3ejt|xn--mgbaam7a8h|xn--mgbayh7gpa|xn--mgbb9fbpob|xn--mgbbh1a71e|xn--mgbca7dzdo|xn--mgbi4ecexp|xn--mgbx4cd0ab|international|lifeinsurance|orientexpress|spreadbetting|travelchannel|wolterskluwer|xn--eckvdtc9d|xn--fpcrj9c3d|xn--fzc2c9e2c|xn--tiq49xqyj|xn--yfro4i67o|xn--ygbi2ammx|construction|lplfinancial|pamperedchef|scholarships|versicherung|xn--3e0b707e|xn--80adxhks|xn--80asehdb|xn--8y0a063a|xn--gckr3f0f|xn--mgb9awbf|xn--mgbab2bd|xn--mgbpl2fh|xn--mgbt3dhd|xn--mk1bu44c|xn--ngbc5azd|xn--ngbe9e0a|xn--ogbpf8fl|xn--qcka1pmc|accountants|barclaycard|blackfriday|blockbuster|bridgestone|calvinklein|contractors|creditunion|engineering|enterprises|foodnetwork|investments|kerryhotels|lamborghini|motorcycles|olayangroup|photography|playstation|productions|progressive|redumbrella|rightathome|williamhill|xn--11b4c3d|xn--1ck2e1b|xn--1qqw23a|xn--3bst00m|xn--3ds443g|xn--42c2d9a|xn--45brj9c|xn--55qw42g|xn--6frz82g|xn--80ao21a|xn--9krt00a|xn--cck2b3b|xn--czr694b|xn--d1acj3b|xn--efvy88h|xn--estv75g|xn--fct429k|xn--fjq720a|xn--flw351e|xn--g2xx48c|xn--gecrj9c|xn--gk3at1e|xn--h2brj9c|xn--hxt814e|xn--imr513n|xn--j6w193g|xn--jvr189m|xn--kprw13d|xn--kpry57d|xn--kpu716f|xn--mgbtx2b|xn--mix891f|xn--nyqy26a|xn--pbt977c|xn--pgbs0dh|xn--q9jyb4c|xn--rhqv96g|xn--rovu88b|xn--s9brj9c|xn--ses554g|xn--t60b56a|xn--vuq861b|xn--w4rs40l|xn--xhq521b|xn--zfr164b|சிங்கப்பூர்|accountant|apartments|associates|basketball|bnpparibas|boehringer|capitalone|consulting|creditcard|cuisinella|eurovision|extraspace|foundation|healthcare|immobilien|industries|management|mitsubishi|nationwide|newholland|nextdirect|onyourside|properties|protection|prudential|realestate|republican|restaurant|schaeffler|swiftcover|tatamotors|technology|telefonica|university|vistaprint|vlaanderen|volkswagen|xn--30rr7y|xn--3pxu8k|xn--45q11c|xn--4gbrim|xn--55qx5d|xn--5tzm5g|xn--80aswg|xn--90a3ac|xn--9dbq2a|xn--9et52u|xn--c2br7g|xn--cg4bki|xn--czrs0t|xn--czru2d|xn--fiq64b|xn--fiqs8s|xn--fiqz9s|xn--io0a7i|xn--kput3i|xn--mxtq1m|xn--o3cw4h|xn--pssy2u|xn--unup4y|xn--wgbh1c|xn--wgbl6a|xn--y9a3aq|accenture|alfaromeo|allfinanz|amsterdam|analytics|aquarelle|barcelona|bloomberg|christmas|community|directory|education|equipment|fairwinds|financial|firestone|fresenius|frontdoor|fujixerox|furniture|goldpoint|goodhands|hisamitsu|homedepot|homegoods|homesense|honeywell|institute|insurance|kuokgroup|ladbrokes|lancaster|landrover|lifestyle|marketing|marshalls|mcdonalds|melbourne|microsoft|montblanc|panasonic|passagens|pramerica|richardli|scjohnson|shangrila|solutions|statebank|statefarm|stockholm|travelers|vacations|xn--90ais|xn--c1avg|xn--d1alf|xn--e1a4c|xn--fhbei|xn--j1aef|xn--j1amh|xn--l1acc|xn--nqv7f|xn--p1acf|xn--tckwe|xn--vhquv|yodobashi|abudhabi|airforce|allstate|attorney|barclays|barefoot|bargains|baseball|boutique|bradesco|broadway|brussels|budapest|builders|business|capetown|catering|catholic|chrysler|cipriani|cityeats|cleaning|clinique|clothing|commbank|computer|delivery|deloitte|democrat|diamonds|discount|discover|download|engineer|ericsson|esurance|everbank|exchange|feedback|fidelity|firmdale|football|frontier|goodyear|grainger|graphics|guardian|hdfcbank|helsinki|holdings|hospital|infiniti|ipiranga|istanbul|jpmorgan|lighting|lundbeck|marriott|maserati|mckinsey|memorial|mortgage|movistar|observer|partners|pharmacy|pictures|plumbing|property|redstone|reliance|saarland|samsclub|security|services|shopping|showtime|softbank|software|stcgroup|supplies|symantec|telecity|training|uconnect|vanguard|ventures|verisign|woodside|xn--90ae|xn--node|xn--p1ai|xn--qxam|yokohama|السعودية|abogado|academy|agakhan|alibaba|android|athleta|auction|audible|auspost|avianca|banamex|bauhaus|bentley|bestbuy|booking|brother|bugatti|capital|caravan|careers|cartier|channel|chintai|citadel|clubmed|college|cologne|comcast|company|compare|contact|cooking|corsica|country|coupons|courses|cricket|cruises|dentist|digital|domains|exposed|express|farmers|fashion|ferrari|ferrero|finance|fishing|fitness|flights|florist|flowers|forsale|frogans|fujitsu|gallery|genting|godaddy|guitars|hamburg|hangout|hitachi|holiday|hosting|hoteles|hotmail|hyundai|iselect|ismaili|jewelry|juniper|kitchen|komatsu|lacaixa|lancome|lanxess|lasalle|latrobe|leclerc|liaison|limited|lincoln|markets|metlife|monster|netbank|netflix|network|neustar|okinawa|oldnavy|organic|origins|panerai|philips|pioneer|politie|realtor|recipes|rentals|reviews|rexroth|samsung|sandvik|schmidt|schwarz|science|shiksha|shriram|singles|spiegel|staples|starhub|statoil|storage|support|surgery|systems|temasek|theater|theatre|tickets|tiffany|toshiba|trading|walmart|wanggou|watches|weather|website|wedding|whoswho|windows|winners|xfinity|yamaxun|youtube|zuerich|католик|الجزائر|العليان|پاکستان|كاثوليك|موبايلي|இந்தியா|abarth|abbott|abbvie|active|africa|agency|airbus|airtel|alipay|alsace|alstom|anquan|aramco|author|bayern|beauty|berlin|bharti|blanco|bostik|boston|broker|camera|career|caseih|casino|center|chanel|chrome|church|circle|claims|clinic|coffee|comsec|condos|coupon|credit|cruise|dating|datsun|dealer|degree|dental|design|direct|doctor|dunlop|dupont|durban|emerck|energy|estate|events|expert|family|flickr|futbol|gallup|garden|george|giving|global|google|gratis|health|hermes|hiphop|hockey|hughes|imamat|insure|intuit|jaguar|joburg|juegos|kaufen|kinder|kindle|kosher|lancia|latino|lawyer|lefrak|living|locker|london|luxury|madrid|maison|makeup|market|mattel|mobile|mobily|monash|mormon|moscow|museum|mutual|nagoya|natura|nissan|nissay|norton|nowruz|office|olayan|online|oracle|orange|otsuka|pfizer|photos|physio|piaget|pictet|quebec|racing|realty|reisen|repair|report|review|rocher|rogers|ryukyu|safety|sakura|sanofi|school|schule|secure|select|shouji|soccer|social|stream|studio|supply|suzuki|swatch|sydney|taipei|taobao|target|tattoo|tennis|tienda|tjmaxx|tkmaxx|toyota|travel|unicom|viajes|viking|villas|virgin|vision|voting|voyage|vuelos|walter|warman|webcam|xihuan|xperia|yachts|yandex|zappos|москва|онлайн|ابوظبي|ارامكو|الاردن|المغرب|امارات|فلسطين|مليسيا|இலங்கை|ファッション|actor|adult|aetna|amfam|amica|apple|archi|audio|autos|azure|baidu|beats|bible|bingo|black|boats|boots|bosch|build|canon|cards|chase|cheap|chloe|cisco|citic|click|cloud|coach|codes|crown|cymru|dabur|dance|deals|delta|dodge|drive|dubai|earth|edeka|email|epost|epson|faith|fedex|final|forex|forum|gallo|games|gifts|gives|glade|glass|globo|gmail|green|gripe|group|gucci|guide|homes|honda|horse|house|hyatt|ikano|intel|irish|iveco|jetzt|koeln|kyoto|lamer|lease|legal|lexus|lilly|linde|lipsy|lixil|loans|locus|lotte|lotto|lupin|macys|mango|media|miami|money|mopar|movie|nadex|nexus|nikon|ninja|nokia|nowtv|omega|osaka|paris|parts|party|phone|photo|pizza|place|poker|praxi|press|prime|promo|quest|radio|rehab|reise|ricoh|rocks|rodeo|salon|sener|seven|sharp|shell|shoes|skype|sling|smart|smile|solar|space|stada|store|study|style|sucks|swiss|tatar|tires|tirol|tmall|today|tokyo|tools|toray|total|tours|trade|trust|tunes|tushu|ubank|vegas|video|vista|vodka|volvo|wales|watch|weber|weibo|works|world|xerox|yahoo|zippo|ایران|بازار|بھارت|سودان|سورية|همراه|संगठन|বাংলা|భారత్|嘉里大酒店|aarp|able|adac|aero|aigo|akdn|ally|amex|army|arpa|arte|asda|asia|audi|auto|baby|band|bank|bbva|beer|best|bike|bing|blog|blue|bofa|bond|book|buzz|cafe|call|camp|care|cars|casa|case|cash|cbre|cern|chat|citi|city|club|cool|coop|cyou|data|date|dclk|deal|dell|desi|diet|dish|docs|doha|duck|duns|dvag|erni|fage|fail|fans|farm|fast|fiat|fido|film|fire|fish|flir|food|ford|free|fund|game|gbiz|gent|ggee|gift|gmbh|gold|golf|goog|guge|guru|hair|haus|hdfc|help|here|hgtv|host|hsbc|icbc|ieee|imdb|immo|info|itau|java|jeep|jobs|jprs|kddi|kiwi|kpmg|kred|land|lego|lgbt|lidl|life|like|limo|link|live|loan|loft|love|ltda|luxe|maif|meet|meme|menu|mini|mint|mobi|moda|moto|mtpc|name|navy|news|next|nico|nike|ollo|open|page|pars|pccw|pics|ping|pink|play|plus|pohl|porn|post|prod|prof|qpon|raid|read|reit|rent|rest|rich|rmit|room|rsvp|ruhr|safe|sale|sapo|sarl|save|saxo|scor|scot|seat|seek|sexy|shaw|shia|shop|show|silk|sina|site|skin|sncf|sohu|song|sony|spot|star|surf|talk|taxi|team|tech|teva|tiaa|tips|town|toys|tube|vana|visa|viva|vivo|vote|voto|wang|weir|wien|wiki|wine|work|xbox|yoga|zara|zero|zone|дети|сайт|بيتك|تونس|شبكة|عراق|عمان|موقع|भारत|ভারত|ਭਾਰਤ|ભારત|ලංකා|グーグル|クラウド|ポイント|大众汽车|组织机构|電訊盈科|香格里拉|aaa|abb|abc|aco|ads|aeg|afl|aig|anz|aol|app|art|aws|axa|bar|bbc|bbt|bcg|bcn|bet|bid|bio|biz|bms|bmw|bnl|bom|boo|bot|box|buy|bzh|cab|cal|cam|car|cat|cba|cbn|cbs|ceb|ceo|cfa|cfd|com|crs|csc|dad|day|dds|dev|dhl|diy|dnp|dog|dot|dtv|dvr|eat|eco|edu|esq|eus|fan|fit|fly|foo|fox|frl|ftr|fun|fyi|gal|gap|gdn|gea|gle|gmo|gmx|goo|gop|got|gov|hbo|hiv|hkt|hot|how|htc|ibm|ice|icu|ifm|ing|ink|int|ist|itv|iwc|jcb|jcp|jio|jlc|jll|jmp|jnj|jot|joy|kfh|kia|kim|kpn|krd|lat|law|lds|lol|lpl|ltd|man|mba|mcd|med|men|meo|mil|mit|mlb|mls|mma|moe|moi|mom|mov|msd|mtn|mtr|nab|nba|nec|net|new|nfl|ngo|nhk|now|nra|nrw|ntt|nyc|obi|off|one|ong|onl|ooo|org|ott|ovh|pay|pet|pid|pin|pnc|pro|pru|pub|pwc|qvc|red|ren|ril|rio|rip|run|rwe|sap|sas|sbi|sbs|sca|scb|ses|sew|sex|sfr|ski|sky|soy|srl|srt|stc|tab|tax|tci|tdk|tel|thd|tjx|top|trv|tui|tvs|ubs|uno|uol|ups|vet|vig|vin|vip|wed|win|wme|wow|wtc|wtf|xin|xxx|xyz|you|yun|zip|бел|ком|қаз|мкд|мон|орг|рус|срб|укр|հայ|קום|قطر|كوم|مصر|कॉम|नेट|คอม|ไทย|ストア|セール|みんな|中文网|天主教|我爱你|新加坡|淡马锡|诺基亚|飞利浦|ac|ad|ae|af|ag|ai|al|am|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw|ελ|бг|ею|рф|გე|닷넷|닷컴|삼성|한국|コム|世界|中信|中国|中國|企业|佛山|信息|健康|八卦|公司|公益|台湾|台灣|商城|商店|商标|嘉里|在线|大拿|娱乐|家電|工行|广东|微博|慈善|手机|手表|政务|政府|新闻|时尚|書籍|机构|游戏|澳門|点看|珠宝|移动|网址|网店|网站|网络|联通|谷歌|购物|通販|集团|食品|餐厅|香港)/;

/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.matcher.Matcher
 *
 * An abstract class and interface for individual matchers to find matches in
 * an input string with linkified versions of them.
 *
 * Note that Matchers do not take HTML into account - they must be fed the text
 * nodes of any HTML string, which is handled by {@link Autolinker#parse}.
 */
Autolinker.matcher.Matcher = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Autolinker.AnchorTagBuilder} tagBuilder (required)
	 *
	 * Reference to the AnchorTagBuilder instance to use to generate HTML tags
	 * for {@link Autolinker.match.Match Matches}.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Matcher
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		if( !cfg.tagBuilder ) throw new Error( '`tagBuilder` cfg required' );

		this.tagBuilder = cfg.tagBuilder;
	},


	/**
	 * Parses the input `text` and returns the array of {@link Autolinker.match.Match Matches}
	 * for the matcher.
	 *
	 * @abstract
	 * @param {String} text The text to scan and replace matches in.
	 * @return {Autolinker.match.Match[]}
	 */
	parseMatches : Autolinker.Util.abstractMethod

} );
/*global Autolinker */
/**
 * @class Autolinker.matcher.Email
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find email matches in an input string.
 *
 * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.
 */
Autolinker.matcher.Email = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * The regular expression to match email addresses. Example match:
	 *
	 *     person@place.com
	 *
	 * @private
	 * @property {RegExp} matcherRegex
	 */
	matcherRegex : (function() {
		var alphaNumericChars = Autolinker.RegexLib.alphaNumericCharsStr,
		    emailRegex = new RegExp( '[' + alphaNumericChars + '\\-_\';:&=+$.,]+@' ),  // something@ for email addresses (a.k.a. local-part)
			domainNameRegex = Autolinker.RegexLib.domainNameRegex,
			tldRegex = Autolinker.tldRegex;  // match our known top level domains (TLDs)

		return new RegExp( [
			emailRegex.source,
			domainNameRegex.source,
			'\\.', tldRegex.source   // '.com', '.net', etc
		].join( "" ), 'gi' );
	} )(),


	/**
	 * @inheritdoc
	 */
	parseMatches : function( text ) {
		var matcherRegex = this.matcherRegex,
		    tagBuilder = this.tagBuilder,
		    matches = [],
		    match;

		while( ( match = matcherRegex.exec( text ) ) !== null ) {
			var matchedText = match[ 0 ];

			matches.push( new Autolinker.match.Email( {
				tagBuilder  : tagBuilder,
				matchedText : matchedText,
				offset      : match.index,
				email       : matchedText
			} ) );
		}

		return matches;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.matcher.Hashtag
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find Hashtag matches in an input string.
 */
Autolinker.matcher.Hashtag = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * @cfg {String} serviceName
	 *
	 * The service to point hashtag matches to. See {@link Autolinker#hashtag}
	 * for available values.
	 */


	/**
	 * The regular expression to match Hashtags. Example match:
	 *
	 *     #asdf
	 *
	 * @private
	 * @property {RegExp} matcherRegex
	 */
	matcherRegex : new RegExp( '#[_' + Autolinker.RegexLib.alphaNumericCharsStr + ']{1,139}', 'g' ),

	/**
	 * The regular expression to use to check the character before a username match to
	 * make sure we didn't accidentally match an email address.
	 *
	 * For example, the string "asdf@asdf.com" should not match "@asdf" as a username.
	 *
	 * @private
	 * @property {RegExp} nonWordCharRegex
	 */
	nonWordCharRegex : new RegExp( '[^' + Autolinker.RegexLib.alphaNumericCharsStr + ']' ),


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance,
	 *   specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.matcher.Matcher.prototype.constructor.call( this, cfg );

		this.serviceName = cfg.serviceName;
	},


	/**
	 * @inheritdoc
	 */
	parseMatches : function( text ) {
		var matcherRegex = this.matcherRegex,
		    nonWordCharRegex = this.nonWordCharRegex,
		    serviceName = this.serviceName,
		    tagBuilder = this.tagBuilder,
		    matches = [],
		    match;

		while( ( match = matcherRegex.exec( text ) ) !== null ) {
			var offset = match.index,
			    prevChar = text.charAt( offset - 1 );

			// If we found the match at the beginning of the string, or we found the match
			// and there is a whitespace char in front of it (meaning it is not a '#' char
			// in the middle of a word), then it is a hashtag match.
			if( offset === 0 || nonWordCharRegex.test( prevChar ) ) {
				var matchedText = match[ 0 ],
				    hashtag = match[ 0 ].slice( 1 );  // strip off the '#' character at the beginning

				matches.push( new Autolinker.match.Hashtag( {
					tagBuilder  : tagBuilder,
					matchedText : matchedText,
					offset      : offset,
					serviceName : serviceName,
					hashtag     : hashtag
				} ) );
			}
		}

		return matches;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.matcher.Phone
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find Phone number matches in an input string.
 *
 * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more
 * details.
 */
Autolinker.matcher.Phone = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * The regular expression to match Phone numbers. Example match:
	 *
	 *     (123) 456-7890
	 *
	 * This regular expression has the following capturing groups:
	 *
	 * 1. The prefixed '+' sign, if there is one.
	 *
	 * @private
	 * @property {RegExp} matcherRegex
	 */
    matcherRegex : /(?:(\+)?\d{1,3}[-\040.]?)?\(?\d{3}\)?[-\040.]?\d{3}[-\040.]?\d{4}([,;]*[0-9]+#?)*/g,    
    
    // ex: (123) 456-7890, 123 456 7890, 123-456-7890, +18004441234,,;,10226420346#, 
    // +1 (800) 444 1234, 10226420346#, 1-800-444-1234,1022,64,20346#

	/**
	 * @inheritdoc
	 */
	parseMatches: function(text) {
		var matcherRegex = this.matcherRegex,
			tagBuilder = this.tagBuilder,
			matches = [],
			match;

		while ((match = matcherRegex.exec(text)) !== null) {
			// Remove non-numeric values from phone number string
			var matchedText = match[0],
				cleanNumber = matchedText.replace(/[^0-9,;#]/g, ''), // strip out non-digit characters exclude comma semicolon and #
				plusSign = !!match[1]; // match[ 1 ] is the prefixed plus sign, if there is one
			if (/\D/.test(match[2]) && /\D/.test(matchedText)) {
    			matches.push(new Autolinker.match.Phone({
    				tagBuilder: tagBuilder,
    				matchedText: matchedText,
    				offset: match.index,
    				number: cleanNumber,
    				plusSign: plusSign
    			}));
            }
		}

		return matches;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.matcher.Mention
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find/replace username matches in an input string.
 */
Autolinker.matcher.Mention = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * Hash of regular expression to match username handles. Example match:
	 *
	 *     @asdf
	 *
	 * @private
	 * @property {Object} matcherRegexes
	 */
	matcherRegexes : {
		"twitter": new RegExp( '@[_' + Autolinker.RegexLib.alphaNumericCharsStr + ']{1,20}', 'g' ),
		"instagram": new RegExp( '@[_.' + Autolinker.RegexLib.alphaNumericCharsStr + ']{1,50}', 'g' )
	},

	/**
	 * The regular expression to use to check the character before a username match to
	 * make sure we didn't accidentally match an email address.
	 *
	 * For example, the string "asdf@asdf.com" should not match "@asdf" as a username.
	 *
	 * @private
	 * @property {RegExp} nonWordCharRegex
	 */
	nonWordCharRegex : new RegExp( '[^' + Autolinker.RegexLib.alphaNumericCharsStr + ']' ),


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance,
	 *   specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.matcher.Matcher.prototype.constructor.call( this, cfg );

		this.serviceName = cfg.serviceName;
	},


	/**
	 * @inheritdoc
	 */
	parseMatches : function( text ) {
		var matcherRegex = this.matcherRegexes[this.serviceName],
		    nonWordCharRegex = this.nonWordCharRegex,
		    serviceName = this.serviceName,
		    tagBuilder = this.tagBuilder,
		    matches = [],
		    match;

		if (!matcherRegex) {
			return matches;
		}

		while( ( match = matcherRegex.exec( text ) ) !== null ) {
			var offset = match.index,
			    prevChar = text.charAt( offset - 1 );

			// If we found the match at the beginning of the string, or we found the match
			// and there is a whitespace char in front of it (meaning it is not an email
			// address), then it is a username match.
			if( offset === 0 || nonWordCharRegex.test( prevChar ) ) {
				var matchedText = match[ 0 ].replace(/\.+$/g, ''), // strip off trailing .
				    mention = matchedText.slice( 1 );  // strip off the '@' character at the beginning

				matches.push( new Autolinker.match.Mention( {
					tagBuilder    : tagBuilder,
					matchedText   : matchedText,
					offset        : offset,
					serviceName   : serviceName,
					mention       : mention
				} ) );
			}
		}

		return matches;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.matcher.Url
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find URL matches in an input string.
 *
 * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.
 */
Autolinker.matcher.Url = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * @cfg {Object} stripPrefix (required)
	 *
	 * The Object form of {@link Autolinker#cfg-stripPrefix}.
	 */

	/**
	 * @cfg {Boolean} stripTrailingSlash (required)
	 * @inheritdoc Autolinker#stripTrailingSlash
	 */


	/**
	 * @private
	 * @property {RegExp} matcherRegex
	 *
	 * The regular expression to match URLs with an optional scheme, port
	 * number, path, query string, and hash anchor.
	 *
	 * Example matches:
	 *
	 *     http://google.com
	 *     www.google.com
	 *     google.com/path/to/file?q1=1&q2=2#myAnchor
	 *
	 *
	 * This regular expression will have the following capturing groups:
	 *
	 * 1.  Group that matches a scheme-prefixed URL (i.e. 'http://google.com').
	 *     This is used to match scheme URLs with just a single word, such as
	 *     'http://localhost', where we won't double check that the domain name
	 *     has at least one dot ('.') in it.
	 * 2.  Group that matches a 'www.' prefixed URL. This is only matched if the
	 *     'www.' text was not prefixed by a scheme (i.e.: not prefixed by
	 *     'http://', 'ftp:', etc.)
	 * 3.  A protocol-relative ('//') match for the case of a 'www.' prefixed
	 *     URL. Will be an empty string if it is not a protocol-relative match.
	 *     We need to know the character before the '//' in order to determine
	 *     if it is a valid match or the // was in a string we don't want to
	 *     auto-link.
	 * 4.  Group that matches a known TLD (top level domain), when a scheme
	 *     or 'www.'-prefixed domain is not matched.
	 * 5.  A protocol-relative ('//') match for the case of a known TLD prefixed
	 *     URL. Will be an empty string if it is not a protocol-relative match.
	 *     See #3 for more info.
	 */
	matcherRegex : (function() {
		var schemeRegex = /(?:[A-Za-z][-.+A-Za-z0-9]*:(?![A-Za-z][-.+A-Za-z0-9]*:\/\/)(?!\d+\/?)(?:\/\/)?)/,  // match protocol, allow in format "http://" or "mailto:". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match "link:"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)
		    wwwRegex = /(?:www\.)/,                  // starting with 'www.'
		    domainNameRegex = Autolinker.RegexLib.domainNameRegex,
		    tldRegex = Autolinker.tldRegex,  // match our known top level domains (TLDs)
		    alphaNumericCharsStr = Autolinker.RegexLib.alphaNumericCharsStr,

		    // Allow optional path, query string, and hash anchor, not ending in the following characters: "?!:,.;"
		    // http://blog.codinghorror.com/the-problem-with-urls/
		    urlSuffixRegex = new RegExp( '[/?#](?:[' + alphaNumericCharsStr + '\\-+&@#/%=~_()|\'$*\\[\\]?!:,.;\u2713]*[' + alphaNumericCharsStr + '\\-+&@#/%=~_()|\'$*\\[\\]\u2713])?' );

		return new RegExp( [
			'(?:', // parens to cover match for scheme (optional), and domain
				'(',  // *** Capturing group $1, for a scheme-prefixed url (ex: http://google.com)
					schemeRegex.source,
					domainNameRegex.source,
				')',

				'|',

				'(',  // *** Capturing group $2, for a 'www.' prefixed url (ex: www.google.com)
					'(//)?',  // *** Capturing group $3 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character (handled later)
					wwwRegex.source,
					domainNameRegex.source,
				')',

				'|',

				'(',  // *** Capturing group $4, for known a TLD url (ex: google.com)
					'(//)?',  // *** Capturing group $5 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character (handled later)
					domainNameRegex.source + '\\.',
					tldRegex.source,
					'(?![-' + alphaNumericCharsStr + '])', // TLD not followed by a letter, behaves like unicode-aware \b
				')',
			')',

			'(?::[0-9]+)?', // port

			'(?:' + urlSuffixRegex.source + ')?'  // match for path, query string, and/or hash anchor - optional
		].join( "" ), 'gi' );
	} )(),


	/**
	 * A regular expression to use to check the character before a protocol-relative
	 * URL match. We don't want to match a protocol-relative URL if it is part
	 * of another word.
	 *
	 * For example, we want to match something like "Go to: //google.com",
	 * but we don't want to match something like "abc//google.com"
	 *
	 * This regular expression is used to test the character before the '//'.
	 *
	 * @private
	 * @type {RegExp} wordCharRegExp
	 */
	wordCharRegExp : new RegExp( '[' + Autolinker.RegexLib.alphaNumericCharsStr + ']' ),


	/**
	 * The regular expression to match opening parenthesis in a URL match.
	 *
	 * This is to determine if we have unbalanced parenthesis in the URL, and to
	 * drop the final parenthesis that was matched if so.
	 *
	 * Ex: The text "(check out: wikipedia.com/something_(disambiguation))"
	 * should only autolink the inner "wikipedia.com/something_(disambiguation)"
	 * part, so if we find that we have unbalanced parenthesis, we will drop the
	 * last one for the match.
	 *
	 * @private
	 * @property {RegExp}
	 */
	openParensRe : /\(/g,

	/**
	 * The regular expression to match closing parenthesis in a URL match. See
	 * {@link #openParensRe} for more information.
	 *
	 * @private
	 * @property {RegExp}
	 */
	closeParensRe : /\)/g,


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance,
	 *   specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.matcher.Matcher.prototype.constructor.call( this, cfg );

		if( cfg.stripPrefix == null ) throw new Error( '`stripPrefix` cfg required' );
		if( cfg.stripTrailingSlash == null ) throw new Error( '`stripTrailingSlash` cfg required' );

		this.stripPrefix = cfg.stripPrefix;
		this.stripTrailingSlash = cfg.stripTrailingSlash;
	},


	/**
	 * @inheritdoc
	 */
	parseMatches : function( text ) {
		var matcherRegex = this.matcherRegex,
		    stripPrefix = this.stripPrefix,
		    stripTrailingSlash = this.stripTrailingSlash,
		    tagBuilder = this.tagBuilder,
		    matches = [],
		    match;

		while( ( match = matcherRegex.exec( text ) ) !== null ) {
			var matchStr = match[ 0 ],
			    schemeUrlMatch = match[ 1 ],
			    wwwUrlMatch = match[ 2 ],
			    wwwProtocolRelativeMatch = match[ 3 ],
			    //tldUrlMatch = match[ 4 ],  -- not needed at the moment
			    tldProtocolRelativeMatch = match[ 5 ],
			    offset = match.index,
			    protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,
				prevChar = text.charAt( offset - 1 );

			if( !Autolinker.matcher.UrlMatchValidator.isValid( matchStr, schemeUrlMatch ) ) {
				continue;
			}

			// If the match is preceded by an '@' character, then it is either
			// an email address or a username. Skip these types of matches.
			if( offset > 0 && prevChar === '@' ) {
				continue;
			}

			// If it's a protocol-relative '//' match, but the character before the '//'
			// was a word character (i.e. a letter/number), then we found the '//' in the
			// middle of another word (such as "asdf//asdf.com"). In this case, skip the
			// match.
			if( offset > 0 && protocolRelativeMatch && this.wordCharRegExp.test( prevChar ) ) {
				continue;
			}

			if( /\?$/.test(matchStr) ) {
				matchStr = matchStr.substr(0, matchStr.length-1);
			}

			// Handle a closing parenthesis at the end of the match, and exclude
			// it if there is not a matching open parenthesis in the match
			// itself.
			if( this.matchHasUnbalancedClosingParen( matchStr ) ) {
				matchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing ")"
			} else {
				// Handle an invalid character after the TLD
				var pos = this.matchHasInvalidCharAfterTld( matchStr, schemeUrlMatch );
				if( pos > -1 ) {
					matchStr = matchStr.substr( 0, pos ); // remove the trailing invalid chars
				}
			}

			var urlMatchType = schemeUrlMatch ? 'scheme' : ( wwwUrlMatch ? 'www' : 'tld' ),
			    protocolUrlMatch = !!schemeUrlMatch;

			matches.push( new Autolinker.match.Url( {
				tagBuilder            : tagBuilder,
				matchedText           : matchStr,
				offset                : offset,
				urlMatchType          : urlMatchType,
				url                   : matchStr,
				protocolUrlMatch      : protocolUrlMatch,
				protocolRelativeMatch : !!protocolRelativeMatch,
				stripPrefix           : stripPrefix,
				stripTrailingSlash    : stripTrailingSlash
			} ) );
		}

		return matches;
	},


	/**
	 * Determines if a match found has an unmatched closing parenthesis. If so,
	 * this parenthesis will be removed from the match itself, and appended
	 * after the generated anchor tag.
	 *
	 * A match may have an extra closing parenthesis at the end of the match
	 * because the regular expression must include parenthesis for URLs such as
	 * "wikipedia.com/something_(disambiguation)", which should be auto-linked.
	 *
	 * However, an extra parenthesis *will* be included when the URL itself is
	 * wrapped in parenthesis, such as in the case of "(wikipedia.com/something_(disambiguation))".
	 * In this case, the last closing parenthesis should *not* be part of the
	 * URL itself, and this method will return `true`.
	 *
	 * @private
	 * @param {String} matchStr The full match string from the {@link #matcherRegex}.
	 * @return {Boolean} `true` if there is an unbalanced closing parenthesis at
	 *   the end of the `matchStr`, `false` otherwise.
	 */
	matchHasUnbalancedClosingParen : function( matchStr ) {
		var lastChar = matchStr.charAt( matchStr.length - 1 );

		if( lastChar === ')' ) {
			var openParensMatch = matchStr.match( this.openParensRe ),
			    closeParensMatch = matchStr.match( this.closeParensRe ),
			    numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,
			    numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;

			if( numOpenParens < numCloseParens ) {
				return true;
			}
		}

		return false;
	},


	/**
	 * Determine if there's an invalid character after the TLD in a URL. Valid
	 * characters after TLD are ':/?#'. Exclude scheme matched URLs from this
	 * check.
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} schemeUrlMatch The match URL string for a scheme
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @return {Number} the position where the invalid character was found. If
	 *   no such character was found, returns -1
	 */
	matchHasInvalidCharAfterTld : function( urlMatch, schemeUrlMatch ) {
		if( !urlMatch ) {
			return -1;
		}

		var offset = 0;
		if ( schemeUrlMatch ) {
			offset = urlMatch.indexOf(':');
			urlMatch = urlMatch.slice(offset);
		}

		var alphaNumeric = Autolinker.RegexLib.alphaNumericCharsStr;

		var re = new RegExp("^((.?\/\/)?[-." + alphaNumeric + "]*[-" + alphaNumeric + "]\\.[-" + alphaNumeric + "]+)");
		var res = re.exec( urlMatch );
		if ( res === null ) {
			return -1;
		}

		offset += res[1].length;
		urlMatch = urlMatch.slice(res[1].length);
		if (/^[^-.A-Za-z0-9:\/?#]/.test(urlMatch)) {
			return offset;
		}

		return -1;
	}

} );

/*global Autolinker */
/*jshint scripturl:true */
/**
 * @private
 * @class Autolinker.matcher.UrlMatchValidator
 * @singleton
 *
 * Used by Autolinker to filter out false URL positives from the
 * {@link Autolinker.matcher.Url UrlMatcher}.
 *
 * Due to the limitations of regular expressions (including the missing feature
 * of look-behinds in JS regular expressions), we cannot always determine the
 * validity of a given match. This class applies a bit of additional logic to
 * filter out any false positives that have been matched by the
 * {@link Autolinker.matcher.Url UrlMatcher}.
 */
Autolinker.matcher.UrlMatchValidator = {

	/**
	 * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'
	 *
	 * @private
	 * @property {RegExp} hasFullProtocolRegex
	 */
	hasFullProtocolRegex : /^[A-Za-z][-.+A-Za-z0-9]*:\/\//,

	/**
	 * Regex to find the URI scheme, such as 'mailto:'.
	 *
	 * This is used to filter out 'javascript:' and 'vbscript:' schemes.
	 *
	 * @private
	 * @property {RegExp} uriSchemeRegex
	 */
	uriSchemeRegex : /^[A-Za-z][-.+A-Za-z0-9]*:/,

	/**
	 * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')
	 *
	 * @private
	 * @property {RegExp} hasWordCharAfterProtocolRegex
	 */
	hasWordCharAfterProtocolRegex : new RegExp(":[^\\s]*?[" + Autolinker.RegexLib.alphaCharsStr + "]"),

	/**
	 * Regex to determine if the string is a valid IP address
	 *
	 * @private
	 * @property {RegExp} ipRegex
	 */
	ipRegex: /[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?(:[0-9]*)?\/?$/,

	/**
	 * Determines if a given URL match found by the {@link Autolinker.matcher.Url UrlMatcher}
	 * is valid. Will return `false` for:
	 *
	 * 1) URL matches which do not have at least have one period ('.') in the
	 *    domain name (effectively skipping over matches like "abc:def").
	 *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')
	 * 2) URL matches which do not have at least one word character in the
	 *    domain name (effectively skipping over matches like "git:1.0").
	 * 3) A protocol-relative url match (a URL beginning with '//') whose
	 *    previous character is a word character (effectively skipping over
	 *    strings like "abc//google.com")
	 *
	 * Otherwise, returns `true`.
	 *
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @return {Boolean} `true` if the match given is valid and should be
	 *   processed, or `false` if the match is invalid and/or should just not be
	 *   processed.
	 */
	isValid : function( urlMatch, protocolUrlMatch ) {
		if(
			( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||
			this.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||    // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')
			(this.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) && // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like "git:1.0"
			   !this.isValidIpAddress( urlMatch )) || // Except if it's an IP address
			this.containsMultipleDots( urlMatch )
		) {
			return false;
		}

		return true;
	},


	isValidIpAddress : function ( uriSchemeMatch ) {
		var newRegex = new RegExp(this.hasFullProtocolRegex.source + this.ipRegex.source);
		var uriScheme = uriSchemeMatch.match( newRegex );

		return uriScheme !== null;
	},

	containsMultipleDots : function ( urlMatch ) {
		return urlMatch.indexOf("..") > -1;
	},

	/**
	 * Determines if the URI scheme is a valid scheme to be autolinked. Returns
	 * `false` if the scheme is 'javascript:' or 'vbscript:'
	 *
	 * @private
	 * @param {String} uriSchemeMatch The match URL string for a full URI scheme
	 *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.
	 * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.
	 */
	isValidUriScheme : function( uriSchemeMatch ) {
		var uriScheme = uriSchemeMatch.match( this.uriSchemeRegex )[ 0 ].toLowerCase();

		return ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );
	},


	/**
	 * Determines if a URL match does not have either:
	 *
	 * a) a full protocol (i.e. 'http://'), or
	 * b) at least one dot ('.') in the domain name (for a non-full-protocol
	 *    match).
	 *
	 * Either situation is considered an invalid URL (ex: 'git:d' does not have
	 * either the '://' part, or at least one dot in the domain name. If the
	 * match was 'git:abc.com', we would consider this valid.)
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @return {Boolean} `true` if the URL match does not have a full protocol,
	 *   or at least one dot ('.') in a non-full-protocol match.
	 */
	urlMatchDoesNotHaveProtocolOrDot : function( urlMatch, protocolUrlMatch ) {
		return ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );
	},


	/**
	 * Determines if a URL match does not have at least one word character after
	 * the protocol (i.e. in the domain name).
	 *
	 * At least one letter character must exist in the domain name after a
	 * protocol match. Ex: skip over something like "git:1.0"
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we
	 *   have a protocol in the URL string, in order to check for a word
	 *   character after the protocol separator (':').
	 * @return {Boolean} `true` if the URL match does not have at least one word
	 *   character in it after the protocol, `false` otherwise.
	 */
	urlMatchDoesNotHaveAtLeastOneWordChar : function( urlMatch, protocolUrlMatch ) {
		if( urlMatch && protocolUrlMatch ) {
			return !this.hasWordCharAfterProtocolRegex.test( urlMatch );
		} else {
			return false;
		}
	}

};

/*global Autolinker */
/**
 * A truncation feature where the ellipsis will be placed at the end of the URL.
 *
 * @param {String} anchorText
 * @param {Number} truncateLen The maximum length of the truncated output URL string.
 * @param {String} ellipsisChars The characters to place within the url, e.g. "..".
 * @return {String} The truncated URL.
 */
Autolinker.truncate.TruncateEnd = function(anchorText, truncateLen, ellipsisChars){
	return Autolinker.Util.ellipsis( anchorText, truncateLen, ellipsisChars );
};

/*global Autolinker */
/**
 * Date: 2015-10-05
 * Author: Kasper Søfren <soefritz@gmail.com> (https://github.com/kafoso)
 *
 * A truncation feature, where the ellipsis will be placed in the dead-center of the URL.
 *
 * @param {String} url             A URL.
 * @param {Number} truncateLen     The maximum length of the truncated output URL string.
 * @param {String} ellipsisChars   The characters to place within the url, e.g. "..".
 * @return {String} The truncated URL.
 */
Autolinker.truncate.TruncateMiddle = function(url, truncateLen, ellipsisChars){
  if (url.length <= truncateLen) {
    return url;
  }

  var ellipsisLengthBeforeParsing;
  var ellipsisLength;

  if(ellipsisChars == null) {
    ellipsisChars = '&hellip;';
    ellipsisLengthBeforeParsing = 8;
    ellipsisLength = 3;
  } else {
    ellipsisLengthBeforeParsing = ellipsisChars.length;
    ellipsisLength = ellipsisChars.length;
  }

  var availableLength = truncateLen - ellipsisLength;
  var end = "";
  if (availableLength > 0) {
    end = url.substr((-1)*Math.floor(availableLength/2));
  }
  return (url.substr(0, Math.ceil(availableLength/2)) + ellipsisChars + end).substr(0, availableLength + ellipsisLengthBeforeParsing);
};

/*global Autolinker */
/**
 * Date: 2015-10-05
 * Author: Kasper Søfren <soefritz@gmail.com> (https://github.com/kafoso)
 *
 * A truncation feature, where the ellipsis will be placed at a section within
 * the URL making it still somewhat human readable.
 *
 * @param {String} url						 A URL.
 * @param {Number} truncateLen		 The maximum length of the truncated output URL string.
 * @param {String} ellipsisChars	 The characters to place within the url, e.g. "...".
 * @return {String} The truncated URL.
 */
Autolinker.truncate.TruncateSmart = function(url, truncateLen, ellipsisChars){

	var ellipsisLengthBeforeParsing;
	var ellipsisLength;

	if(ellipsisChars == null) {
		ellipsisChars = '&hellip;';
		ellipsisLength = 3;
		ellipsisLengthBeforeParsing = 8;
	} else {
		ellipsisLength = ellipsisChars.length;
		ellipsisLengthBeforeParsing = ellipsisChars.length;
	}

	var parse_url = function(url){ // Functionality inspired by PHP function of same name
		var urlObj = {};
		var urlSub = url;
		var match = urlSub.match(/^([a-z]+):\/\//i);
		if (match) {
			urlObj.scheme = match[1];
			urlSub = urlSub.substr(match[0].length);
		}
		match = urlSub.match(/^(.*?)(?=(\?|#|\/|$))/i);
		if (match) {
			urlObj.host = match[1];
			urlSub = urlSub.substr(match[0].length);
		}
		match = urlSub.match(/^\/(.*?)(?=(\?|#|$))/i);
		if (match) {
			urlObj.path = match[1];
			urlSub = urlSub.substr(match[0].length);
		}
		match = urlSub.match(/^\?(.*?)(?=(#|$))/i);
		if (match) {
			urlObj.query = match[1];
			urlSub = urlSub.substr(match[0].length);
		}
		match = urlSub.match(/^#(.*?)$/i);
		if (match) {
			urlObj.fragment = match[1];
			//urlSub = urlSub.substr(match[0].length);  -- not used. Uncomment if adding another block.
		}
		return urlObj;
	};

	var buildUrl = function(urlObj){
		var url = "";
		if (urlObj.scheme && urlObj.host) {
			url += urlObj.scheme + "://";
		}
		if (urlObj.host) {
			url += urlObj.host;
		}
		if (urlObj.path) {
			url += "/" + urlObj.path;
		}
		if (urlObj.query) {
			url += "?" + urlObj.query;
		}
		if (urlObj.fragment) {
			url += "#" + urlObj.fragment;
		}
		return url;
	};

	var buildSegment = function(segment, remainingAvailableLength){
		var remainingAvailableLengthHalf = remainingAvailableLength/ 2,
				startOffset = Math.ceil(remainingAvailableLengthHalf),
				endOffset = (-1)*Math.floor(remainingAvailableLengthHalf),
				end = "";
		if (endOffset < 0) {
			end = segment.substr(endOffset);
		}
		return segment.substr(0, startOffset) + ellipsisChars + end;
	};
	if (url.length <= truncateLen) {
		return url;
	}
	var availableLength = truncateLen - ellipsisLength;
	var urlObj = parse_url(url);
	// Clean up the URL
	if (urlObj.query) {
		var matchQuery = urlObj.query.match(/^(.*?)(?=(\?|\#))(.*?)$/i);
		if (matchQuery) {
			// Malformed URL; two or more "?". Removed any content behind the 2nd.
			urlObj.query = urlObj.query.substr(0, matchQuery[1].length);
			url = buildUrl(urlObj);
		}
	}
	if (url.length <= truncateLen) {
		return url;
	}
	if (urlObj.host) {
		urlObj.host = urlObj.host.replace(/^www\./, "");
		url = buildUrl(urlObj);
	}
	if (url.length <= truncateLen) {
		return url;
	}
	// Process and build the URL
	var str = "";
	if (urlObj.host) {
		str += urlObj.host;
	}
	if (str.length >= availableLength) {
		if (urlObj.host.length == truncateLen) {
			return (urlObj.host.substr(0, (truncateLen - ellipsisLength)) + ellipsisChars).substr(0, availableLength + ellipsisLengthBeforeParsing);
		}
		return buildSegment(str, availableLength).substr(0, availableLength + ellipsisLengthBeforeParsing);
	}
	var pathAndQuery = "";
	if (urlObj.path) {
		pathAndQuery += "/" + urlObj.path;
	}
	if (urlObj.query) {
		pathAndQuery += "?" + urlObj.query;
	}
	if (pathAndQuery) {
		if ((str+pathAndQuery).length >= availableLength) {
			if ((str+pathAndQuery).length == truncateLen) {
				return (str + pathAndQuery).substr(0, truncateLen);
			}
			var remainingAvailableLength = availableLength - str.length;
			return (str + buildSegment(pathAndQuery, remainingAvailableLength)).substr(0, availableLength + ellipsisLengthBeforeParsing);
		} else {
			str += pathAndQuery;
		}
	}
	if (urlObj.fragment) {
		var fragment = "#"+urlObj.fragment;
		if ((str+fragment).length >= availableLength) {
			if ((str+fragment).length == truncateLen) {
				return (str + fragment).substr(0, truncateLen);
			}
			var remainingAvailableLength2 = availableLength - str.length;
			return (str + buildSegment(fragment, remainingAvailableLength2)).substr(0, availableLength + ellipsisLengthBeforeParsing);
		} else {
			str += fragment;
		}
	}
	if (urlObj.scheme && urlObj.host) {
		var scheme = urlObj.scheme + "://";
		if ((str+scheme).length < availableLength) {
			return (scheme + str).substr(0, truncateLen);
		}
	}
	if (str.length <= truncateLen) {
		return str;
	}
	var end = "";
	if (availableLength > 0) {
		end = str.substr((-1)*Math.floor(availableLength/2));
	}
	return (str.substr(0, Math.ceil(availableLength/2)) + ellipsisChars + end).substr(0, availableLength + ellipsisLengthBeforeParsing);
};

return Autolinker;
}));

},{}],69:[function(require,module,exports){
/*
 * JavaScript Load Image Exif Parser
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* global define */

;(function (factory) {
  'use strict'
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define(['./load-image', './load-image-meta'], factory)
  } else if (typeof module === 'object' && module.exports) {
    factory(require('./load-image'), require('./load-image-meta'))
  } else {
    // Browser globals:
    factory(window.loadImage)
  }
}(function (loadImage) {
  'use strict'

  loadImage.ExifMap = function () {
    return this
  }

  loadImage.ExifMap.prototype.map = {
    'Orientation': 0x0112
  }

  loadImage.ExifMap.prototype.get = function (id) {
    return this[id] || this[this.map[id]]
  }

  loadImage.getExifThumbnail = function (dataView, offset, length) {
    var hexData,
      i,
      b
    if (!length || offset + length > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid thumbnail data.')
      return
    }
    hexData = []
    for (i = 0; i < length; i += 1) {
      b = dataView.getUint8(offset + i)
      hexData.push((b < 16 ? '0' : '') + b.toString(16))
    }
    return 'data:image/jpeg,%' + hexData.join('%')
  }

  loadImage.exifTagTypes = {
    // byte, 8-bit unsigned int:
    1: {
      getValue: function (dataView, dataOffset) {
        return dataView.getUint8(dataOffset)
      },
      size: 1
    },
    // ascii, 8-bit byte:
    2: {
      getValue: function (dataView, dataOffset) {
        return String.fromCharCode(dataView.getUint8(dataOffset))
      },
      size: 1,
      ascii: true
    },
    // short, 16 bit int:
    3: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return dataView.getUint16(dataOffset, littleEndian)
      },
      size: 2
    },
    // long, 32 bit int:
    4: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return dataView.getUint32(dataOffset, littleEndian)
      },
      size: 4
    },
    // rational = two long values, first is numerator, second is denominator:
    5: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return dataView.getUint32(dataOffset, littleEndian) /
        dataView.getUint32(dataOffset + 4, littleEndian)
      },
      size: 8
    },
    // slong, 32 bit signed int:
    9: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return dataView.getInt32(dataOffset, littleEndian)
      },
      size: 4
    },
    // srational, two slongs, first is numerator, second is denominator:
    10: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return dataView.getInt32(dataOffset, littleEndian) /
        dataView.getInt32(dataOffset + 4, littleEndian)
      },
      size: 8
    }
  }
  // undefined, 8-bit byte, value depending on field:
  loadImage.exifTagTypes[7] = loadImage.exifTagTypes[1]

  loadImage.getExifValue = function (dataView, tiffOffset, offset, type, length, littleEndian) {
    var tagType = loadImage.exifTagTypes[type]
    var tagSize
    var dataOffset
    var values
    var i
    var str
    var c
    if (!tagType) {
      console.log('Invalid Exif data: Invalid tag type.')
      return
    }
    tagSize = tagType.size * length
    // Determine if the value is contained in the dataOffset bytes,
    // or if the value at the dataOffset is a pointer to the actual data:
    dataOffset = tagSize > 4
      ? tiffOffset + dataView.getUint32(offset + 8, littleEndian)
      : (offset + 8)
    if (dataOffset + tagSize > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid data offset.')
      return
    }
    if (length === 1) {
      return tagType.getValue(dataView, dataOffset, littleEndian)
    }
    values = []
    for (i = 0; i < length; i += 1) {
      values[i] = tagType.getValue(dataView, dataOffset + i * tagType.size, littleEndian)
    }
    if (tagType.ascii) {
      str = ''
      // Concatenate the chars:
      for (i = 0; i < values.length; i += 1) {
        c = values[i]
        // Ignore the terminating NULL byte(s):
        if (c === '\u0000') {
          break
        }
        str += c
      }
      return str
    }
    return values
  }

  loadImage.parseExifTag = function (dataView, tiffOffset, offset, littleEndian, data) {
    var tag = dataView.getUint16(offset, littleEndian)
    data.exif[tag] = loadImage.getExifValue(
      dataView,
      tiffOffset,
      offset,
      dataView.getUint16(offset + 2, littleEndian), // tag type
      dataView.getUint32(offset + 4, littleEndian), // tag length
      littleEndian
    )
  }

  loadImage.parseExifTags = function (dataView, tiffOffset, dirOffset, littleEndian, data) {
    var tagsNumber,
      dirEndOffset,
      i
    if (dirOffset + 6 > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid directory offset.')
      return
    }
    tagsNumber = dataView.getUint16(dirOffset, littleEndian)
    dirEndOffset = dirOffset + 2 + 12 * tagsNumber
    if (dirEndOffset + 4 > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid directory size.')
      return
    }
    for (i = 0; i < tagsNumber; i += 1) {
      this.parseExifTag(
        dataView,
        tiffOffset,
        dirOffset + 2 + 12 * i, // tag offset
        littleEndian,
        data
      )
    }
    // Return the offset to the next directory:
    return dataView.getUint32(dirEndOffset, littleEndian)
  }

  loadImage.parseExifData = function (dataView, offset, length, data, options) {
    if (options.disableExif) {
      return
    }
    var tiffOffset = offset + 10
    var littleEndian
    var dirOffset
    var thumbnailData
    // Check for the ASCII code for "Exif" (0x45786966):
    if (dataView.getUint32(offset + 4) !== 0x45786966) {
      // No Exif data, might be XMP data instead
      return
    }
    if (tiffOffset + 8 > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid segment size.')
      return
    }
    // Check for the two null bytes:
    if (dataView.getUint16(offset + 8) !== 0x0000) {
      console.log('Invalid Exif data: Missing byte alignment offset.')
      return
    }
    // Check the byte alignment:
    switch (dataView.getUint16(tiffOffset)) {
      case 0x4949:
        littleEndian = true
        break
      case 0x4D4D:
        littleEndian = false
        break
      default:
        console.log('Invalid Exif data: Invalid byte alignment marker.')
        return
    }
    // Check for the TIFF tag marker (0x002A):
    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002A) {
      console.log('Invalid Exif data: Missing TIFF marker.')
      return
    }
    // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:
    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian)
    // Create the exif object to store the tags:
    data.exif = new loadImage.ExifMap()
    // Parse the tags of the main image directory and retrieve the
    // offset to the next directory, usually the thumbnail directory:
    dirOffset = loadImage.parseExifTags(
      dataView,
      tiffOffset,
      tiffOffset + dirOffset,
      littleEndian,
      data
    )
    if (dirOffset && !options.disableExifThumbnail) {
      thumbnailData = {exif: {}}
      dirOffset = loadImage.parseExifTags(
        dataView,
        tiffOffset,
        tiffOffset + dirOffset,
        littleEndian,
        thumbnailData
      )
      // Check for JPEG Thumbnail offset:
      if (thumbnailData.exif[0x0201]) {
        data.exif.Thumbnail = loadImage.getExifThumbnail(
          dataView,
          tiffOffset + thumbnailData.exif[0x0201],
          thumbnailData.exif[0x0202] // Thumbnail data length
        )
      }
    }
    // Check for Exif Sub IFD Pointer:
    if (data.exif[0x8769] && !options.disableExifSub) {
      loadImage.parseExifTags(
        dataView,
        tiffOffset,
        tiffOffset + data.exif[0x8769], // directory offset
        littleEndian,
        data
      )
    }
    // Check for GPS Info IFD Pointer:
    if (data.exif[0x8825] && !options.disableExifGps) {
      loadImage.parseExifTags(
        dataView,
        tiffOffset,
        tiffOffset + data.exif[0x8825], // directory offset
        littleEndian,
        data
      )
    }
  }

  // Registers the Exif parser for the APP1 JPEG meta data segment:
  loadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData)

  // Adds the following properties to the parseMetaData callback data:
  // * exif: The exif tags, parsed by the parseExifData method

  // Adds the following options to the parseMetaData method:
  // * disableExif: Disables Exif parsing.
  // * disableExifThumbnail: Disables parsing of the Exif Thumbnail.
  // * disableExifSub: Disables parsing of the Exif Sub IFD.
  // * disableExifGps: Disables parsing of the Exif GPS Info IFD.
}))

},{"./load-image":73,"./load-image-meta":70}],70:[function(require,module,exports){
/*
 * JavaScript Load Image Meta
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Image meta data handling implementation
 * based on the help and contribution of
 * Achim Stöhr.
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* global define, Blob */

;(function (factory) {
  'use strict'
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define(['./load-image'], factory)
  } else if (typeof module === 'object' && module.exports) {
    factory(require('./load-image'))
  } else {
    // Browser globals:
    factory(window.loadImage)
  }
}(function (loadImage) {
  'use strict'

  var hasblobSlice = window.Blob && (Blob.prototype.slice ||
  Blob.prototype.webkitSlice || Blob.prototype.mozSlice)

  loadImage.blobSlice = hasblobSlice && function () {
    var slice = this.slice || this.webkitSlice || this.mozSlice
    return slice.apply(this, arguments)
  }

  loadImage.metaDataParsers = {
    jpeg: {
      0xffe1: [] // APP1 marker
    }
  }

  // Parses image meta data and calls the callback with an object argument
  // with the following properties:
  // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)
  // The options arguments accepts an object and supports the following properties:
  // * maxMetaDataSize: Defines the maximum number of bytes to parse.
  // * disableImageHead: Disables creating the imageHead property.
  loadImage.parseMetaData = function (file, callback, options, data) {
    options = options || {}
    data = data || {}
    var that = this
    // 256 KiB should contain all EXIF/ICC/IPTC segments:
    var maxMetaDataSize = options.maxMetaDataSize || 262144
    var noMetaData = !(window.DataView && file && file.size >= 12 &&
                      file.type === 'image/jpeg' && loadImage.blobSlice)
    if (noMetaData || !loadImage.readFile(
        loadImage.blobSlice.call(file, 0, maxMetaDataSize),
        function (e) {
          if (e.target.error) {
            // FileReader error
            console.log(e.target.error)
            callback(data)
            return
          }
          // Note on endianness:
          // Since the marker and length bytes in JPEG files are always
          // stored in big endian order, we can leave the endian parameter
          // of the DataView methods undefined, defaulting to big endian.
          var buffer = e.target.result
          var dataView = new DataView(buffer)
          var offset = 2
          var maxOffset = dataView.byteLength - 4
          var headLength = offset
          var markerBytes
          var markerLength
          var parsers
          var i
          // Check for the JPEG marker (0xffd8):
          if (dataView.getUint16(0) === 0xffd8) {
            while (offset < maxOffset) {
              markerBytes = dataView.getUint16(offset)
              // Search for APPn (0xffeN) and COM (0xfffe) markers,
              // which contain application-specific meta-data like
              // Exif, ICC and IPTC data and text comments:
              if ((markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||
                markerBytes === 0xfffe) {
                // The marker bytes (2) are always followed by
                // the length bytes (2), indicating the length of the
                // marker segment, which includes the length bytes,
                // but not the marker bytes, so we add 2:
                markerLength = dataView.getUint16(offset + 2) + 2
                if (offset + markerLength > dataView.byteLength) {
                  console.log('Invalid meta data: Invalid segment size.')
                  break
                }
                parsers = loadImage.metaDataParsers.jpeg[markerBytes]
                if (parsers) {
                  for (i = 0; i < parsers.length; i += 1) {
                    parsers[i].call(
                      that,
                      dataView,
                      offset,
                      markerLength,
                      data,
                      options
                    )
                  }
                }
                offset += markerLength
                headLength = offset
              } else {
                // Not an APPn or COM marker, probably safe to
                // assume that this is the end of the meta data
                break
              }
            }
            // Meta length must be longer than JPEG marker (2)
            // plus APPn marker (2), followed by length bytes (2):
            if (!options.disableImageHead && headLength > 6) {
              if (buffer.slice) {
                data.imageHead = buffer.slice(0, headLength)
              } else {
                // Workaround for IE10, which does not yet
                // support ArrayBuffer.slice:
                data.imageHead = new Uint8Array(buffer)
                  .subarray(0, headLength)
              }
            }
          } else {
            console.log('Invalid JPEG file: Missing JPEG marker.')
          }
          callback(data)
        },
        'readAsArrayBuffer'
      )) {
      callback(data)
    }
  }

  // Determines if meta data should be loaded automatically:
  loadImage.hasMetaOption = function (options) {
    return options && options.meta
  }

  var originalTransform = loadImage.transform
  loadImage.transform = function (img, options, callback, file, data) {
    if (loadImage.hasMetaOption(options)) {
      loadImage.parseMetaData(file, function (data) {
        originalTransform.call(loadImage, img, options, callback, file, data)
      }, options, data)
    } else {
      originalTransform.apply(loadImage, arguments)
    }
  }
}))

},{"./load-image":73}],71:[function(require,module,exports){
/*
 * JavaScript Load Image Orientation
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* global define */

;(function (factory) {
  'use strict'
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define(['./load-image', './load-image-scale', './load-image-meta'], factory)
  } else if (typeof module === 'object' && module.exports) {
    factory(
      require('./load-image'),
      require('./load-image-scale'),
      require('./load-image-meta')
    )
  } else {
    // Browser globals:
    factory(window.loadImage)
  }
}(function (loadImage) {
  'use strict'

  var originalHasCanvasOption = loadImage.hasCanvasOption
  var originalHasMetaOption = loadImage.hasMetaOption
  var originalTransformCoordinates = loadImage.transformCoordinates
  var originalGetTransformedOptions = loadImage.getTransformedOptions

  // Determines if the target image should be a canvas element:
  loadImage.hasCanvasOption = function (options) {
    return !!options.orientation ||
      originalHasCanvasOption.call(loadImage, options)
  }

  // Determines if meta data should be loaded automatically:
  loadImage.hasMetaOption = function (options) {
    return options && options.orientation === true ||
      originalHasMetaOption.call(loadImage, options)
  }

  // Transform image orientation based on
  // the given EXIF orientation option:
  loadImage.transformCoordinates = function (canvas, options) {
    originalTransformCoordinates.call(loadImage, canvas, options)
    var ctx = canvas.getContext('2d')
    var width = canvas.width
    var height = canvas.height
    var styleWidth = canvas.style.width
    var styleHeight = canvas.style.height
    var orientation = options.orientation
    if (!orientation || orientation > 8) {
      return
    }
    if (orientation > 4) {
      canvas.width = height
      canvas.height = width
      canvas.style.width = styleHeight
      canvas.style.height = styleWidth
    }
    switch (orientation) {
      case 2:
        // horizontal flip
        ctx.translate(width, 0)
        ctx.scale(-1, 1)
        break
      case 3:
        // 180° rotate left
        ctx.translate(width, height)
        ctx.rotate(Math.PI)
        break
      case 4:
        // vertical flip
        ctx.translate(0, height)
        ctx.scale(1, -1)
        break
      case 5:
        // vertical flip + 90 rotate right
        ctx.rotate(0.5 * Math.PI)
        ctx.scale(1, -1)
        break
      case 6:
        // 90° rotate right
        ctx.rotate(0.5 * Math.PI)
        ctx.translate(0, -height)
        break
      case 7:
        // horizontal flip + 90 rotate right
        ctx.rotate(0.5 * Math.PI)
        ctx.translate(width, -height)
        ctx.scale(-1, 1)
        break
      case 8:
        // 90° rotate left
        ctx.rotate(-0.5 * Math.PI)
        ctx.translate(-width, 0)
        break
    }
  }

  // Transforms coordinate and dimension options
  // based on the given orientation option:
  loadImage.getTransformedOptions = function (img, opts, data) {
    var options = originalGetTransformedOptions.call(loadImage, img, opts)
    var orientation = options.orientation
    var newOptions
    var i
    if (orientation === true && data && data.exif) {
      orientation = data.exif.get('Orientation')
    }
    if (!orientation || orientation > 8 || orientation === 1) {
      return options
    }
    newOptions = {}
    for (i in options) {
      if (options.hasOwnProperty(i)) {
        newOptions[i] = options[i]
      }
    }
    newOptions.orientation = orientation
    switch (orientation) {
      case 2:
        // horizontal flip
        newOptions.left = options.right
        newOptions.right = options.left
        break
      case 3:
        // 180° rotate left
        newOptions.left = options.right
        newOptions.top = options.bottom
        newOptions.right = options.left
        newOptions.bottom = options.top
        break
      case 4:
        // vertical flip
        newOptions.top = options.bottom
        newOptions.bottom = options.top
        break
      case 5:
        // vertical flip + 90 rotate right
        newOptions.left = options.top
        newOptions.top = options.left
        newOptions.right = options.bottom
        newOptions.bottom = options.right
        break
      case 6:
        // 90° rotate right
        newOptions.left = options.top
        newOptions.top = options.right
        newOptions.right = options.bottom
        newOptions.bottom = options.left
        break
      case 7:
        // horizontal flip + 90 rotate right
        newOptions.left = options.bottom
        newOptions.top = options.right
        newOptions.right = options.top
        newOptions.bottom = options.left
        break
      case 8:
        // 90° rotate left
        newOptions.left = options.bottom
        newOptions.top = options.left
        newOptions.right = options.top
        newOptions.bottom = options.right
        break
    }
    if (newOptions.orientation > 4) {
      newOptions.maxWidth = options.maxHeight
      newOptions.maxHeight = options.maxWidth
      newOptions.minWidth = options.minHeight
      newOptions.minHeight = options.minWidth
      newOptions.sourceWidth = options.sourceHeight
      newOptions.sourceHeight = options.sourceWidth
    }
    return newOptions
  }
}))

},{"./load-image":73,"./load-image-meta":70,"./load-image-scale":72}],72:[function(require,module,exports){
/*
 * JavaScript Load Image Scaling
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* global define */

;(function (factory) {
  'use strict'
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define(['./load-image'], factory)
  } else if (typeof module === 'object' && module.exports) {
    factory(require('./load-image'))
  } else {
    // Browser globals:
    factory(window.loadImage)
  }
}(function (loadImage) {
  'use strict'

  var originalTransform = loadImage.transform

  loadImage.transform = function (img, options, callback, file, data) {
    originalTransform.call(
      loadImage,
      loadImage.scale(img, options, data),
      options,
      callback,
      file,
      data
    )
  }

  // Transform image coordinates, allows to override e.g.
  // the canvas orientation based on the orientation option,
  // gets canvas, options passed as arguments:
  loadImage.transformCoordinates = function () {
    return
  }

  // Returns transformed options, allows to override e.g.
  // maxWidth, maxHeight and crop options based on the aspectRatio.
  // gets img, options passed as arguments:
  loadImage.getTransformedOptions = function (img, options) {
    var aspectRatio = options.aspectRatio
    var newOptions
    var i
    var width
    var height
    if (!aspectRatio) {
      return options
    }
    newOptions = {}
    for (i in options) {
      if (options.hasOwnProperty(i)) {
        newOptions[i] = options[i]
      }
    }
    newOptions.crop = true
    width = img.naturalWidth || img.width
    height = img.naturalHeight || img.height
    if (width / height > aspectRatio) {
      newOptions.maxWidth = height * aspectRatio
      newOptions.maxHeight = height
    } else {
      newOptions.maxWidth = width
      newOptions.maxHeight = width / aspectRatio
    }
    return newOptions
  }

  // Canvas render method, allows to implement a different rendering algorithm:
  loadImage.renderImageToCanvas = function (
    canvas,
    img,
    sourceX,
    sourceY,
    sourceWidth,
    sourceHeight,
    destX,
    destY,
    destWidth,
    destHeight
  ) {
    canvas.getContext('2d').drawImage(
      img,
      sourceX,
      sourceY,
      sourceWidth,
      sourceHeight,
      destX,
      destY,
      destWidth,
      destHeight
    )
    return canvas
  }

  // Determines if the target image should be a canvas element:
  loadImage.hasCanvasOption = function (options) {
    return options.canvas || options.crop || !!options.aspectRatio
  }

  // Scales and/or crops the given image (img or canvas HTML element)
  // using the given options.
  // Returns a canvas object if the browser supports canvas
  // and the hasCanvasOption method returns true or a canvas
  // object is passed as image, else the scaled image:
  loadImage.scale = function (img, options, data) {
    options = options || {}
    var canvas = document.createElement('canvas')
    var useCanvas = img.getContext ||
                    (loadImage.hasCanvasOption(options) && canvas.getContext)
    var width = img.naturalWidth || img.width
    var height = img.naturalHeight || img.height
    var destWidth = width
    var destHeight = height
    var maxWidth
    var maxHeight
    var minWidth
    var minHeight
    var sourceWidth
    var sourceHeight
    var sourceX
    var sourceY
    var pixelRatio
    var downsamplingRatio
    var tmp
    function scaleUp () {
      var scale = Math.max(
        (minWidth || destWidth) / destWidth,
        (minHeight || destHeight) / destHeight
      )
      if (scale > 1) {
        destWidth *= scale
        destHeight *= scale
      }
    }
    function scaleDown () {
      var scale = Math.min(
        (maxWidth || destWidth) / destWidth,
        (maxHeight || destHeight) / destHeight
      )
      if (scale < 1) {
        destWidth *= scale
        destHeight *= scale
      }
    }
    if (useCanvas) {
      options = loadImage.getTransformedOptions(img, options, data)
      sourceX = options.left || 0
      sourceY = options.top || 0
      if (options.sourceWidth) {
        sourceWidth = options.sourceWidth
        if (options.right !== undefined && options.left === undefined) {
          sourceX = width - sourceWidth - options.right
        }
      } else {
        sourceWidth = width - sourceX - (options.right || 0)
      }
      if (options.sourceHeight) {
        sourceHeight = options.sourceHeight
        if (options.bottom !== undefined && options.top === undefined) {
          sourceY = height - sourceHeight - options.bottom
        }
      } else {
        sourceHeight = height - sourceY - (options.bottom || 0)
      }
      destWidth = sourceWidth
      destHeight = sourceHeight
    }
    maxWidth = options.maxWidth
    maxHeight = options.maxHeight
    minWidth = options.minWidth
    minHeight = options.minHeight
    if (useCanvas && maxWidth && maxHeight && options.crop) {
      destWidth = maxWidth
      destHeight = maxHeight
      tmp = sourceWidth / sourceHeight - maxWidth / maxHeight
      if (tmp < 0) {
        sourceHeight = maxHeight * sourceWidth / maxWidth
        if (options.top === undefined && options.bottom === undefined) {
          sourceY = (height - sourceHeight) / 2
        }
      } else if (tmp > 0) {
        sourceWidth = maxWidth * sourceHeight / maxHeight
        if (options.left === undefined && options.right === undefined) {
          sourceX = (width - sourceWidth) / 2
        }
      }
    } else {
      if (options.contain || options.cover) {
        minWidth = maxWidth = maxWidth || minWidth
        minHeight = maxHeight = maxHeight || minHeight
      }
      if (options.cover) {
        scaleDown()
        scaleUp()
      } else {
        scaleUp()
        scaleDown()
      }
    }
    if (useCanvas) {
      pixelRatio = options.pixelRatio
      if (pixelRatio > 1) {
        canvas.style.width = destWidth + 'px'
        canvas.style.height = destHeight + 'px'
        destWidth *= pixelRatio
        destHeight *= pixelRatio
        canvas.getContext('2d').scale(pixelRatio, pixelRatio)
      }
      downsamplingRatio = options.downsamplingRatio
      if (downsamplingRatio > 0 && downsamplingRatio < 1 &&
            destWidth < sourceWidth && destHeight < sourceHeight) {
        while (sourceWidth * downsamplingRatio > destWidth) {
          canvas.width = sourceWidth * downsamplingRatio
          canvas.height = sourceHeight * downsamplingRatio
          loadImage.renderImageToCanvas(
            canvas,
            img,
            sourceX,
            sourceY,
            sourceWidth,
            sourceHeight,
            0,
            0,
            canvas.width,
            canvas.height
          )
          sourceX = 0
          sourceY = 0
          sourceWidth = canvas.width
          sourceHeight = canvas.height
          img = document.createElement('canvas')
          img.width = sourceWidth
          img.height = sourceHeight
          loadImage.renderImageToCanvas(
            img,
            canvas,
            0,
            0,
            sourceWidth,
            sourceHeight,
            0,
            0,
            sourceWidth,
            sourceHeight
          )
        }
      }
      canvas.width = destWidth
      canvas.height = destHeight
      loadImage.transformCoordinates(
        canvas,
        options
      )
      return loadImage.renderImageToCanvas(
        canvas,
        img,
        sourceX,
        sourceY,
        sourceWidth,
        sourceHeight,
        0,
        0,
        destWidth,
        destHeight
      )
    }
    img.width = destWidth
    img.height = destHeight
    return img
  }
}))

},{"./load-image":73}],73:[function(require,module,exports){
/*
 * JavaScript Load Image
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* global define, URL, webkitURL, FileReader */

;(function ($) {
  'use strict'

  // Loads an image for a given File object.
  // Invokes the callback with an img or optional canvas
  // element (if supported by the browser) as parameter:
  function loadImage (file, callback, options) {
    var img = document.createElement('img')
    var url
    img.onerror = function (event) {
      return loadImage.onerror(img, event, file, callback, options)
    }
    img.onload = function (event) {
      return loadImage.onload(img, event, file, callback, options)
    }
    if (typeof file === 'string') {
      loadImage.fetchBlob(file, function (blob) {
        if (blob) {
          file = blob
          url = loadImage.createObjectURL(file)
        } else {
          url = file
          if (options && options.crossOrigin) {
            img.crossOrigin = options.crossOrigin
          }
        }
        img.src = url
      }, options)
      return img
    } else if (loadImage.isInstanceOf('Blob', file) ||
        // Files are also Blob instances, but some browsers
        // (Firefox 3.6) support the File API but not Blobs:
        loadImage.isInstanceOf('File', file)) {
      url = img._objectURL = loadImage.createObjectURL(file)
      if (url) {
        img.src = url
        return img
      }
      return loadImage.readFile(file, function (e) {
        var target = e.target
        if (target && target.result) {
          img.src = target.result
        } else if (callback) {
          callback(e)
        }
      })
    }
  }
  // The check for URL.revokeObjectURL fixes an issue with Opera 12,
  // which provides URL.createObjectURL but doesn't properly implement it:
  var urlAPI = (window.createObjectURL && window) ||
                (window.URL && URL.revokeObjectURL && URL) ||
                (window.webkitURL && webkitURL)

  function revokeHelper (img, options) {
    if (img._objectURL && !(options && options.noRevoke)) {
      loadImage.revokeObjectURL(img._objectURL)
      delete img._objectURL
    }
  }

  // If the callback given to this function returns a blob, it is used as image
  // source instead of the original url and overrides the file argument used in
  // the onload and onerror event callbacks:
  loadImage.fetchBlob = function (url, callback, options) {
    callback()
  }

  loadImage.isInstanceOf = function (type, obj) {
    // Cross-frame instanceof check
    return Object.prototype.toString.call(obj) === '[object ' + type + ']'
  }

  loadImage.transform = function (img, options, callback, file, data) {
    callback(img, data)
  }

  loadImage.onerror = function (img, event, file, callback, options) {
    revokeHelper(img, options)
    if (callback) {
      callback.call(img, event)
    }
  }

  loadImage.onload = function (img, event, file, callback, options) {
    revokeHelper(img, options)
    if (callback) {
      loadImage.transform(img, options, callback, file, {})
    }
  }

  loadImage.createObjectURL = function (file) {
    return urlAPI ? urlAPI.createObjectURL(file) : false
  }

  loadImage.revokeObjectURL = function (url) {
    return urlAPI ? urlAPI.revokeObjectURL(url) : false
  }

  // Loads a given File object via FileReader interface,
  // invokes the callback with the event object (load or error).
  // The result can be read via event.target.result:
  loadImage.readFile = function (file, callback, method) {
    if (window.FileReader) {
      var fileReader = new FileReader()
      fileReader.onload = fileReader.onerror = callback
      method = method || 'readAsDataURL'
      if (fileReader[method]) {
        fileReader[method](file)
        return fileReader
      }
    }
    return false
  }

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return loadImage
    })
  } else if (typeof module === 'object' && module.exports) {
    module.exports = loadImage
  } else {
    $.loadImage = loadImage
  }
}(window))

},{}],74:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.Notify = global.Notify || {})));
}(this, function (exports) { 'use strict';

  var _objectWithoutProperties = (function (obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  })

  /*
   * Author: Alex Gibson
   * https://github.com/alexgibson/notify.js
   * License: MIT license
   */

  var N = window.Notification;

  function isFunction(item) {
      return typeof item === 'function';
  }

  function Notify(title) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


      if (typeof title !== 'string') {
          throw new Error('Notify(): first arg (title) must be a string.');
      }

      if (typeof options !== 'object') {
          throw new Error('Notify(): second arg (options) must be an object.');
      }

      var _options$notifyShow = options.notifyShow;
      var
      // Notify options
      notifyShow = _options$notifyShow === undefined ? null : _options$notifyShow;
      var _options$notifyClose = options.notifyClose;
      var notifyClose = _options$notifyClose === undefined ? null : _options$notifyClose;
      var _options$notifyClick = options.notifyClick;
      var notifyClick = _options$notifyClick === undefined ? null : _options$notifyClick;
      var _options$notifyError = options.notifyError;
      var notifyError = _options$notifyError === undefined ? null : _options$notifyError;
      var _options$closeOnClick = options.closeOnClick;
      var closeOnClick = _options$closeOnClick === undefined ? false : _options$closeOnClick;
      var _options$timeout = options.timeout;
      var timeout = _options$timeout === undefined ? null : _options$timeout;

      var rest = _objectWithoutProperties(options, ['notifyShow', 'notifyClose', 'notifyClick', 'notifyError', 'closeOnClick', 'timeout']);

      this.title = title;
      this.options = rest;
      this.permission = null;
      this.closeOnClick = closeOnClick;
      this.timeout = timeout;

      //callback when notification is displayed
      if (isFunction(notifyShow)) {
          this.onShowCallback = notifyShow;
      }

      //callback when notification is closed
      if (isFunction(notifyClose)) {
          this.onCloseCallback = notifyClose;
      }

      //callback when notification is clicked
      if (isFunction(notifyClick)) {
          this.onClickCallback = notifyClick;
      }

      //callback when notification throws error
      if (isFunction(notifyError)) {
          this.onErrorCallback = notifyError;
      }
  }

  // returns true if the browser supports Web Notifications
  // https://developers.google.com/web/updates/2015/05/Notifying-you-of-notificiation-changes
  // @param {perm} for test purposes only
  Notify.isSupported = function (perm) {
      if (!N || !N.requestPermission) {
          return false;
      }

      if (perm === 'granted' || N.permission === 'granted') {
          throw new Error('You must only call this before calling Notification.requestPermission(), otherwise this feature detect would trigger an actual notification!');
      }

      try {
          new N('');
      } catch (e) {
          if (e.name === 'TypeError') {
              return false;
          }
      }
      return true;
  };

  // true if the permission is not granted
  Notify.needsPermission = N && N.permission && N.permission === 'granted' ? false : true;

  // asks the user for permission to display notifications.  Then calls the callback functions is supplied.
  Notify.requestPermission = function (onPermissionGrantedCallback, onPermissionDeniedCallback) {
      N.requestPermission(function (perm) {
          switch (perm) {
              case 'granted':
                  Notify.needsPermission = false;
                  if (isFunction(onPermissionGrantedCallback)) {
                      onPermissionGrantedCallback();
                  }
                  break;
              case 'denied':
                  Notify.needsPermission = true;
                  if (isFunction(onPermissionDeniedCallback)) {
                      onPermissionDeniedCallback();
                  }
                  break;
          }
      });
  };

  Notify.prototype.show = function () {
      this.myNotify = new N(this.title, this.options);

      if (!this.options.requireInteraction && this.timeout && !isNaN(this.timeout)) {
          setTimeout(this.close.bind(this), this.timeout * 1000);
      }

      this.myNotify.addEventListener('show', this, false);
      this.myNotify.addEventListener('error', this, false);
      this.myNotify.addEventListener('close', this, false);
      this.myNotify.addEventListener('click', this, false);
  };

  Notify.prototype.onShowNotification = function (e) {
      if (this.onShowCallback) {
          this.onShowCallback(e);
      }
  };

  Notify.prototype.onCloseNotification = function (e) {
      if (this.onCloseCallback) {
          this.onCloseCallback(e);
      }
      this.destroy();
  };

  Notify.prototype.onClickNotification = function (e) {
      if (this.onClickCallback) {
          this.onClickCallback(e);
      }

      if (this.closeOnClick) {
          this.close();
      }
  };

  Notify.prototype.onErrorNotification = function (e) {
      if (this.onErrorCallback) {
          this.onErrorCallback(e);
      }
      this.destroy();
  };

  Notify.prototype.destroy = function () {
      this.myNotify.removeEventListener('show', this, false);
      this.myNotify.removeEventListener('error', this, false);
      this.myNotify.removeEventListener('close', this, false);
      this.myNotify.removeEventListener('click', this, false);
  };

  Notify.prototype.close = function () {
      this.myNotify.close();
  };

  Notify.prototype.handleEvent = function (e) {
      switch (e.type) {
          case 'show':
              this.onShowNotification(e);
              break;
          case 'close':
              this.onCloseNotification(e);
              break;
          case 'click':
              this.onClickNotification(e);
              break;
          case 'error':
              this.onErrorNotification(e);
              break;
      }
  };

  exports['default'] = Notify;

}));
},{}],75:[function(require,module,exports){
/* jshint node:true */

module.exports = {
    ":alarm_clock:": "\u23F0",
    ":anchor:": "\u2693",
    ":aquarius:": "\u2652",
    ":aries:": "\u2648",
    ":arrow_backward:": "\u25C0",
    ":arrow_double_down:": "\u23EC",
    ":arrow_double_up:": "\u23EB",
    ":arrow_down:": "\u2B07",
    ":arrow_forward:": "\u25B6",
    ":arrow_heading_down:": "\u2935",
    ":arrow_heading_up:": "\u2934",
    ":arrow_left:": "\u2B05",
    ":arrow_lower_left:": "\u2199",
    ":arrow_lower_right:": "\u2198",
    ":arrow_right:": "\u27A1",
    ":arrow_right_hook:": "\u21AA",
    ":arrow_up:": "\u2B06",
    ":arrow_up_down:": "\u2195",
    ":arrow_upper_left:": "\u2196",
    ":arrow_upper_right:": "\u2197",
    ":ballot_box_with_check:": "\u2611",
    ":bangbang:": "\u203C",
    ":cancer:": "\u264B",
    ":baseball:": "\u26BE",
    ":black_large_square:": "\u2B1B",
    ":black_medium_small_square:": "\u25FE",
    ":black_medium_square:": "\u25FC",
    ":black_nib:": "\u2712",
    ":black_small_square:": "\u25AA",
    ":black_circle:": "\u26AB",
    ":boat:": "\u26F5",
    ":capricorn:": "\u2651",
    ":church:": "\u26EA",
    ":cloud:": "\u2601",
    ":clubs:": "\u2663",
    ":coffee:": "\u2615",
    ":congratulations:": "\u3297",
    ":copyright:": "\u00A9",
    ":curly_loop:": "\u27B0",
    ":eight_pointed_black_star:": "\u2734",
    ":eight_spoked_asterisk:": "\u2733",
    ":diamonds:": "\u2666",
    ":email:": "\u2709",
    ":envelope:": "\u2709",
    ":exclamation:": "\u2757",
    ":fast_forward:": "\u23E9",
    ":fist:": "\u270A",
    ":fountain:": "\u26F2",
    ":fuelpump:": "\u26FD",
    ":gemini:": "\u264A",
    ":golf:": "\u26F3",
    ":grey_exclamation:": "\u2755",
    ":grey_question:": "\u2754",
    ":hand:": "\u270B",
    ":heart:": "\u2764",
    ":hearts:": "\u2665",
    ":heavy_check_mark:": "\u2714",
    ":heavy_division_sign:": "\u2797",
    ":heavy_exclamation_mark:": "\u2757",
    ":heavy_minus_sign:": "\u2796",
    ":heavy_multiplication_x:": "\u2716",
    ":heavy_plus_sign:": "\u2795",
    ":hotsprings:": "\u2668",
    ":hourglass:": "\u231B",
    ":hourglass_flowing_sand:": "\u23F3",
    ":information_source:": "\u2139",
    ":interrobang:": "\u2049",
    ":left_right_arrow:": "\u2194",
    ":leftwards_arrow_with_hook:": "\u21A9",
    ":leo:": "\u264C",
    ":libra:": "\u264E",
    ":loop:": "\u27BF",
    ":m:": "\u24C2",
    ":negative_squared_cross_mark:": "\u274E",
    ":no_entry:": "\u26D4",
    ":o:": "\u2B55",
    ":ophiuchus:": "\u26CE",
    ":part_alternation_mark:": "\u303D",
    ":partly_sunny:": "\u26C5",
    ":pencil2:": "\u270F",
    ":phone:": "\u260E",
    ":pisces:": "\u2653",
    ":point_up:": "\u261D",
    ":question:": "\u2753",
    ":raised_hand:": "\u270B",
    ":recycle:": "\u267B",
    ":registered:": "\u00AE",
    ":relaxed:": "\u263A",
    ":rewind:": "\u23EA",
    ":sagittarius:": "\u2650",
    ":sailboat:": "\u26F5",
    ":scissors:": "\u2702",
    ":scorpius:": "\u264F",
    ":secret:": "\u3299",
    ":snowflake:": "\u2744",
    ":snowman:": "\u26C4",
    ":soccer:": "\u26BD",
    ":spades:": "\u2660",
    ":sparkle:": "\u2747",
    ":sparkles:": "\u2728",
    ":star:": "\u2B50",
    ":sunny:": "\u2600",
    ":taurus:": "\u2649",
    ":telephone:": "\u260E",
    ":tent:": "\u26FA",
    ":tm:": "\u2122",
    ":umbrella:": "\u2614",
    ":v:": "\u270C",
    ":virgo:": "\u264D",
    ":warning:": "\u26A0",
    ":watch:": "\u231A",
    ":wavy_dash:": "\u3030",
    ":wheelchair:": "\u267F",
    ":white_check_mark:": "\u2705",
    ":white_circle:": "\u26AA",
    ":white_large_square:": "\u2B1C",
    ":white_medium_small_square:": "\u25FD",
    ":white_medium_square:": "\u25FB",
    ":white_small_square:": "\u25AB",
    ":x:": "\u274C",
    ":zap:": "\u26A1",
    ":airplane:": "\u2708",
    ":+1:": "👍",
    ":-1:": "👎",
    ":100:": "💯",
    ":1234:": "🔢",
    ":8ball:": "🎱",
    ":a:": "🅰",
    ":ab:": "🆎",
    ":abc:": "🔤",
    ":abcd:": "🔡",
    ":accept:": "🉑",
    ":aerial_tramway:": "🚡",
    ":alien:": "👽",
    ":ambulance:": "🚑",
    ":angel:": "👼",
    ":anger:": "💢",
    ":angry:": "😠",
    ":-||": "😠",
    ":@": "😠",
    ">:(": "😠",
    ":anguished:": "😧",
    ":ant:": "🐜",
    ":apple:": "🍎",
    ":arrow_down_small:": "🔽",
    ":arrow_up_small:": "🔼",
    ":arrows_clockwise:": "🔃",
    ":arrows_counterclockwise:": "🔄",
    ":art:": "🎨",
    ":articulated_lorry:": "🚛",
    ":astonished:": "😲",
    ":athletic_shoe:": "👟",
    ":atm:": "🏧",
    ":b:": "🅱",
    ":baby:": "👶",
    ":baby_bottle:": "🍼",
    ":baby_chick:": "🐤",
    ":baby_symbol:": "🚼",
    ":back:": "🔙",
    ":baggage_claim:": "🛄",
    ":balloon:": "🎈",
    ":bamboo:": "🎍",
    ":banana:": "🍌",
    ":bank:": "🏦",
    ":bar_chart:": "📊",
    ":barber:": "💈",
    ":basketball:": "🏀",
    ":bath:": "🛀",
    ":bathtub:": "🛁",
    ":battery:": "🔋",
    ":bear:": "🐻",
    ":bee:": "🐝",
    ":beer:": "🍺",
    ":beers:": "🍻",
    ":beetle:": "🐞",
    ":beginner:": "🔰",
    ":bell:": "🔔",
    ":bento:": "🍱",
    ":bicyclist:": "🚴",
    ":bike:": "🚲",
    ":bikini:": "👙",
    ":bird:": "🐦",
    ":birthday:": "🎂",
    ":black_joker:": "🃏",
    ":black_square_button:": "🔲",
    ":blossom:": "🌼",
    ":blowfish:": "🐡",
    ":blue_book:": "📘",
    ":blue_car:": "🚙",
    ":blue_heart:": "💙",
    ":blush:": "😊",
    ":$": "😊",
    ":boar:": "🐗",
    ":bomb:": "💣",
    ":book:": "📖",
    ":bookmark:": "🔖",
    ":bookmark_tabs:": "📑",
    ":books:": "📚",
    ":boom:": "💥",
    ":boot:": "👢",
    ":bouquet:": "💐",
    ":bow:": "🙇",
    ":bowling:": "🎳",
    ":boy:": "👦",
    ":bread:": "🍞",
    ":bride_with_veil:": "👰",
    ":bridge_at_night:": "🌉",
    ":briefcase:": "💼",
    ":broken_heart:": "💔",
    ":bug:": "🐛",
    ":bulb:": "💡",
    ":bullettrain_front:": "🚅",
    ":bullettrain_side:": "🚄",
    ":bus:": "🚌",
    ":busstop:": "🚏",
    ":bust_in_silhouette:": "👤",
    ":busts_in_silhouette:": "👥",
    ":cactus:": "🌵",
    ":cake:": "🍰",
    ":calendar:": "📆",
    ":calling:": "📲",
    ":camel:": "🐫",
    ":camera:": "📷",
    ":candy:": "🍬",
    ":capital_abcd:": "🔠",
    ":car:": "🚗",
    ":card_index:": "📇",
    ":carousel_horse:": "🎠",
    ":cat:": "🐱",
    ":cat2:": "🐈",
    ":cd:": "💿",
    ":chart:": "💹",
    ":chart_with_downwards_trend:": "📉",
    ":chart_with_upwards_trend:": "📈",
    ":checkered_flag:": "🏁",
    ":cherries:": "🍒",
    ":cherry_blossom:": "🌸",
    ":chestnut:": "🌰",
    ":chicken:": "🐔",
    ":children_crossing:": "🚸",
    ":chocolate_bar:": "🍫",
    ":christmas_tree:": "🎄",
    ":cinema:": "🎦",
    ":circus_tent:": "🎪",
    ":city_sunrise:": "🌇",
    ":city_sunset:": "🌆",
    ":cl:": "🆑",
    ":clap:": "👏",
    ":clapper:": "🎬",
    ":clipboard:": "📋",
    ":clock1:": "🕐",
    ":clock10:": "🕙",
    ":clock1030:": "🕥",
    ":clock11:": "🕚",
    ":clock1130:": "🕦",
    ":clock12:": "🕛",
    ":clock1230:": "🕧",
    ":clock130:": "🕜",
    ":clock2:": "🕑",
    ":clock230:": "🕝",
    ":clock3:": "🕒",
    ":clock330:": "🕞",
    ":clock4:": "🕓",
    ":clock430:": "🕟",
    ":clock5:": "🕔",
    ":clock530:": "🕠",
    ":clock6:": "🕕",
    ":clock630:": "🕡",
    ":clock7:": "🕖",
    ":clock730:": "🕢",
    ":clock8:": "🕗",
    ":clock830:": "🕣",
    ":clock9:": "🕘",
    ":clock930:": "🕤",
    ":closed_book:": "📕",
    ":closed_lock_with_key:": "🔐",
    ":closed_umbrella:": "🌂",
    ":cocktail:": "🍸",
    ":cold_sweat:": "😰",
    ":collision:": "💥",
    ":computer:": "💻",
    ":confetti_ball:": "🎊",
    ":confounded:": "😖",
    ":confused:": "😕",
    "%-)": "😕",
    "%)": "😕",
    ":construction:": "🚧",
    ":construction_worker:": "👷",
    ":convenience_store:": "🏪",
    ":cookie:": "🍪",
    ":cool:": "🆒",
    ":cop:": "👮",
    ":corn:": "🌽",
    ":couple:": "👫",
    ":couple_with_heart:": "💑",
    ":couplekiss:": "💏",
    ":cow:": "🐮",
    ":cow2:": "🐄",
    ":credit_card:": "💳",
    ":crocodile:": "🐊",
    ":crossed_flags:": "🎌",
    ":crown:": "👑",
    ":cry:": "😢",
    ":'(": "😢",
    ":-'(": "😢",
    ":crying_cat_face:": "😿",
    ":crystal_ball:": "🔮",
    ":cupid:": "💘",
    ":currency_exchange:": "💱",
    ":curry:": "🍛",
    ":custard:": "🍮",
    ":customs:": "🛃",
    ":cyclone:": "🌀",
    ":dancer:": "💃",
    ":dancers:": "👯",
    ":dango:": "🍡",
    ":dart:": "🎯",
    ":dash:": "💨",
    ":date:": "📅",
    ":deciduous_tree:": "🌳",
    ":department_store:": "🏬",
    ":diamond_shape_with_a_dot_inside:": "💠",
    ":disappointed:": "😞",
    ":disappointed_relieved:": "😥",
    ":dizzy:": "💫",
    ":dizzy_face:": "😵",
    ":do_not_litter:": "🚯",
    ":dog:": "🐶",
    ":dog2:": "🐕",
    ":dollar:": "💵",
    ":dolls:": "🎎",
    ":dolphin:": "🐬",
    ":door:": "🚪",
    ":doughnut:": "🍩",
    ":dragon:": "🐉",
    ":dragon_face:": "🐲",
    ":dress:": "👗",
    ":dromedary_camel:": "🐪",
    ":droplet:": "💧",
    ":dvd:": "📀",
    ":e-mail:": "📧",
    ":ear:": "👂",
    ":ear_of_rice:": "🌾",
    ":earth_africa:": "🌍",
    ":earth_americas:": "🌎",
    ":earth_asia:": "🌏",
    ":egg:": "🍳",
    ":eggplant:": "🍆",
    ":electric_plug:": "🔌",
    ":elephant:": "🐘",
    ":end:": "🔚",
    ":envelope_with_arrow:": "📩",
    ":euro:": "💶",
    ":european_castle:": "🏰",
    ":european_post_office:": "🏤",
    ":evergreen_tree:": "🌲",
    ":expressionless:": "😑",
    ":eyeglasses:": "👓",
    ":eyes:": "👀",
    ":facepunch:": "👊",
    ":factory:": "🏭",
    ":fallen_leaf:": "🍂",
    ":family:": "👪",
    ":fax:": "📠",
    ":fearful:": "😨",
    ":feet:": "🐾",
    ":ferris_wheel:": "🎡",
    ":file_folder:": "📁",
    ":fire:": "🔥",
    ":fire_engine:": "🚒",
    ":fireworks:": "🎆",
    ":first_quarter_moon:": "🌓",
    ":first_quarter_moon_with_face:": "🌛",
    ":fish:": "🐟",
    ":fish_cake:": "🍥",
    ":fishing_pole_and_fish:": "🎣",
    ":flags:": "🎏",
    ":flashlight:": "🔦",
    ":floppy_disk:": "💾",
    ":flower_playing_cards:": "🎴",
    ":flushed:": "😳",
    ":foggy:": "🌁",
    ":football:": "🏈",
    ":footprints:": "👣",
    ":fork_and_knife:": "🍴",
    ":four_leaf_clover:": "🍀",
    ":free:": "🆓",
    ":fried_shrimp:": "🍤",
    ":fries:": "🍟",
    ":frog:": "🐸",
    ":frowning:": "😦",
    ":(": "😦",
    ":-(": "😦",
    ":-[": "😦",
    ":[": "😦",
    ":full_moon:": "🌕",
    ":full_moon_with_face:": "🌝",
    ":game_die:": "🎲",
    ":gem:": "💎",
    ":ghost:": "👻",
    ":gift:": "🎁",
    ":gift_heart:": "💝",
    ":girl:": "👧",
    ":globe_with_meridians:": "🌐",
    ":goat:": "🐐",
    ":grapes:": "🍇",
    ":green_apple:": "🍏",
    ":green_book:": "📗",
    ":green_heart:": "💚",
    ":grimacing:": "😬",
    ":grin:": "😁",
    "xD": "😁",
    "x-D": "😁",
    "XD": "😁",
    "X-D": "😁",
    ":grinning:": "😀",
    ":guardsman:": "💂",
    ":guitar:": "🎸",
    ":gun:": "🔫",
    ":haircut:": "💇",
    ":hamburger:": "🍔",
    ":hammer:": "🔨",
    ":hamster:": "🐹",
    ":handbag:": "👜",
    ":hankey:": "💩",
    ":hatched_chick:": "🐥",
    ":hatching_chick:": "🐣",
    ":headphones:": "🎧",
    ":hear_no_evil:": "🙉",
    ":heart_decoration:": "💟",
    ":heart_eyes:": "😍",
    ":heart_eyes_cat:": "😻",
    ":heartbeat:": "💓",
    ":heartpulse:": "💗",
    ":heavy_dollar_sign:": "💲",
    ":helicopter:": "🚁",
    ":herb:": "🌿",
    ":hibiscus:": "🌺",
    ":high_brightness:": "🔆",
    ":high_heel:": "👠",
    ":hocho:": "🔪",
    ":honey_pot:": "🍯",
    ":honeybee:": "🐝",
    ":horse:": "🐴",
    ":horse_racing:": "🏇",
    ":hospital:": "🏥",
    ":hotel:": "🏨",
    ":house:": "🏠",
    ":house_with_garden:": "🏡",
    ":hushed:": "😯",
    ":ice_cream:": "🍨",
    ":icecream:": "🍦",
    ":id:": "🆔",
    ":ideograph_advantage:": "🉐",
    ":imp:": "👿",
    ":inbox_tray:": "📥",
    ":incoming_envelope:": "📨",
    ":information_desk_person:": "💁",
    ":innocent:": "😇",
    ":halo:": "😇",
    "0:-)": "😇",
    "0:)": "😇",
    "0:3": "😇",
    "0:-3": "😇",
    ":iphone:": "📱",
    ":izakaya_lantern:": "🏮",
    ":jack_o_lantern:": "🎃",
    ":japan:": "🗾",
    ":japanese_castle:": "🏯",
    ":japanese_goblin:": "👺",
    ":japanese_ogre:": "👹",
    ":jeans:": "👖",
    ":joy:": "😂",
    ":joy_cat:": "😹",
    ":key:": "🔑",
    ":keycap_ten:": "🔟",
    ":kimono:": "👘",
    ":kiss:": "💋",
    ":kissing:": "😗",
    ":*": "😗",
    ":^*": "😗",
    ":kissing_cat:": "😽",
    ":kissing_closed_eyes:": "😚",
    ":kissing_heart:": "😘",
    ":kissing_smiling_eyes:": "😙",
    ":koala:": "🐨",
    ":koko:": "🈁",
    ":large_blue_circle:": "🔵",
    ":large_blue_diamond:": "🔷",
    ":large_orange_diamond:": "🔶",
    ":last_quarter_moon:": "🌗",
    ":last_quarter_moon_with_face:": "🌜",
    ":laughing:": "😆",
    ":laugh:": "😆",
    ":-D": "😆",
    ":D": "😆",
    ":leaves:": "🍃",
    ":ledger:": "📒",
    ":left_luggage:": "🛅",
    ":lemon:": "🍋",
    ":leopard:": "🐆",
    ":light_rail:": "🚈",
    ":link:": "🔗",
    ":lips:": "👄",
    ":lipstick:": "💄",
    ":lock:": "🔒",
    ":lock_with_ink_pen:": "🔏",
    ":lollipop:": "🍭",
    ":loudspeaker:": "📢",
    ":love_hotel:": "🏩",
    ":love_letter:": "💌",
    ":low_brightness:": "🔅",
    ":mag:": "🔍",
    ":mag_right:": "🔎",
    ":mahjong:": "🀄",
    ":mailbox:": "📫",
    ":mailbox_closed:": "📪",
    ":mailbox_with_mail:": "📬",
    ":mailbox_with_no_mail:": "📭",
    ":man:": "👨",
    ":man_with_gua_pi_mao:": "👲",
    ":man_with_turban:": "👳",
    ":mans_shoe:": "👞",
    ":maple_leaf:": "🍁",
    ":mask:": "😷",
    ":massage:": "💆",
    ":meat_on_bone:": "🍖",
    ":mega:": "📣",
    ":melon:": "🍈",
    ":memo:": "📝",
    ":mens:": "🚹",
    ":metro:": "🚇",
    ":microphone:": "🎤",
    ":microscope:": "🔬",
    ":milky_way:": "🌌",
    ":minibus:": "🚐",
    ":minidisc:": "💽",
    ":mobile_phone_off:": "📴",
    ":money_with_wings:": "💸",
    ":moneybag:": "💰",
    ":monkey:": "🐒",
    ":monkey_face:": "🐵",
    ":monorail:": "🚝",
    ":moon:": "🌙",
    ":mortar_board:": "🎓",
    ":mount_fuji:": "🗻",
    ":mountain_bicyclist:": "🚵",
    ":mountain_cableway:": "🚠",
    ":mountain_railway:": "🚞",
    ":mouse:": "🐭",
    ":mouse2:": "🐁",
    ":movie_camera:": "🎥",
    ":moyai:": "🗿",
    ":muscle:": "💪",
    ":mushroom:": "🍄",
    ":musical_keyboard:": "🎹",
    ":musical_note:": "🎵",
    ":musical_score:": "🎼",
    ":mute:": "🔇",
    ":nail_care:": "💅",
    ":name_badge:": "📛",
    ":necktie:": "👔",
    ":neutral_face:": "😐",
    ":|": "😐",
    ":-|": "😐",
    ":new:": "🆕",
    ":new_moon:": "🌑",
    ":new_moon_with_face:": "🌚",
    ":newspaper:": "📰",
    ":ng:": "🆖",
    ":no_bell:": "🔕",
    ":no_bicycles:": "🚳",
    ":no_entry_sign:": "🚫",
    ":no_good:": "🙅",
    ":no_mobile_phones:": "📵",
    ":no_mouth:": "😶",
    ":no_pedestrians:": "🚷",
    ":no_smoking:": "🚭",
    ":non-potable_water:": "🚱",
    ":nose:": "👃",
    ":notebook:": "📓",
    ":notebook_with_decorative_cover:": "📔",
    ":notes:": "🎶",
    ":nut_and_bolt:": "🔩",
    ":o2:": "🅾",
    ":ocean:": "🌊",
    ":octopus:": "🐙",
    ":oden:": "🍢",
    ":office:": "🏢",
    ":ok:": "🆗",
    ":ok_hand:": "👌",
    ":ok_woman:": "🙆",
    ":older_man:": "👴",
    ":older_woman:": "👵",
    ":on:": "🔛",
    ":oncoming_automobile:": "🚘",
    ":oncoming_bus:": "🚍",
    ":oncoming_police_car:": "🚔",
    ":oncoming_taxi:": "🚖",
    ":open_book:": "📖",
    ":open_file_folder:": "📂",
    ":open_hands:": "👐",
    ":open_mouth:": "😮",
    ":O": "😮",
    ":-O": "😮",
    ":-o": "😮",
    ":o": "😮",
    ":orange_book:": "📙",
    ":outbox_tray:": "📤",
    ":ox:": "🐂",
    ":package:": "📦",
    ":page_facing_up:": "📄",
    ":page_with_curl:": "📃",
    ":pager:": "📟",
    ":palm_tree:": "🌴",
    ":panda_face:": "🐼",
    ":paperclip:": "📎",
    ":parking:": "🅿",
    ":passport_control:": "🛂",
    ":paw_prints:": "🐾",
    ":peach:": "🍑",
    ":pear:": "🍐",
    ":pencil:": "📝",
    ":penguin:": "🐧",
    ":pensive:": "😔",
    ":performing_arts:": "🎭",
    ":persevere:": "😣",
    ":person_frowning:": "🙍",
    ":person_with_blond_hair:": "👱",
    ":person_with_pouting_face:": "🙎",
    ":pig:": "🐷",
    ":pig2:": "🐖",
    ":pig_nose:": "🐽",
    ":pill:": "💊",
    ":pineapple:": "🍍",
    ":pizza:": "🍕",
    ":point_down:": "👇",
    ":point_left:": "👈",
    ":point_right:": "👉",
    ":point_up_2:": "👆",
    ":police_car:": "🚓",
    ":poodle:": "🐩",
    ":poop:": "💩",
    ":post_office:": "🏣",
    ":postal_horn:": "📯",
    ":postbox:": "📮",
    ":potable_water:": "🚰",
    ":pouch:": "👝",
    ":poultry_leg:": "🍗",
    ":pound:": "💷",
    ":pouting_cat:": "😾",
    ":pray:": "🙏",
    ":princess:": "👸",
    ":punch:": "👊",
    ":purple_heart:": "💜",
    ":purse:": "👛",
    ":pushpin:": "📌",
    ":put_litter_in_its_place:": "🚮",
    ":rabbit:": "🐰",
    ":rabbit2:": "🐇",
    ":racehorse:": "🐎",
    ":radio:": "📻",
    ":radio_button:": "🔘",
    ":rage:": "😡",
    ":railway_car:": "🚃",
    ":rainbow:": "🌈",
    ":raised_hands:": "🙌",
    ":raising_hand:": "🙋",
    ":ram:": "🐏",
    ":ramen:": "🍜",
    ":rat:": "🐀",
    ":red_car:": "🚗",
    ":red_circle:": "🔴",
    ":relieved:": "😌",
    ":repeat:": "🔁",
    ":repeat_one:": "🔂",
    ":restroom:": "🚻",
    ":revolving_hearts:": "💞",
    ":ribbon:": "🎀",
    ":rice:": "🍚",
    ":rice_ball:": "🍙",
    ":rice_cracker:": "🍘",
    ":rice_scene:": "🎑",
    ":ring:": "💍",
    ":rocket:": "🚀",
    ":roller_coaster:": "🎢",
    ":rooster:": "🐓",
    ":rose:": "🌹",
    ":rotating_light:": "🚨",
    ":round_pushpin:": "📍",
    ":rowboat:": "🚣",
    ":rugby_football:": "🏉",
    ":runner:": "🏃",
    ":running:": "🏃",
    ":running_shirt_with_sash:": "🎽",
    ":sa:": "🈂",
    ":sake:": "🍶",
    ":sandal:": "👡",
    ":santa:": "🎅",
    ":satellite:": "📡",
    ":satisfied:": "😆",
    ":saxophone:": "🎷",
    ":school:": "🏫",
    ":school_satchel:": "🎒",
    ":scream:": "😱",
    ":scream_cat:": "🙀",
    ":scroll:": "📜",
    ":seat:": "💺",
    ":see_no_evil:": "🙈",
    ":seedling:": "🌱",
    ":shaved_ice:": "🍧",
    ":sheep:": "🐑",
    ":shell:": "🐚",
    ":ship:": "🚢",
    ":shirt:": "👕",
    ":shit:": "💩",
    ":shoe:": "👞",
    ":shower:": "🚿",
    ":signal_strength:": "📶",
    ":six_pointed_star:": "🔯",
    ":ski:": "🎿",
    ":skull:": "💀",
    ":sleeping:": "😴",
    ":sleepy:": "😪",
    ":slot_machine:": "🎰",
    ":small_blue_diamond:": "🔹",
    ":small_orange_diamond:": "🔸",
    ":small_red_triangle:": "🔺",
    ":small_red_triangle_down:": "🔻",
    ":smile:": "😄",
    ":))": "😄",
    ":-))": "😄",
    ":smile_cat:": "😸",
    ":smiley:": "😃",
    ":-)": "😃",
    ":)": "😃",
    ":]": "😃",
    ":o)": "😃",
    ":smiley_cat:": "😺",
    ":smiling_imp:": "😈",
    "}:-)": "😈",
    "3:-)": "😈",
    "}:)": "😈",
    "3:)": "😈",
    ":smirk:": "😏",
    ":smirk_cat:": "😼",
    ":smoking:": "🚬",
    ":snail:": "🐌",
    ":snake:": "🐍",
    ":snowboarder:": "🏂",
    ":sob:": "😭",
    ":soon:": "🔜",
    ":sos:": "🆘",
    ":sound:": "🔉",
    ":space_invader:": "👾",
    ":spaghetti:": "🍝",
    ":sparkler:": "🎇",
    ":sparkling_heart:": "💖",
    ":speak_no_evil:": "🙊",
    ":speaker:": "🔊",
    ":speech_balloon:": "💬",
    ":speedboat:": "🚤",
    ":star2:": "🌟",
    ":stars:": "🌃",
    ":station:": "🚉",
    ":statue_of_liberty:": "🗽",
    ":steam_locomotive:": "🚂",
    ":stew:": "🍲",
    ":straight_ruler:": "📏",
    ":strawberry:": "🍓",
    ":stuck_out_tongue:": "😛",
    ":P": "😛",
    ":-P": "😛",
    ":-p": "😛",
    ":p": "😛",
    ":stuck_out_tongue_closed_eyes:": "😝",
    "XP": "😝",
    "X-P": "😝",
    "xP": "😝",
    "x-P": "😝",
    "Xp": "😝",
    "X-p": "😝",
    ":stuck_out_tongue_winking_eye:": "😜",
    ":sun_with_face:": "🌞",
    ":sunflower:": "🌻",
    ":sunglasses:": "😎",
    "8-)": "😎",
    "8)": "😎",
    ":sunrise:": "🌅",
    ":sunrise_over_mountains:": "🌄",
    ":surfer:": "🏄",
    ":sushi:": "🍣",
    ":suspension_railway:": "🚟",
    ":sweat:": "😓",
    ":sweat_drops:": "💦",
    ":sweat_smile:": "😅",
    ":sweet_potato:": "🍠",
    ":swimmer:": "🏊",
    ":symbols:": "🔣",
    ":syringe:": "💉",
    ":tada:": "🎉",
    ":tanabata_tree:": "🎋",
    ":tangerine:": "🍊",
    ":taxi:": "🚕",
    ":tea:": "🍵",
    ":telephone_receiver:": "📞",
    ":telescope:": "🔭",
    ":tennis:": "🎾",
    ":thought_balloon:": "💭",
    ":thumbsdown:": "👎",
    ":thumbsup:": "👍",
    ":ticket:": "🎫",
    ":tiger:": "🐯",
    ":tiger2:": "🐅",
    ":tired_face:": "😫",
    ":toilet:": "🚽",
    ":tokyo_tower:": "🗼",
    ":tomato:": "🍅",
    ":tongue:": "👅",
    ":top:": "🔝",
    ":tophat:": "🎩",
    ":tractor:": "🚜",
    ":traffic_light:": "🚥",
    ":train:": "🚃",
    ":train2:": "🚆",
    ":tram:": "🚊",
    ":triangular_flag_on_post:": "🚩",
    ":triangular_ruler:": "📐",
    ":trident:": "🔱",
    ":triumph:": "😤",
    ":trolleybus:": "🚎",
    ":trophy:": "🏆",
    ":tropical_drink:": "🍹",
    ":tropical_fish:": "🐠",
    ":truck:": "🚚",
    ":trumpet:": "🎺",
    ":tshirt:": "👕",
    ":tulip:": "🌷",
    ":turtle:": "🐢",
    ":tv:": "📺",
    ":twisted_rightwards_arrows:": "🔀",
    ":two_hearts:": "💕",
    ":two_men_holding_hands:": "👬",
    ":two_women_holding_hands:": "👭",
    ":u5272:": "🈹",
    ":u5408:": "🈴",
    ":u55b6:": "🈺",
    ":u6307:": "🈯",
    ":u6708:": "🈷",
    ":u6709:": "🈶",
    ":u6e80:": "🈵",
    ":u7121:": "🈚",
    ":u7533:": "🈸",
    ":u7981:": "🈲",
    ":u7a7a:": "🈳",
    ":unamused:": "😒",
    ":\\": "😒",
    ":-\\": "😒",
    ":-/": "😒",
    ":/": "😒",
    ":underage:": "🔞",
    ":unlock:": "🔓",
    ":up:": "🆙",
    ":vertical_traffic_light:": "🚦",
    ":vhs:": "📼",
    ":vibration_mode:": "📳",
    ":video_camera:": "📹",
    ":video_game:": "🎮",
    ":violin:": "🎻",
    ":volcano:": "🌋",
    ":vs:": "🆚",
    ":walking:": "🚶",
    ":waning_crescent_moon:": "🌘",
    ":waning_gibbous_moon:": "🌖",
    ":water_buffalo:": "🐃",
    ":watermelon:": "🍉",
    ":wave:": "👋",
    ":waxing_crescent_moon:": "🌒",
    ":waxing_gibbous_moon:": "🌔",
    ":wc:": "🚾",
    ":weary:": "😩",
    ":wedding:": "💒",
    ":whale:": "🐳",
    ":whale2:": "🐋",
    ":white_flower:": "💮",
    ":white_square_button:": "🔳",
    ":wind_chime:": "🎐",
    ":wine_glass:": "🍷",
    ":wink:": "😉",
    ";)": "😉",
    ";-)": "😉",
    ":wolf:": "🐺",
    ":woman:": "👩",
    ":womans_clothes:": "👚",
    ":womans_hat:": "👒",
    ":womens:": "🚺",
    ":worried:": "😟",
    ":wrench:": "🔧",
    ":yellow_heart:": "💛",
    ":yen:": "💴",
    ":yum:": "😋",
    ":zzz:": "💤"
};
},{}],76:[function(require,module,exports){
/* jshint node:true */
var emojiMap = require('./emoji-map.js');

module.exports = function (text) {
    if (typeof text !== "string") {
        return;
    }
    var emoji;
    var words = text.split(/[,. ]+/);
    words.forEach(function (word) {
        if (emojiMap.hasOwnProperty(word)) {
            emoji = emojiMap[word];
            text = text.replace(word, emoji);
        }
    });
    return text;
};
},{"./emoji-map.js":75}],77:[function(require,module,exports){
(function (global){
var location = global.location || {};
/*jslint indent: 2, browser: true, bitwise: true, plusplus: true */
var twemoji = (function (
  /*! Copyright Twitter Inc. and other contributors. Licensed under MIT *//*
    https://github.com/twitter/twemoji/blob/gh-pages/LICENSE
  */

  // WARNING:   this file is generated automatically via
  //            `node twemoji-generator.js`
  //            please update its `createTwemoji` function
  //            at the bottom of the same file instead.

) {
  'use strict';

  /*jshint maxparams:4 */

  var
    // the exported module object
    twemoji = {


    /////////////////////////
    //      properties     //
    /////////////////////////

      // default assets url, by default will be Twitter Inc. CDN
      base: (location.protocol === 'https:' ? 'https:' : 'http:') +
            '//twemoji.maxcdn.com/',

      // default assets file extensions, by default '.png'
      ext: '.png',

      // default assets/folder size, by default "36x36"
      // available via Twitter CDN: 16, 36, 72
      size: '36x36',

      // default class name, by default 'emoji'
      className: 'emoji',

      // basic utilities / helpers to convert code points
      // to JavaScript surrogates and vice versa
      convert: {

        /**
         * Given an HEX codepoint, returns UTF16 surrogate pairs.
         *
         * @param   string  generic codepoint, i.e. '1F4A9'
         * @return  string  codepoint transformed into utf16 surrogates pair,
         *          i.e. \uD83D\uDCA9
         *
         * @example
         *  twemoji.convert.fromCodePoint('1f1e8');
         *  // "\ud83c\udde8"
         *
         *  '1f1e8-1f1f3'.split('-').map(twemoji.convert.fromCodePoint).join('')
         *  // "\ud83c\udde8\ud83c\uddf3"
         */
        fromCodePoint: fromCodePoint,

        /**
         * Given UTF16 surrogate pairs, returns the equivalent HEX codepoint.
         *
         * @param   string  generic utf16 surrogates pair, i.e. \uD83D\uDCA9
         * @param   string  optional separator for double code points, default='-'
         * @return  string  utf16 transformed into codepoint, i.e. '1F4A9'
         *
         * @example
         *  twemoji.convert.toCodePoint('\ud83c\udde8\ud83c\uddf3');
         *  // "1f1e8-1f1f3"
         *
         *  twemoji.convert.toCodePoint('\ud83c\udde8\ud83c\uddf3', '~');
         *  // "1f1e8~1f1f3"
         */
        toCodePoint: toCodePoint
      },


    /////////////////////////
    //       methods       //
    /////////////////////////

      /**
       * User first: used to remove missing images
       * preserving the original text intent when
       * a fallback for network problems is desired.
       * Automatically added to Image nodes via DOM
       * It could be recycled for string operations via:
       *  $('img.emoji').on('error', twemoji.onerror)
       */
      onerror: function onerror() {
        if (this.parentNode) {
          this.parentNode.replaceChild(createText(this.alt), this);
        }
      },

      /**
       * Main method/logic to generate either <img> tags or HTMLImage nodes.
       *  "emojify" a generic text or DOM Element.
       *
       * @overloads
       *
       * String replacement for `innerHTML` or server side operations
       *  twemoji.parse(string);
       *  twemoji.parse(string, Function);
       *  twemoji.parse(string, Object);
       *
       * HTMLElement tree parsing for safer operations over existing DOM
       *  twemoji.parse(HTMLElement);
       *  twemoji.parse(HTMLElement, Function);
       *  twemoji.parse(HTMLElement, Object);
       *
       * @param   string|HTMLElement  the source to parse and enrich with emoji.
       *
       *          string              replace emoji matches with <img> tags.
       *                              Mainly used to inject emoji via `innerHTML`
       *                              It does **not** parse the string or validate it,
       *                              it simply replaces found emoji with a tag.
       *                              NOTE: be sure this won't affect security.
       *
       *          HTMLElement         walk through the DOM tree and find emoji
       *                              that are inside **text node only** (nodeType === 3)
       *                              Mainly used to put emoji in already generated DOM
       *                              without compromising surrounding nodes and
       *                              **avoiding** the usage of `innerHTML`.
       *                              NOTE: Using DOM elements instead of strings should
       *                              improve security without compromising too much
       *                              performance compared with a less safe `innerHTML`.
       *
       * @param   Function|Object  [optional]
       *                              either the callback that will be invoked or an object
       *                              with all properties to use per each found emoji.
       *
       *          Function            if specified, this will be invoked per each emoji
       *                              that has been found through the RegExp except
       *                              those follwed by the invariant \uFE0E ("as text").
       *                              Once invoked, parameters will be:
       *
       *                                codePoint:string  the lower case HEX code point
       *                                                  i.e. "1f4a9"
       *
       *                                options:Object    all info for this parsing operation
       *
       *                                variant:char      the optional \uFE0F ("as image")
       *                                                  variant, in case this info
       *                                                  is anyhow meaningful.
       *                                                  By default this is ignored.
       *
       *                              If such callback will return a falsy value instead
       *                              of a valid `src` to use for the image, nothing will
       *                              actually change for that specific emoji.
       *
       *
       *          Object              if specified, an object containing the following properties
       *
       *            callback   Function  the callback to invoke per each found emoji.
       *            base       string    the base url, by default twemoji.base
       *            ext        string    the image extension, by default twemoji.ext
       *            size       string    the assets size, by default twemoji.size
       *
       * @example
       *
       *  twemoji.parse("I \u2764\uFE0F emoji!");
       *  // I <img class="emoji" draggable="false" alt="❤️" src="/assets/2764.gif"> emoji!
       *
       *
       *  twemoji.parse("I \u2764\uFE0F emoji!", function(icon, options, variant) {
       *    return '/assets/' + icon + '.gif';
       *  });
       *  // I <img class="emoji" draggable="false" alt="❤️" src="/assets/2764.gif"> emoji!
       *
       *
       * twemoji.parse("I \u2764\uFE0F emoji!", {
       *   size: 72,
       *   callback: function(icon, options, variant) {
       *     return '/assets/' + options.size + '/' + icon + options.ext;
       *   }
       * });
       *  // I <img class="emoji" draggable="false" alt="❤️" src="/assets/72x72/2764.png"> emoji!
       *
       */
      parse: parse,

      /**
       * Given a string, invokes the callback argument
       *  per each emoji found in such string.
       * This is the most raw version used by
       *  the .parse(string) method itself.
       *
       * @param   string    generic string to parse
       * @param   Function  a generic callback that will be
       *                    invoked to replace the content.
       *                    This calback wil receive standard
       *                    String.prototype.replace(str, callback)
       *                    arguments such:
       *  callback(
       *    match,  // the emoji match
       *    icon,   // the emoji text (same as text)
       *    variant // either '\uFE0E' or '\uFE0F', if present
       *  );
       *
       *                    and others commonly received via replace.
       *
       *  NOTE: When the variant \uFE0E is found, remember this is an explicit intent
       *  from the user: the emoji should **not** be replaced with an image.
       *  In \uFE0F case one, it's the opposite, it should be graphic.
       *  This utility convetion is that only \uFE0E are not translated into images.
       */
      replace: replace,

      /**
       * Simplify string tests against emoji.
       *
       * @param   string  some text that might contain emoji
       * @return  boolean true if any emoji was found, false otherwise.
       *
       * @example
       *
       *  if (twemoji.test(someContent)) {
       *    console.log("emoji All The Things!");
       *  }
       */
      test: test
    },

    // used to escape HTML special chars in attributes
    escaper = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      "'": '&#39;',
      '"': '&quot;'
    },

    // RegExp based on emoji's official Unicode standards
    // http://www.unicode.org/Public/UNIDATA/EmojiSources.txt
    re = /((?:\ud83c\udde8\ud83c\uddf3|\ud83c\uddfa\ud83c\uddf8|\ud83c\uddf7\ud83c\uddfa|\ud83c\uddf0\ud83c\uddf7|\ud83c\uddef\ud83c\uddf5|\ud83c\uddee\ud83c\uddf9|\ud83c\uddec\ud83c\udde7|\ud83c\uddeb\ud83c\uddf7|\ud83c\uddea\ud83c\uddf8|\ud83c\udde9\ud83c\uddea|\u0039\ufe0f?\u20e3|\u0038\ufe0f?\u20e3|\u0037\ufe0f?\u20e3|\u0036\ufe0f?\u20e3|\u0035\ufe0f?\u20e3|\u0034\ufe0f?\u20e3|\u0033\ufe0f?\u20e3|\u0032\ufe0f?\u20e3|\u0031\ufe0f?\u20e3|\u0030\ufe0f?\u20e3|\u0023\ufe0f?\u20e3|\ud83d\udeb3|\ud83d\udeb1|\ud83d\udeb0|\ud83d\udeaf|\ud83d\udeae|\ud83d\udea6|\ud83d\udea3|\ud83d\udea1|\ud83d\udea0|\ud83d\ude9f|\ud83d\ude9e|\ud83d\ude9d|\ud83d\ude9c|\ud83d\ude9b|\ud83d\ude98|\ud83d\ude96|\ud83d\ude94|\ud83d\ude90|\ud83d\ude8e|\ud83d\ude8d|\ud83d\ude8b|\ud83d\ude8a|\ud83d\ude88|\ud83d\ude86|\ud83d\ude82|\ud83d\ude81|\ud83d\ude36|\ud83d\ude34|\ud83d\ude2f|\ud83d\ude2e|\ud83d\ude2c|\ud83d\ude27|\ud83d\ude26|\ud83d\ude1f|\ud83d\ude1b|\ud83d\ude19|\ud83d\ude17|\ud83d\ude15|\ud83d\ude11|\ud83d\ude10|\ud83d\ude0e|\ud83d\ude08|\ud83d\ude07|\ud83d\ude00|\ud83d\udd67|\ud83d\udd66|\ud83d\udd65|\ud83d\udd64|\ud83d\udd63|\ud83d\udd62|\ud83d\udd61|\ud83d\udd60|\ud83d\udd5f|\ud83d\udd5e|\ud83d\udd5d|\ud83d\udd5c|\ud83d\udd2d|\ud83d\udd2c|\ud83d\udd15|\ud83d\udd09|\ud83d\udd08|\ud83d\udd07|\ud83d\udd06|\ud83d\udd05|\ud83d\udd04|\ud83d\udd02|\ud83d\udd01|\ud83d\udd00|\ud83d\udcf5|\ud83d\udcef|\ud83d\udced|\ud83d\udcec|\ud83d\udcb7|\ud83d\udcb6|\ud83d\udcad|\ud83d\udc6d|\ud83d\udc6c|\ud83d\udc65|\ud83d\udc2a|\ud83d\udc16|\ud83d\udc15|\ud83d\udc13|\ud83d\udc10|\ud83d\udc0f|\ud83d\udc0b|\ud83d\udc0a|\ud83d\udc09|\ud83d\udc08|\ud83d\udc07|\ud83d\udc06|\ud83d\udc05|\ud83d\udc04|\ud83d\udc03|\ud83d\udc02|\ud83d\udc01|\ud83d\udc00|\ud83c\udfe4|\ud83c\udfc9|\ud83c\udfc7|\ud83c\udf7c|\ud83c\udf50|\ud83c\udf4b|\ud83c\udf33|\ud83c\udf32|\ud83c\udf1e|\ud83c\udf1d|\ud83c\udf1c|\ud83c\udf1a|\ud83c\udf18|\ud83c\udccf|\ud83c\udd70|\ud83c\udd71|\ud83c\udd7e|\ud83c\udd8e|\ud83c\udd91|\ud83c\udd92|\ud83c\udd93|\ud83c\udd94|\ud83c\udd95|\ud83c\udd96|\ud83c\udd97|\ud83c\udd98|\ud83c\udd99|\ud83c\udd9a|\ud83d\udc77|\ud83d\udec5|\ud83d\udec4|\ud83d\udec3|\ud83d\udec2|\ud83d\udec1|\ud83d\udebf|\ud83d\udeb8|\ud83d\udeb7|\ud83d\udeb5|\ud83c\ude01|\ud83c\ude02|\ud83c\ude32|\ud83c\ude33|\ud83c\ude34|\ud83c\ude35|\ud83c\ude36|\ud83c\ude37|\ud83c\ude38|\ud83c\ude39|\ud83c\ude3a|\ud83c\ude50|\ud83c\ude51|\ud83c\udf00|\ud83c\udf01|\ud83c\udf02|\ud83c\udf03|\ud83c\udf04|\ud83c\udf05|\ud83c\udf06|\ud83c\udf07|\ud83c\udf08|\ud83c\udf09|\ud83c\udf0a|\ud83c\udf0b|\ud83c\udf0c|\ud83c\udf0f|\ud83c\udf11|\ud83c\udf13|\ud83c\udf14|\ud83c\udf15|\ud83c\udf19|\ud83c\udf1b|\ud83c\udf1f|\ud83c\udf20|\ud83c\udf30|\ud83c\udf31|\ud83c\udf34|\ud83c\udf35|\ud83c\udf37|\ud83c\udf38|\ud83c\udf39|\ud83c\udf3a|\ud83c\udf3b|\ud83c\udf3c|\ud83c\udf3d|\ud83c\udf3e|\ud83c\udf3f|\ud83c\udf40|\ud83c\udf41|\ud83c\udf42|\ud83c\udf43|\ud83c\udf44|\ud83c\udf45|\ud83c\udf46|\ud83c\udf47|\ud83c\udf48|\ud83c\udf49|\ud83c\udf4a|\ud83c\udf4c|\ud83c\udf4d|\ud83c\udf4e|\ud83c\udf4f|\ud83c\udf51|\ud83c\udf52|\ud83c\udf53|\ud83c\udf54|\ud83c\udf55|\ud83c\udf56|\ud83c\udf57|\ud83c\udf58|\ud83c\udf59|\ud83c\udf5a|\ud83c\udf5b|\ud83c\udf5c|\ud83c\udf5d|\ud83c\udf5e|\ud83c\udf5f|\ud83c\udf60|\ud83c\udf61|\ud83c\udf62|\ud83c\udf63|\ud83c\udf64|\ud83c\udf65|\ud83c\udf66|\ud83c\udf67|\ud83c\udf68|\ud83c\udf69|\ud83c\udf6a|\ud83c\udf6b|\ud83c\udf6c|\ud83c\udf6d|\ud83c\udf6e|\ud83c\udf6f|\ud83c\udf70|\ud83c\udf71|\ud83c\udf72|\ud83c\udf73|\ud83c\udf74|\ud83c\udf75|\ud83c\udf76|\ud83c\udf77|\ud83c\udf78|\ud83c\udf79|\ud83c\udf7a|\ud83c\udf7b|\ud83c\udf80|\ud83c\udf81|\ud83c\udf82|\ud83c\udf83|\ud83c\udf84|\ud83c\udf85|\ud83c\udf86|\ud83c\udf87|\ud83c\udf88|\ud83c\udf89|\ud83c\udf8a|\ud83c\udf8b|\ud83c\udf8c|\ud83c\udf8d|\ud83c\udf8e|\ud83c\udf8f|\ud83c\udf90|\ud83c\udf91|\ud83c\udf92|\ud83c\udf93|\ud83c\udfa0|\ud83c\udfa1|\ud83c\udfa2|\ud83c\udfa3|\ud83c\udfa4|\ud83c\udfa5|\ud83c\udfa6|\ud83c\udfa7|\ud83c\udfa8|\ud83c\udfa9|\ud83c\udfaa|\ud83c\udfab|\ud83c\udfac|\ud83c\udfad|\ud83c\udfae|\ud83c\udfaf|\ud83c\udfb0|\ud83c\udfb1|\ud83c\udfb2|\ud83c\udfb3|\ud83c\udfb4|\ud83c\udfb5|\ud83c\udfb6|\ud83c\udfb7|\ud83c\udfb8|\ud83c\udfb9|\ud83c\udfba|\ud83c\udfbb|\ud83c\udfbc|\ud83c\udfbd|\ud83c\udfbe|\ud83c\udfbf|\ud83c\udfc0|\ud83c\udfc1|\ud83c\udfc2|\ud83c\udfc3|\ud83c\udfc4|\ud83c\udfc6|\ud83c\udfc8|\ud83c\udfca|\ud83c\udfe0|\ud83c\udfe1|\ud83c\udfe2|\ud83c\udfe3|\ud83c\udfe5|\ud83c\udfe6|\ud83c\udfe7|\ud83c\udfe8|\ud83c\udfe9|\ud83c\udfea|\ud83c\udfeb|\ud83c\udfec|\ud83c\udfed|\ud83c\udfee|\ud83c\udfef|\ud83c\udff0|\ud83d\udc0c|\ud83d\udc0d|\ud83d\udc0e|\ud83d\udc11|\ud83d\udc12|\ud83d\udc14|\ud83d\udc17|\ud83d\udc18|\ud83d\udc19|\ud83d\udc1a|\ud83d\udc1b|\ud83d\udc1c|\ud83d\udc1d|\ud83d\udc1e|\ud83d\udc1f|\ud83d\udc20|\ud83d\udc21|\ud83d\udc22|\ud83d\udc23|\ud83d\udc24|\ud83d\udc25|\ud83d\udc26|\ud83d\udc27|\ud83d\udc28|\ud83d\udc29|\ud83d\udc2b|\ud83d\udc2c|\ud83d\udc2d|\ud83d\udc2e|\ud83d\udc2f|\ud83d\udc30|\ud83d\udc31|\ud83d\udc32|\ud83d\udc33|\ud83d\udc34|\ud83d\udc35|\ud83d\udc36|\ud83d\udc37|\ud83d\udc38|\ud83d\udc39|\ud83d\udc3a|\ud83d\udc3b|\ud83d\udc3c|\ud83d\udc3d|\ud83d\udc3e|\ud83d\udc40|\ud83d\udc42|\ud83d\udc43|\ud83d\udc44|\ud83d\udc45|\ud83d\udc46|\ud83d\udc47|\ud83d\udc48|\ud83d\udc49|\ud83d\udc4a|\ud83d\udc4b|\ud83d\udc4c|\ud83d\udc4d|\ud83d\udc4e|\ud83d\udc4f|\ud83d\udc50|\ud83d\udc51|\ud83d\udc52|\ud83d\udc53|\ud83d\udc54|\ud83d\udc55|\ud83d\udc56|\ud83d\udc57|\ud83d\udc58|\ud83d\udc59|\ud83d\udc5a|\ud83d\udc5b|\ud83d\udc5c|\ud83d\udc5d|\ud83d\udc5e|\ud83d\udc5f|\ud83d\udc60|\ud83d\udc61|\ud83d\udc62|\ud83d\udc63|\ud83d\udc64|\ud83d\udc66|\ud83d\udc67|\ud83d\udc68|\ud83d\udc69|\ud83d\udc6a|\ud83d\udc6b|\ud83d\udc6e|\ud83d\udc6f|\ud83d\udc70|\ud83d\udc71|\ud83d\udc72|\ud83d\udc73|\ud83d\udc74|\ud83d\udc75|\ud83d\udc76|\ud83d\udeb4|\ud83d\udc78|\ud83d\udc79|\ud83d\udc7a|\ud83d\udc7b|\ud83d\udc7c|\ud83d\udc7d|\ud83d\udc7e|\ud83d\udc7f|\ud83d\udc80|\ud83d\udc81|\ud83d\udc82|\ud83d\udc83|\ud83d\udc84|\ud83d\udc85|\ud83d\udc86|\ud83d\udc87|\ud83d\udc88|\ud83d\udc89|\ud83d\udc8a|\ud83d\udc8b|\ud83d\udc8c|\ud83d\udc8d|\ud83d\udc8e|\ud83d\udc8f|\ud83d\udc90|\ud83d\udc91|\ud83d\udc92|\ud83d\udc93|\ud83d\udc94|\ud83d\udc95|\ud83d\udc96|\ud83d\udc97|\ud83d\udc98|\ud83d\udc99|\ud83d\udc9a|\ud83d\udc9b|\ud83d\udc9c|\ud83d\udc9d|\ud83d\udc9e|\ud83d\udc9f|\ud83d\udca0|\ud83d\udca1|\ud83d\udca2|\ud83d\udca3|\ud83d\udca4|\ud83d\udca5|\ud83d\udca6|\ud83d\udca7|\ud83d\udca8|\ud83d\udca9|\ud83d\udcaa|\ud83d\udcab|\ud83d\udcac|\ud83d\udcae|\ud83d\udcaf|\ud83d\udcb0|\ud83d\udcb1|\ud83d\udcb2|\ud83d\udcb3|\ud83d\udcb4|\ud83d\udcb5|\ud83d\udcb8|\ud83d\udcb9|\ud83d\udcba|\ud83d\udcbb|\ud83d\udcbc|\ud83d\udcbd|\ud83d\udcbe|\ud83d\udcbf|\ud83d\udcc0|\ud83d\udcc1|\ud83d\udcc2|\ud83d\udcc3|\ud83d\udcc4|\ud83d\udcc5|\ud83d\udcc6|\ud83d\udcc7|\ud83d\udcc8|\ud83d\udcc9|\ud83d\udcca|\ud83d\udccb|\ud83d\udccc|\ud83d\udccd|\ud83d\udcce|\ud83d\udccf|\ud83d\udcd0|\ud83d\udcd1|\ud83d\udcd2|\ud83d\udcd3|\ud83d\udcd4|\ud83d\udcd5|\ud83d\udcd6|\ud83d\udcd7|\ud83d\udcd8|\ud83d\udcd9|\ud83d\udcda|\ud83d\udcdb|\ud83d\udcdc|\ud83d\udcdd|\ud83d\udcde|\ud83d\udcdf|\ud83d\udce0|\ud83d\udce1|\ud83d\udce2|\ud83d\udce3|\ud83d\udce4|\ud83d\udce5|\ud83d\udce6|\ud83d\udce7|\ud83d\udce8|\ud83d\udce9|\ud83d\udcea|\ud83d\udceb|\ud83d\udcee|\ud83d\udcf0|\ud83d\udcf1|\ud83d\udcf2|\ud83d\udcf3|\ud83d\udcf4|\ud83d\udcf6|\ud83d\udcf7|\ud83d\udcf9|\ud83d\udcfa|\ud83d\udcfb|\ud83d\udcfc|\ud83d\udd03|\ud83d\udd0a|\ud83d\udd0b|\ud83d\udd0c|\ud83d\udd0d|\ud83d\udd0e|\ud83d\udd0f|\ud83d\udd10|\ud83d\udd11|\ud83d\udd12|\ud83d\udd13|\ud83d\udd14|\ud83d\udd16|\ud83d\udd17|\ud83d\udd18|\ud83d\udd19|\ud83d\udd1a|\ud83d\udd1b|\ud83d\udd1c|\ud83d\udd1d|\ud83d\udd1e|\ud83d\udd1f|\ud83d\udd20|\ud83d\udd21|\ud83d\udd22|\ud83d\udd23|\ud83d\udd24|\ud83d\udd25|\ud83d\udd26|\ud83d\udd27|\ud83d\udd28|\ud83d\udd29|\ud83d\udd2a|\ud83d\udd2b|\ud83d\udd2e|\ud83d\udd2f|\ud83d\udd30|\ud83d\udd31|\ud83d\udd32|\ud83d\udd33|\ud83d\udd34|\ud83d\udd35|\ud83d\udd36|\ud83d\udd37|\ud83d\udd38|\ud83d\udd39|\ud83d\udd3a|\ud83d\udd3b|\ud83d\udd3c|\ud83d\udd3d|\ud83d\udd50|\ud83d\udd51|\ud83d\udd52|\ud83d\udd53|\ud83d\udd54|\ud83d\udd55|\ud83d\udd56|\ud83d\udd57|\ud83d\udd58|\ud83d\udd59|\ud83d\udd5a|\ud83d\udd5b|\ud83d\uddfb|\ud83d\uddfc|\ud83d\uddfd|\ud83d\uddfe|\ud83d\uddff|\ud83d\ude01|\ud83d\ude02|\ud83d\ude03|\ud83d\ude04|\ud83d\ude05|\ud83d\ude06|\ud83d\ude09|\ud83d\ude0a|\ud83d\ude0b|\ud83d\ude0c|\ud83d\ude0d|\ud83d\ude0f|\ud83d\ude12|\ud83d\ude13|\ud83d\ude14|\ud83d\ude16|\ud83d\ude18|\ud83d\ude1a|\ud83d\ude1c|\ud83d\ude1d|\ud83d\ude1e|\ud83d\ude20|\ud83d\ude21|\ud83d\ude22|\ud83d\ude23|\ud83d\ude24|\ud83d\ude25|\ud83d\ude28|\ud83d\ude29|\ud83d\ude2a|\ud83d\ude2b|\ud83d\ude2d|\ud83d\ude30|\ud83d\ude31|\ud83d\ude32|\ud83d\ude33|\ud83d\ude35|\ud83d\ude37|\ud83d\ude38|\ud83d\ude39|\ud83d\ude3a|\ud83d\ude3b|\ud83d\ude3c|\ud83d\ude3d|\ud83d\ude3e|\ud83d\ude3f|\ud83d\ude40|\ud83d\ude45|\ud83d\ude46|\ud83d\ude47|\ud83d\ude48|\ud83d\ude49|\ud83d\ude4a|\ud83d\ude4b|\ud83d\ude4c|\ud83d\ude4d|\ud83d\ude4e|\ud83d\ude4f|\ud83d\ude80|\ud83d\ude83|\ud83d\ude84|\ud83d\ude85|\ud83d\ude87|\ud83d\ude89|\ud83d\ude8c|\ud83d\ude8f|\ud83d\ude91|\ud83d\ude92|\ud83d\ude93|\ud83d\ude95|\ud83d\ude97|\ud83d\ude99|\ud83d\ude9a|\ud83d\udea2|\ud83d\udea4|\ud83d\udea5|\ud83d\udea7|\ud83d\udea8|\ud83d\udea9|\ud83d\udeaa|\ud83d\udeab|\ud83d\udeac|\ud83d\udead|\ud83d\udeb2|\ud83d\udeb6|\ud83d\udeb9|\ud83d\udeba|\ud83d\udebb|\ud83d\udebc|\ud83d\udebd|\ud83d\udebe|\ud83d\udec0|\ud83c\udde6|\ud83c\udde7|\ud83c\udde8|\ud83c\udde9|\ud83c\uddea|\ud83c\uddeb|\ud83c\uddec|\ud83c\udded|\ud83c\uddee|\ud83c\uddef|\ud83c\uddf0|\ud83c\uddf1|\ud83c\uddf2|\ud83c\uddf3|\ud83c\uddf4|\ud83c\uddf5|\ud83c\uddf6|\ud83c\uddf7|\ud83c\uddf8|\ud83c\uddf9|\ud83c\uddfa|\ud83c\uddfb|\ud83c\uddfc|\ud83c\uddfd|\ud83c\uddfe|\ud83c\uddff|\ud83c\udf0d|\ud83c\udf0e|\ud83c\udf10|\ud83c\udf12|\ud83c\udf16|\ud83c\udf17|\ue50a|\u3030|\u27b0|\u2797|\u2796|\u2795|\u2755|\u2754|\u2753|\u274e|\u274c|\u2728|\u270b|\u270a|\u2705|\u26ce|\u23f3|\u23f0|\u23ec|\u23eb|\u23ea|\u23e9|\u2122|\u27bf|\u00a9|\u00ae)|(?:(?:\ud83c\udc04|\ud83c\udd7f|\ud83c\ude1a|\ud83c\ude2f|\u3299|\u303d|\u2b55|\u2b50|\u2b1c|\u2b1b|\u2b07|\u2b06|\u2b05|\u2935|\u2934|\u27a1|\u2764|\u2757|\u2747|\u2744|\u2734|\u2733|\u2716|\u2714|\u2712|\u270f|\u270c|\u2709|\u2708|\u2702|\u26fd|\u26fa|\u26f5|\u26f3|\u26f2|\u26ea|\u26d4|\u26c5|\u26c4|\u26be|\u26bd|\u26ab|\u26aa|\u26a1|\u26a0|\u2693|\u267f|\u267b|\u3297|\u2666|\u2665|\u2663|\u2660|\u2653|\u2652|\u2651|\u2650|\u264f|\u264e|\u264d|\u264c|\u264b|\u264a|\u2649|\u2648|\u263a|\u261d|\u2615|\u2614|\u2611|\u260e|\u2601|\u2600|\u25fe|\u25fd|\u25fc|\u25fb|\u25c0|\u25b6|\u25ab|\u25aa|\u24c2|\u231b|\u231a|\u21aa|\u21a9|\u2199|\u2198|\u2197|\u2196|\u2195|\u2194|\u2139|\u2049|\u203c|\u2668)([\uFE0E\uFE0F]?)))/g,

    // used to find HTML special chars in attributes
    rescaper = /[&<>'"]/g,

    // nodes with type 1 which should **not** be parsed
    shouldntBeParsed = /IFRAME|NOFRAMES|NOSCRIPT|SCRIPT|SELECT|STYLE|TEXTAREA/,

    // just a private shortcut
    fromCharCode = String.fromCharCode;

  return twemoji;


  /////////////////////////
  //  private functions  //
  //     declaration     //
  /////////////////////////

  /**
   * Shortcut to create text nodes
   * @param   string  text used to create DOM text node
   * @return  Node  a DOM node with that text
   */
  function createText(text) {
    return document.createTextNode(text);
  }

  /**
   * Utility function to escape html attribute text
   * @param   string  text use in HTML attribute
   * @return  string  text encoded to use in HTML attribute
   */
  function escapeHTML(s) {
    return s.replace(rescaper, replacer);
  }

  /**
   * Default callback used to generate emoji src
   *  based on Twitter CDN
   * @param   string    the emoji codepoint string
   * @param   string    the default size to use, i.e. "36x36"
   * @param   string    optional "\uFE0F" variant char, ignored by default
   * @return  string    the image source to use
   */
  function defaultImageSrcGenerator(icon, options) {
    return ''.concat(options.base, options.size, '/', icon, options.ext);
  }

  /**
   * Given a generic DOM nodeType 1, walk through all children
   * and store every nodeType 3 (#text) found in the tree.
   * @param   Element a DOM Element with probably some text in it
   * @param   Array the list of previously discovered text nodes
   * @return  Array same list with new discovered nodes, if any
   */
  function grabAllTextNodes(node, allText) {
    var
      childNodes = node.childNodes,
      length = childNodes.length,
      subnode,
      nodeType;
    while (length--) {
      subnode = childNodes[length];
      nodeType = subnode.nodeType;
      // parse emoji only in text nodes
      if (nodeType === 3) {
        // collect them to process emoji later
        allText.push(subnode);
      }
      // ignore all nodes that are not type 1 or that
      // should not be parsed as script, style, and others
      else if (nodeType === 1 && !shouldntBeParsed.test(subnode.nodeName)) {
        grabAllTextNodes(subnode, allText);
      }
    }
    return allText;
  }

  /**
   * Used to both remove the possible variant
   *  and to convert utf16 into code points
   * @param   string    the emoji surrogate pair
   * @param   string    the optional variant char, if any
   */
  function grabTheRightIcon(icon, variant) {
    // if variant is present as \uFE0F
    return toCodePoint(
      variant === '\uFE0F' ?
        // the icon should not contain it
        icon.slice(0, -1) :
        // fix non standard OSX behavior
        (icon.length === 3 && icon.charAt(1) === '\uFE0F' ?
          icon.charAt(0) + icon.charAt(2) : icon)
    );
  }

  /**
   * DOM version of the same logic / parser:
   *  emojify all found sub-text nodes placing images node instead.
   * @param   Element   generic DOM node with some text in some child node
   * @param   Object    options  containing info about how to parse
    *
    *            .callback   Function  the callback to invoke per each found emoji.
    *            .base       string    the base url, by default twemoji.base
    *            .ext        string    the image extension, by default twemoji.ext
    *            .size       string    the assets size, by default twemoji.size
    *
   * @return  Element same generic node with emoji in place, if any.
   */
  function parseNode(node, options) {
    var
      allText = grabAllTextNodes(node, []),
      length = allText.length,
      attrib,
      attrname,
      modified,
      fragment,
      subnode,
      text,
      match,
      i,
      index,
      img,
      alt,
      icon,
      variant,
      src;
    while (length--) {
      modified = false;
      fragment = document.createDocumentFragment();
      subnode = allText[length];
      text = subnode.nodeValue;
      i = 0;
      while ((match = re.exec(text))) {
        index = match.index;
        if (index !== i) {
          fragment.appendChild(
            createText(text.slice(i, index))
          );
        }
        alt = match[0];
        icon = match[1];
        variant = match[2];
        i = index + alt.length;
        if (variant !== '\uFE0E') {
          src = options.callback(
            grabTheRightIcon(icon, variant),
            options,
            variant
          );
          if (src) {
            img = new Image();
            img.onerror = twemoji.onerror;
            img.setAttribute('draggable', 'false');
            attrib = options.attributes(icon, variant);
            for (attrname in attrib) {
              if (
                attrib.hasOwnProperty(attrname) &&
                // don't allow any handlers to be set + don't allow overrides
                attrname.indexOf('on') !== 0 &&
                !img.hasAttribute(attrname)
              ) {
                img.setAttribute(attrname, attrib[attrname]);
              }
            }
            img.className = options.className;
            img.alt = alt;
            img.src = src;
            modified = true;
            fragment.appendChild(img);
          }
        }
        if (!img) fragment.appendChild(createText(alt));
        img = null;
      }
      // is there actually anything to replace in here ?
      if (modified) {
        // any text left to be added ?
        if (i < text.length) {
          fragment.appendChild(
            createText(text.slice(i))
          );
        }
        // replace the text node only, leave intact
        // anything else surrounding such text
        subnode.parentNode.replaceChild(fragment, subnode);
      }
    }
    return node;
  }

  /**
   * String/HTML version of the same logic / parser:
   *  emojify a generic text placing images tags instead of surrogates pair.
   * @param   string    generic string with possibly some emoji in it
   * @param   Object    options  containing info about how to parse
   *
   *            .callback   Function  the callback to invoke per each found emoji.
   *            .base       string    the base url, by default twemoji.base
   *            .ext        string    the image extension, by default twemoji.ext
   *            .size       string    the assets size, by default twemoji.size
   *
   * @return  the string with <img tags> replacing all found and parsed emoji
   */
  function parseString(str, options) {
    return replace(str, function (match, icon, variant) {
      var
        ret = match,
        attrib,
        attrname,
        src;
      // verify the variant is not the FE0E one
      // this variant means "emoji as text" and should not
      // require any action/replacement
      // http://unicode.org/Public/UNIDATA/StandardizedVariants.html
      if (variant !== '\uFE0E') {
        src = options.callback(
          grabTheRightIcon(icon, variant),
          options,
          variant
        );
        if (src) {
          // recycle the match string replacing the emoji
          // with its image counter part
          ret = '<img '.concat(
            'class="', options.className, '" ',
            'draggable="false" ',
            // needs to preserve user original intent
            // when variants should be copied and pasted too
            'alt="',
            match,
            '"',
            ' src="',
            src,
            '"'
          );
          attrib = options.attributes(icon, variant);
          for (attrname in attrib) { 
            if (
              attrib.hasOwnProperty(attrname) &&
              // don't allow any handlers to be set + don't allow overrides
              attrname.indexOf('on') !== 0 &&
              ret.indexOf(' ' + attrname + '=') === -1
            ) {
              ret = ret.concat(' ', attrname, '="', escapeHTML(attrib[attrname]), '"');
            }
          }
          ret = ret.concat('>');
        }
      }
      return ret;
    });
  }

  /**
   * Function used to actually replace HTML special chars
   * @param   string  HTML special char
   * @return  string  encoded HTML special char
   */
  function replacer(m) {
    return escaper[m];
  }

  /**
   * Default options.attribute callback
   * @return  null
   */
  function returnNull() {
    return null;
  }

  /**
   * Given a generic value, creates its squared counterpart if it's a number.
   *  As example, number 36 will return '36x36'.
   * @param   any     a generic value.
   * @return  any     a string representing asset size, i.e. "36x36"
   *                  only in case the value was a number.
   *                  Returns initial value otherwise.
   */
  function toSizeSquaredAsset(value) {
    return typeof value === 'number' ?
      value + 'x' + value :
      value;
  }


  /////////////////////////
  //  exported functions //
  //     declaration     //
  /////////////////////////

  function fromCodePoint(codepoint) {
    var code = typeof codepoint === 'string' ?
          parseInt(codepoint, 16) : codepoint;
    if (code < 0x10000) {
      return fromCharCode(code);
    }
    code -= 0x10000;
    return fromCharCode(
      0xD800 + (code >> 10),
      0xDC00 + (code & 0x3FF)
    );
  }

  function parse(what, how) {
    if (!how || typeof how === 'function') {
      how = {callback: how};
    }
    // if first argument is string, inject html <img> tags
    // otherwise use the DOM tree and parse text nodes only
    return (typeof what === 'string' ? parseString : parseNode)(what, {
      callback:   how.callback || defaultImageSrcGenerator,
      attributes: typeof how.attributes === 'function' ? how.attributes : returnNull,
      base:       typeof how.base === 'string' ? how.base : twemoji.base,
      ext:        how.ext || twemoji.ext,
      size:       how.folder || toSizeSquaredAsset(how.size || twemoji.size),
      className:  how.className || twemoji.className
    });
  }

  function replace(text, callback) {
    return String(text).replace(re, callback);
  }

  function test(text) {
    // IE6 needs a reset before too
    re.lastIndex = 0;
    var result = re.test(text);
    re.lastIndex = 0;
    return result;
  }

  function toCodePoint(unicodeSurrogates, sep) {
    var
      r = [],
      c = 0,
      p = 0,
      i = 0;
    while (i < unicodeSurrogates.length) {
      c = unicodeSurrogates.charCodeAt(i++);
      if (p) {
        r.push((0x10000 + ((p - 0xD800) << 10) + (c - 0xDC00)).toString(16));
        p = 0;
      } else if (0xD800 <= c && c <= 0xDBFF) {
        p = c;
      } else {
        r.push(c.toString(16));
      }
    }
    return r.join(sep || '-');
  }

}());
if (!location.protocol) {
  twemoji.base = twemoji.base.replace(/^http:/, "");
}
module.exports = twemoji;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],78:[function(require,module,exports){
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.24
(function() {
  window.WebComponents = window.WebComponents || {
    flags: {}
  };
  var file = "webcomponents-lite.js";
  var script = document.querySelector('script[src*="' + file + '"]');
  var flags = {};
  if (!flags.noOpts) {
    location.search.slice(1).split("&").forEach(function(option) {
      var parts = option.split("=");
      var match;
      if (parts[0] && (match = parts[0].match(/wc-(.+)/))) {
        flags[match[1]] = parts[1] || true;
      }
    });
    if (script) {
      for (var i = 0, a; a = script.attributes[i]; i++) {
        if (a.name !== "src") {
          flags[a.name] = a.value || true;
        }
      }
    }
    if (flags.log && flags.log.split) {
      var parts = flags.log.split(",");
      flags.log = {};
      parts.forEach(function(f) {
        flags.log[f] = true;
      });
    } else {
      flags.log = {};
    }
  }
  if (flags.register) {
    window.CustomElements = window.CustomElements || {
      flags: {}
    };
    window.CustomElements.flags.register = flags.register;
  }
  WebComponents.flags = flags;
})();

(function(scope) {
  "use strict";
  var hasWorkingUrl = false;
  if (!scope.forceJURL) {
    try {
      var u = new URL("b", "http://a");
      u.pathname = "c%20d";
      hasWorkingUrl = u.href === "http://a/c%20d";
    } catch (e) {}
  }
  if (hasWorkingUrl) return;
  var relative = Object.create(null);
  relative["ftp"] = 21;
  relative["file"] = 0;
  relative["gopher"] = 70;
  relative["http"] = 80;
  relative["https"] = 443;
  relative["ws"] = 80;
  relative["wss"] = 443;
  var relativePathDotMapping = Object.create(null);
  relativePathDotMapping["%2e"] = ".";
  relativePathDotMapping[".%2e"] = "..";
  relativePathDotMapping["%2e."] = "..";
  relativePathDotMapping["%2e%2e"] = "..";
  function isRelativeScheme(scheme) {
    return relative[scheme] !== undefined;
  }
  function invalid() {
    clear.call(this);
    this._isInvalid = true;
  }
  function IDNAToASCII(h) {
    if ("" == h) {
      invalid.call(this);
    }
    return h.toLowerCase();
  }
  function percentEscape(c) {
    var unicode = c.charCodeAt(0);
    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 63, 96 ].indexOf(unicode) == -1) {
      return c;
    }
    return encodeURIComponent(c);
  }
  function percentEscapeQuery(c) {
    var unicode = c.charCodeAt(0);
    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 96 ].indexOf(unicode) == -1) {
      return c;
    }
    return encodeURIComponent(c);
  }
  var EOF = undefined, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;
  function parse(input, stateOverride, base) {
    function err(message) {
      errors.push(message);
    }
    var state = stateOverride || "scheme start", cursor = 0, buffer = "", seenAt = false, seenBracket = false, errors = [];
    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {
      var c = input[cursor];
      switch (state) {
       case "scheme start":
        if (c && ALPHA.test(c)) {
          buffer += c.toLowerCase();
          state = "scheme";
        } else if (!stateOverride) {
          buffer = "";
          state = "no scheme";
          continue;
        } else {
          err("Invalid scheme.");
          break loop;
        }
        break;

       case "scheme":
        if (c && ALPHANUMERIC.test(c)) {
          buffer += c.toLowerCase();
        } else if (":" == c) {
          this._scheme = buffer;
          buffer = "";
          if (stateOverride) {
            break loop;
          }
          if (isRelativeScheme(this._scheme)) {
            this._isRelative = true;
          }
          if ("file" == this._scheme) {
            state = "relative";
          } else if (this._isRelative && base && base._scheme == this._scheme) {
            state = "relative or authority";
          } else if (this._isRelative) {
            state = "authority first slash";
          } else {
            state = "scheme data";
          }
        } else if (!stateOverride) {
          buffer = "";
          cursor = 0;
          state = "no scheme";
          continue;
        } else if (EOF == c) {
          break loop;
        } else {
          err("Code point not allowed in scheme: " + c);
          break loop;
        }
        break;

       case "scheme data":
        if ("?" == c) {
          this._query = "?";
          state = "query";
        } else if ("#" == c) {
          this._fragment = "#";
          state = "fragment";
        } else {
          if (EOF != c && "\t" != c && "\n" != c && "\r" != c) {
            this._schemeData += percentEscape(c);
          }
        }
        break;

       case "no scheme":
        if (!base || !isRelativeScheme(base._scheme)) {
          err("Missing scheme.");
          invalid.call(this);
        } else {
          state = "relative";
          continue;
        }
        break;

       case "relative or authority":
        if ("/" == c && "/" == input[cursor + 1]) {
          state = "authority ignore slashes";
        } else {
          err("Expected /, got: " + c);
          state = "relative";
          continue;
        }
        break;

       case "relative":
        this._isRelative = true;
        if ("file" != this._scheme) this._scheme = base._scheme;
        if (EOF == c) {
          this._host = base._host;
          this._port = base._port;
          this._path = base._path.slice();
          this._query = base._query;
          this._username = base._username;
          this._password = base._password;
          break loop;
        } else if ("/" == c || "\\" == c) {
          if ("\\" == c) err("\\ is an invalid code point.");
          state = "relative slash";
        } else if ("?" == c) {
          this._host = base._host;
          this._port = base._port;
          this._path = base._path.slice();
          this._query = "?";
          this._username = base._username;
          this._password = base._password;
          state = "query";
        } else if ("#" == c) {
          this._host = base._host;
          this._port = base._port;
          this._path = base._path.slice();
          this._query = base._query;
          this._fragment = "#";
          this._username = base._username;
          this._password = base._password;
          state = "fragment";
        } else {
          var nextC = input[cursor + 1];
          var nextNextC = input[cursor + 2];
          if ("file" != this._scheme || !ALPHA.test(c) || nextC != ":" && nextC != "|" || EOF != nextNextC && "/" != nextNextC && "\\" != nextNextC && "?" != nextNextC && "#" != nextNextC) {
            this._host = base._host;
            this._port = base._port;
            this._username = base._username;
            this._password = base._password;
            this._path = base._path.slice();
            this._path.pop();
          }
          state = "relative path";
          continue;
        }
        break;

       case "relative slash":
        if ("/" == c || "\\" == c) {
          if ("\\" == c) {
            err("\\ is an invalid code point.");
          }
          if ("file" == this._scheme) {
            state = "file host";
          } else {
            state = "authority ignore slashes";
          }
        } else {
          if ("file" != this._scheme) {
            this._host = base._host;
            this._port = base._port;
            this._username = base._username;
            this._password = base._password;
          }
          state = "relative path";
          continue;
        }
        break;

       case "authority first slash":
        if ("/" == c) {
          state = "authority second slash";
        } else {
          err("Expected '/', got: " + c);
          state = "authority ignore slashes";
          continue;
        }
        break;

       case "authority second slash":
        state = "authority ignore slashes";
        if ("/" != c) {
          err("Expected '/', got: " + c);
          continue;
        }
        break;

       case "authority ignore slashes":
        if ("/" != c && "\\" != c) {
          state = "authority";
          continue;
        } else {
          err("Expected authority, got: " + c);
        }
        break;

       case "authority":
        if ("@" == c) {
          if (seenAt) {
            err("@ already seen.");
            buffer += "%40";
          }
          seenAt = true;
          for (var i = 0; i < buffer.length; i++) {
            var cp = buffer[i];
            if ("\t" == cp || "\n" == cp || "\r" == cp) {
              err("Invalid whitespace in authority.");
              continue;
            }
            if (":" == cp && null === this._password) {
              this._password = "";
              continue;
            }
            var tempC = percentEscape(cp);
            null !== this._password ? this._password += tempC : this._username += tempC;
          }
          buffer = "";
        } else if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c) {
          cursor -= buffer.length;
          buffer = "";
          state = "host";
          continue;
        } else {
          buffer += c;
        }
        break;

       case "file host":
        if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c) {
          if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == ":" || buffer[1] == "|")) {
            state = "relative path";
          } else if (buffer.length == 0) {
            state = "relative path start";
          } else {
            this._host = IDNAToASCII.call(this, buffer);
            buffer = "";
            state = "relative path start";
          }
          continue;
        } else if ("\t" == c || "\n" == c || "\r" == c) {
          err("Invalid whitespace in file host.");
        } else {
          buffer += c;
        }
        break;

       case "host":
       case "hostname":
        if (":" == c && !seenBracket) {
          this._host = IDNAToASCII.call(this, buffer);
          buffer = "";
          state = "port";
          if ("hostname" == stateOverride) {
            break loop;
          }
        } else if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c) {
          this._host = IDNAToASCII.call(this, buffer);
          buffer = "";
          state = "relative path start";
          if (stateOverride) {
            break loop;
          }
          continue;
        } else if ("\t" != c && "\n" != c && "\r" != c) {
          if ("[" == c) {
            seenBracket = true;
          } else if ("]" == c) {
            seenBracket = false;
          }
          buffer += c;
        } else {
          err("Invalid code point in host/hostname: " + c);
        }
        break;

       case "port":
        if (/[0-9]/.test(c)) {
          buffer += c;
        } else if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c || stateOverride) {
          if ("" != buffer) {
            var temp = parseInt(buffer, 10);
            if (temp != relative[this._scheme]) {
              this._port = temp + "";
            }
            buffer = "";
          }
          if (stateOverride) {
            break loop;
          }
          state = "relative path start";
          continue;
        } else if ("\t" == c || "\n" == c || "\r" == c) {
          err("Invalid code point in port: " + c);
        } else {
          invalid.call(this);
        }
        break;

       case "relative path start":
        if ("\\" == c) err("'\\' not allowed in path.");
        state = "relative path";
        if ("/" != c && "\\" != c) {
          continue;
        }
        break;

       case "relative path":
        if (EOF == c || "/" == c || "\\" == c || !stateOverride && ("?" == c || "#" == c)) {
          if ("\\" == c) {
            err("\\ not allowed in relative path.");
          }
          var tmp;
          if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
            buffer = tmp;
          }
          if (".." == buffer) {
            this._path.pop();
            if ("/" != c && "\\" != c) {
              this._path.push("");
            }
          } else if ("." == buffer && "/" != c && "\\" != c) {
            this._path.push("");
          } else if ("." != buffer) {
            if ("file" == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == "|") {
              buffer = buffer[0] + ":";
            }
            this._path.push(buffer);
          }
          buffer = "";
          if ("?" == c) {
            this._query = "?";
            state = "query";
          } else if ("#" == c) {
            this._fragment = "#";
            state = "fragment";
          }
        } else if ("\t" != c && "\n" != c && "\r" != c) {
          buffer += percentEscape(c);
        }
        break;

       case "query":
        if (!stateOverride && "#" == c) {
          this._fragment = "#";
          state = "fragment";
        } else if (EOF != c && "\t" != c && "\n" != c && "\r" != c) {
          this._query += percentEscapeQuery(c);
        }
        break;

       case "fragment":
        if (EOF != c && "\t" != c && "\n" != c && "\r" != c) {
          this._fragment += c;
        }
        break;
      }
      cursor++;
    }
  }
  function clear() {
    this._scheme = "";
    this._schemeData = "";
    this._username = "";
    this._password = null;
    this._host = "";
    this._port = "";
    this._path = [];
    this._query = "";
    this._fragment = "";
    this._isInvalid = false;
    this._isRelative = false;
  }
  function jURL(url, base) {
    if (base !== undefined && !(base instanceof jURL)) base = new jURL(String(base));
    this._url = url;
    clear.call(this);
    var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, "");
    parse.call(this, input, null, base);
  }
  jURL.prototype = {
    toString: function() {
      return this.href;
    },
    get href() {
      if (this._isInvalid) return this._url;
      var authority = "";
      if ("" != this._username || null != this._password) {
        authority = this._username + (null != this._password ? ":" + this._password : "") + "@";
      }
      return this.protocol + (this._isRelative ? "//" + authority + this.host : "") + this.pathname + this._query + this._fragment;
    },
    set href(href) {
      clear.call(this);
      parse.call(this, href);
    },
    get protocol() {
      return this._scheme + ":";
    },
    set protocol(protocol) {
      if (this._isInvalid) return;
      parse.call(this, protocol + ":", "scheme start");
    },
    get host() {
      return this._isInvalid ? "" : this._port ? this._host + ":" + this._port : this._host;
    },
    set host(host) {
      if (this._isInvalid || !this._isRelative) return;
      parse.call(this, host, "host");
    },
    get hostname() {
      return this._host;
    },
    set hostname(hostname) {
      if (this._isInvalid || !this._isRelative) return;
      parse.call(this, hostname, "hostname");
    },
    get port() {
      return this._port;
    },
    set port(port) {
      if (this._isInvalid || !this._isRelative) return;
      parse.call(this, port, "port");
    },
    get pathname() {
      return this._isInvalid ? "" : this._isRelative ? "/" + this._path.join("/") : this._schemeData;
    },
    set pathname(pathname) {
      if (this._isInvalid || !this._isRelative) return;
      this._path = [];
      parse.call(this, pathname, "relative path start");
    },
    get search() {
      return this._isInvalid || !this._query || "?" == this._query ? "" : this._query;
    },
    set search(search) {
      if (this._isInvalid || !this._isRelative) return;
      this._query = "?";
      if ("?" == search[0]) search = search.slice(1);
      parse.call(this, search, "query");
    },
    get hash() {
      return this._isInvalid || !this._fragment || "#" == this._fragment ? "" : this._fragment;
    },
    set hash(hash) {
      if (this._isInvalid) return;
      this._fragment = "#";
      if ("#" == hash[0]) hash = hash.slice(1);
      parse.call(this, hash, "fragment");
    },
    get origin() {
      var host;
      if (this._isInvalid || !this._scheme) {
        return "";
      }
      switch (this._scheme) {
       case "data":
       case "file":
       case "javascript":
       case "mailto":
        return "null";
      }
      host = this.host;
      if (!host) {
        return "";
      }
      return this._scheme + "://" + host;
    }
  };
  var OriginalURL = scope.URL;
  if (OriginalURL) {
    jURL.createObjectURL = function(blob) {
      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
    };
    jURL.revokeObjectURL = function(url) {
      OriginalURL.revokeObjectURL(url);
    };
  }
  scope.URL = jURL;
})(self);

if (typeof WeakMap === "undefined") {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  if (global.JsMutationObserver) {
    return;
  }
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case "DOMAttrModified":
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord("attributes", target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMCharacterDataModified":
        var target = e.target;
        var record = getRecord("characterData", target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMNodeRemoved":
        this.addTransientObserver(e.target);

       case "DOMNodeInserted":
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === "DOMNodeInserted") {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord("childList", e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) {
    global.MutationObserver = JsMutationObserver;
    JsMutationObserver._isPolyfilled = true;
  }
})(self);

(function() {
  var needsTemplate = typeof HTMLTemplateElement === "undefined";
  if (/Trident/.test(navigator.userAgent)) {
    (function() {
      var importNode = document.importNode;
      document.importNode = function() {
        var n = importNode.apply(document, arguments);
        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var f = document.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }
  var needsCloning = function() {
    if (!needsTemplate) {
      var t = document.createElement("template");
      var t2 = document.createElement("template");
      t2.content.appendChild(document.createElement("div"));
      t.content.appendChild(t2);
      var clone = t.cloneNode(true);
      return clone.content.childNodes.length === 0 || clone.content.firstChild.content.childNodes.length === 0;
    }
  }();
  var TEMPLATE_TAG = "template";
  var TemplateImpl = function() {};
  if (needsTemplate) {
    var contentDoc = document.implementation.createHTMLDocument("template");
    var canDecorate = true;
    var templateStyle = document.createElement("style");
    templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";
    var head = document.head;
    head.insertBefore(templateStyle, head.firstElementChild);
    TemplateImpl.prototype = Object.create(HTMLElement.prototype);
    TemplateImpl.decorate = function(template) {
      if (template.content) {
        return;
      }
      template.content = contentDoc.createDocumentFragment();
      var child;
      while (child = template.firstChild) {
        template.content.appendChild(child);
      }
      template.cloneNode = function(deep) {
        return TemplateImpl.cloneNode(this, deep);
      };
      if (canDecorate) {
        try {
          Object.defineProperty(template, "innerHTML", {
            get: function() {
              var o = "";
              for (var e = this.content.firstChild; e; e = e.nextSibling) {
                o += e.outerHTML || escapeData(e.data);
              }
              return o;
            },
            set: function(text) {
              contentDoc.body.innerHTML = text;
              TemplateImpl.bootstrap(contentDoc);
              while (this.content.firstChild) {
                this.content.removeChild(this.content.firstChild);
              }
              while (contentDoc.body.firstChild) {
                this.content.appendChild(contentDoc.body.firstChild);
              }
            },
            configurable: true
          });
        } catch (err) {
          canDecorate = false;
        }
      }
      TemplateImpl.bootstrap(template.content);
    };
    TemplateImpl.bootstrap = function(doc) {
      var templates = doc.querySelectorAll(TEMPLATE_TAG);
      for (var i = 0, l = templates.length, t; i < l && (t = templates[i]); i++) {
        TemplateImpl.decorate(t);
      }
    };
    document.addEventListener("DOMContentLoaded", function() {
      TemplateImpl.bootstrap(document);
    });
    var createElement = document.createElement;
    document.createElement = function() {
      "use strict";
      var el = createElement.apply(document, arguments);
      if (el.localName === "template") {
        TemplateImpl.decorate(el);
      }
      return el;
    };
    var escapeDataRegExp = /[&\u00A0<>]/g;
    function escapeReplace(c) {
      switch (c) {
       case "&":
        return "&amp;";

       case "<":
        return "&lt;";

       case ">":
        return "&gt;";

       case " ":
        return "&nbsp;";
      }
    }
    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  }
  if (needsTemplate || needsCloning) {
    var nativeCloneNode = Node.prototype.cloneNode;
    TemplateImpl.cloneNode = function(template, deep) {
      var clone = nativeCloneNode.call(template, false);
      if (this.decorate) {
        this.decorate(clone);
      }
      if (deep) {
        clone.content.appendChild(nativeCloneNode.call(template.content, true));
        this.fixClonedDom(clone.content, template.content);
      }
      return clone;
    };
    TemplateImpl.fixClonedDom = function(clone, source) {
      if (!source.querySelectorAll) return;
      var s$ = source.querySelectorAll(TEMPLATE_TAG);
      var t$ = clone.querySelectorAll(TEMPLATE_TAG);
      for (var i = 0, l = t$.length, t, s; i < l; i++) {
        s = s$[i];
        t = t$[i];
        if (this.decorate) {
          this.decorate(s);
        }
        t.parentNode.replaceChild(s.cloneNode(true), t);
      }
    };
    var originalImportNode = document.importNode;
    Node.prototype.cloneNode = function(deep) {
      var dom = nativeCloneNode.call(this, deep);
      if (deep) {
        TemplateImpl.fixClonedDom(dom, this);
      }
      return dom;
    };
    document.importNode = function(element, deep) {
      if (element.localName === TEMPLATE_TAG) {
        return TemplateImpl.cloneNode(element, deep);
      } else {
        var dom = originalImportNode.call(document, element, deep);
        if (deep) {
          TemplateImpl.fixClonedDom(dom, element);
        }
        return dom;
      }
    };
    if (needsCloning) {
      HTMLTemplateElement.prototype.cloneNode = function(deep) {
        return TemplateImpl.cloneNode(this, deep);
      };
    }
  }
  if (needsTemplate) {
    window.HTMLTemplateElement = TemplateImpl;
  }
})();

(function(scope) {
  "use strict";
  if (!(window.performance && window.performance.now)) {
    var start = Date.now();
    window.performance = {
      now: function() {
        return Date.now() - start;
      }
    };
  }
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function() {
      var nativeRaf = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
      return nativeRaf ? function(callback) {
        return nativeRaf(function() {
          callback(performance.now());
        });
      } : function(callback) {
        return window.setTimeout(callback, 1e3 / 60);
      };
    }();
  }
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function() {
      return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id) {
        clearTimeout(id);
      };
    }();
  }
  var workingDefaultPrevented = function() {
    var e = document.createEvent("Event");
    e.initEvent("foo", true, true);
    e.preventDefault();
    return e.defaultPrevented;
  }();
  if (!workingDefaultPrevented) {
    var origPreventDefault = Event.prototype.preventDefault;
    Event.prototype.preventDefault = function() {
      if (!this.cancelable) {
        return;
      }
      origPreventDefault.call(this);
      Object.defineProperty(this, "defaultPrevented", {
        get: function() {
          return true;
        },
        configurable: true
      });
    };
  }
  var isIE = /Trident/.test(navigator.userAgent);
  if (!window.CustomEvent || isIE && typeof window.CustomEvent !== "function") {
    window.CustomEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent("CustomEvent");
      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
      return e;
    };
    window.CustomEvent.prototype = window.Event.prototype;
  }
  if (!window.Event || isIE && typeof window.Event !== "function") {
    var origEvent = window.Event;
    window.Event = function(inType, params) {
      params = params || {};
      var e = document.createEvent("Event");
      e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
      return e;
    };
    window.Event.prototype = origEvent.prototype;
  }
})(window.WebComponents);

window.HTMLImports = window.HTMLImports || {
  flags: {}
};

(function(scope) {
  var IMPORT_LINK_TYPE = "import";
  var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement("link"));
  var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);
  var wrap = function(node) {
    return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;
  };
  var rootDocument = wrap(document);
  var currentScriptDescriptor = {
    get: function() {
      var script = window.HTMLImports.currentScript || document.currentScript || (document.readyState !== "complete" ? document.scripts[document.scripts.length - 1] : null);
      return wrap(script);
    },
    configurable: true
  };
  Object.defineProperty(document, "_currentScript", currentScriptDescriptor);
  Object.defineProperty(rootDocument, "_currentScript", currentScriptDescriptor);
  var isIE = /Trident/.test(navigator.userAgent);
  function whenReady(callback, doc) {
    doc = doc || rootDocument;
    whenDocumentReady(function() {
      watchImportsLoad(callback, doc);
    }, doc);
  }
  var requiredReadyState = isIE ? "complete" : "interactive";
  var READY_EVENT = "readystatechange";
  function isDocumentReady(doc) {
    return doc.readyState === "complete" || doc.readyState === requiredReadyState;
  }
  function whenDocumentReady(callback, doc) {
    if (!isDocumentReady(doc)) {
      var checkReady = function() {
        if (doc.readyState === "complete" || doc.readyState === requiredReadyState) {
          doc.removeEventListener(READY_EVENT, checkReady);
          whenDocumentReady(callback, doc);
        }
      };
      doc.addEventListener(READY_EVENT, checkReady);
    } else if (callback) {
      callback();
    }
  }
  function markTargetLoaded(event) {
    event.target.__loaded = true;
  }
  function watchImportsLoad(callback, doc) {
    var imports = doc.querySelectorAll("link[rel=import]");
    var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];
    function checkDone() {
      if (parsedCount == importCount && callback) {
        callback({
          allImports: imports,
          loadedImports: newImports,
          errorImports: errorImports
        });
      }
    }
    function loadedImport(e) {
      markTargetLoaded(e);
      newImports.push(this);
      parsedCount++;
      checkDone();
    }
    function errorLoadingImport(e) {
      errorImports.push(this);
      parsedCount++;
      checkDone();
    }
    if (importCount) {
      for (var i = 0, imp; i < importCount && (imp = imports[i]); i++) {
        if (isImportLoaded(imp)) {
          newImports.push(this);
          parsedCount++;
          checkDone();
        } else {
          imp.addEventListener("load", loadedImport);
          imp.addEventListener("error", errorLoadingImport);
        }
      }
    } else {
      checkDone();
    }
  }
  function isImportLoaded(link) {
    return useNative ? link.__loaded || link.import && link.import.readyState !== "loading" : link.__importParsed;
  }
  if (useNative) {
    new MutationObserver(function(mxns) {
      for (var i = 0, l = mxns.length, m; i < l && (m = mxns[i]); i++) {
        if (m.addedNodes) {
          handleImports(m.addedNodes);
        }
      }
    }).observe(document.head, {
      childList: true
    });
    function handleImports(nodes) {
      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
        if (isImport(n)) {
          handleImport(n);
        }
      }
    }
    function isImport(element) {
      return element.localName === "link" && element.rel === "import";
    }
    function handleImport(element) {
      var loaded = element.import;
      if (loaded) {
        markTargetLoaded({
          target: element
        });
      } else {
        element.addEventListener("load", markTargetLoaded);
        element.addEventListener("error", markTargetLoaded);
      }
    }
    (function() {
      if (document.readyState === "loading") {
        var imports = document.querySelectorAll("link[rel=import]");
        for (var i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {
          handleImport(imp);
        }
      }
    })();
  }
  whenReady(function(detail) {
    window.HTMLImports.ready = true;
    window.HTMLImports.readyTime = new Date().getTime();
    var evt = rootDocument.createEvent("CustomEvent");
    evt.initCustomEvent("HTMLImportsLoaded", true, true, detail);
    rootDocument.dispatchEvent(evt);
  });
  scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
  scope.useNative = useNative;
  scope.rootDocument = rootDocument;
  scope.whenReady = whenReady;
  scope.isIE = isIE;
})(window.HTMLImports);

(function(scope) {
  var modules = [];
  var addModule = function(module) {
    modules.push(module);
  };
  var initializeModules = function() {
    modules.forEach(function(module) {
      module(scope);
    });
  };
  scope.addModule = addModule;
  scope.initializeModules = initializeModules;
})(window.HTMLImports);

window.HTMLImports.addModule(function(scope) {
  var CSS_URL_REGEXP = /(url\()([^)]*)(\))/g;
  var CSS_IMPORT_REGEXP = /(@import[\s]+(?!url\())([^;]*)(;)/g;
  var path = {
    resolveUrlsInStyle: function(style, linkUrl) {
      var doc = style.ownerDocument;
      var resolver = doc.createElement("a");
      style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);
      return style;
    },
    resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {
      var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);
      r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);
      return r;
    },
    replaceUrls: function(text, urlObj, linkUrl, regexp) {
      return text.replace(regexp, function(m, pre, url, post) {
        var urlPath = url.replace(/["']/g, "");
        if (linkUrl) {
          urlPath = new URL(urlPath, linkUrl).href;
        }
        urlObj.href = urlPath;
        urlPath = urlObj.href;
        return pre + "'" + urlPath + "'" + post;
      });
    }
  };
  scope.path = path;
});

window.HTMLImports.addModule(function(scope) {
  var xhr = {
    async: true,
    ok: function(request) {
      return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;
    },
    load: function(url, next, nextContext) {
      var request = new XMLHttpRequest();
      if (scope.flags.debug || scope.flags.bust) {
        url += "?" + Math.random();
      }
      request.open("GET", url, xhr.async);
      request.addEventListener("readystatechange", function(e) {
        if (request.readyState === 4) {
          var redirectedUrl = null;
          try {
            var locationHeader = request.getResponseHeader("Location");
            if (locationHeader) {
              redirectedUrl = locationHeader.substr(0, 1) === "/" ? location.origin + locationHeader : locationHeader;
            }
          } catch (e) {
            console.error(e.message);
          }
          next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);
        }
      });
      request.send();
      return request;
    },
    loadDocument: function(url, next, nextContext) {
      this.load(url, next, nextContext).responseType = "document";
    }
  };
  scope.xhr = xhr;
});

window.HTMLImports.addModule(function(scope) {
  var xhr = scope.xhr;
  var flags = scope.flags;
  var Loader = function(onLoad, onComplete) {
    this.cache = {};
    this.onload = onLoad;
    this.oncomplete = onComplete;
    this.inflight = 0;
    this.pending = {};
  };
  Loader.prototype = {
    addNodes: function(nodes) {
      this.inflight += nodes.length;
      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
        this.require(n);
      }
      this.checkDone();
    },
    addNode: function(node) {
      this.inflight++;
      this.require(node);
      this.checkDone();
    },
    require: function(elt) {
      var url = elt.src || elt.href;
      elt.__nodeUrl = url;
      if (!this.dedupe(url, elt)) {
        this.fetch(url, elt);
      }
    },
    dedupe: function(url, elt) {
      if (this.pending[url]) {
        this.pending[url].push(elt);
        return true;
      }
      var resource;
      if (this.cache[url]) {
        this.onload(url, elt, this.cache[url]);
        this.tail();
        return true;
      }
      this.pending[url] = [ elt ];
      return false;
    },
    fetch: function(url, elt) {
      flags.load && console.log("fetch", url, elt);
      if (!url) {
        setTimeout(function() {
          this.receive(url, elt, {
            error: "href must be specified"
          }, null);
        }.bind(this), 0);
      } else if (url.match(/^data:/)) {
        var pieces = url.split(",");
        var header = pieces[0];
        var body = pieces[1];
        if (header.indexOf(";base64") > -1) {
          body = atob(body);
        } else {
          body = decodeURIComponent(body);
        }
        setTimeout(function() {
          this.receive(url, elt, null, body);
        }.bind(this), 0);
      } else {
        var receiveXhr = function(err, resource, redirectedUrl) {
          this.receive(url, elt, err, resource, redirectedUrl);
        }.bind(this);
        xhr.load(url, receiveXhr);
      }
    },
    receive: function(url, elt, err, resource, redirectedUrl) {
      this.cache[url] = resource;
      var $p = this.pending[url];
      for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
        this.onload(url, p, resource, err, redirectedUrl);
        this.tail();
      }
      this.pending[url] = null;
    },
    tail: function() {
      --this.inflight;
      this.checkDone();
    },
    checkDone: function() {
      if (!this.inflight) {
        this.oncomplete();
      }
    }
  };
  scope.Loader = Loader;
});

window.HTMLImports.addModule(function(scope) {
  var Observer = function(addCallback) {
    this.addCallback = addCallback;
    this.mo = new MutationObserver(this.handler.bind(this));
  };
  Observer.prototype = {
    handler: function(mutations) {
      for (var i = 0, l = mutations.length, m; i < l && (m = mutations[i]); i++) {
        if (m.type === "childList" && m.addedNodes.length) {
          this.addedNodes(m.addedNodes);
        }
      }
    },
    addedNodes: function(nodes) {
      if (this.addCallback) {
        this.addCallback(nodes);
      }
      for (var i = 0, l = nodes.length, n, loading; i < l && (n = nodes[i]); i++) {
        if (n.children && n.children.length) {
          this.addedNodes(n.children);
        }
      }
    },
    observe: function(root) {
      this.mo.observe(root, {
        childList: true,
        subtree: true
      });
    }
  };
  scope.Observer = Observer;
});

window.HTMLImports.addModule(function(scope) {
  var path = scope.path;
  var rootDocument = scope.rootDocument;
  var flags = scope.flags;
  var isIE = scope.isIE;
  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
  var IMPORT_SELECTOR = "link[rel=" + IMPORT_LINK_TYPE + "]";
  var importParser = {
    documentSelectors: IMPORT_SELECTOR,
    importsSelectors: [ IMPORT_SELECTOR, "link[rel=stylesheet]:not([type])", "style:not([type])", "script:not([type])", 'script[type="application/javascript"]', 'script[type="text/javascript"]' ].join(","),
    map: {
      link: "parseLink",
      script: "parseScript",
      style: "parseStyle"
    },
    dynamicElements: [],
    parseNext: function() {
      var next = this.nextToParse();
      if (next) {
        this.parse(next);
      }
    },
    parse: function(elt) {
      if (this.isParsed(elt)) {
        flags.parse && console.log("[%s] is already parsed", elt.localName);
        return;
      }
      var fn = this[this.map[elt.localName]];
      if (fn) {
        this.markParsing(elt);
        fn.call(this, elt);
      }
    },
    parseDynamic: function(elt, quiet) {
      this.dynamicElements.push(elt);
      if (!quiet) {
        this.parseNext();
      }
    },
    markParsing: function(elt) {
      flags.parse && console.log("parsing", elt);
      this.parsingElement = elt;
    },
    markParsingComplete: function(elt) {
      elt.__importParsed = true;
      this.markDynamicParsingComplete(elt);
      if (elt.__importElement) {
        elt.__importElement.__importParsed = true;
        this.markDynamicParsingComplete(elt.__importElement);
      }
      this.parsingElement = null;
      flags.parse && console.log("completed", elt);
    },
    markDynamicParsingComplete: function(elt) {
      var i = this.dynamicElements.indexOf(elt);
      if (i >= 0) {
        this.dynamicElements.splice(i, 1);
      }
    },
    parseImport: function(elt) {
      elt.import = elt.__doc;
      if (window.HTMLImports.__importsParsingHook) {
        window.HTMLImports.__importsParsingHook(elt);
      }
      if (elt.import) {
        elt.import.__importParsed = true;
      }
      this.markParsingComplete(elt);
      if (elt.__resource && !elt.__error) {
        elt.dispatchEvent(new CustomEvent("load", {
          bubbles: false
        }));
      } else {
        elt.dispatchEvent(new CustomEvent("error", {
          bubbles: false
        }));
      }
      if (elt.__pending) {
        var fn;
        while (elt.__pending.length) {
          fn = elt.__pending.shift();
          if (fn) {
            fn({
              target: elt
            });
          }
        }
      }
      this.parseNext();
    },
    parseLink: function(linkElt) {
      if (nodeIsImport(linkElt)) {
        this.parseImport(linkElt);
      } else {
        linkElt.href = linkElt.href;
        this.parseGeneric(linkElt);
      }
    },
    parseStyle: function(elt) {
      var src = elt;
      elt = cloneStyle(elt);
      src.__appliedElement = elt;
      elt.__importElement = src;
      this.parseGeneric(elt);
    },
    parseGeneric: function(elt) {
      this.trackElement(elt);
      this.addElementToDocument(elt);
    },
    rootImportForElement: function(elt) {
      var n = elt;
      while (n.ownerDocument.__importLink) {
        n = n.ownerDocument.__importLink;
      }
      return n;
    },
    addElementToDocument: function(elt) {
      var port = this.rootImportForElement(elt.__importElement || elt);
      port.parentNode.insertBefore(elt, port);
    },
    trackElement: function(elt, callback) {
      var self = this;
      var done = function(e) {
        elt.removeEventListener("load", done);
        elt.removeEventListener("error", done);
        if (callback) {
          callback(e);
        }
        self.markParsingComplete(elt);
        self.parseNext();
      };
      elt.addEventListener("load", done);
      elt.addEventListener("error", done);
      if (isIE && elt.localName === "style") {
        var fakeLoad = false;
        if (elt.textContent.indexOf("@import") == -1) {
          fakeLoad = true;
        } else if (elt.sheet) {
          fakeLoad = true;
          var csr = elt.sheet.cssRules;
          var len = csr ? csr.length : 0;
          for (var i = 0, r; i < len && (r = csr[i]); i++) {
            if (r.type === CSSRule.IMPORT_RULE) {
              fakeLoad = fakeLoad && Boolean(r.styleSheet);
            }
          }
        }
        if (fakeLoad) {
          setTimeout(function() {
            elt.dispatchEvent(new CustomEvent("load", {
              bubbles: false
            }));
          });
        }
      }
    },
    parseScript: function(scriptElt) {
      var script = document.createElement("script");
      script.__importElement = scriptElt;
      script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);
      scope.currentScript = scriptElt;
      this.trackElement(script, function(e) {
        if (script.parentNode) {
          script.parentNode.removeChild(script);
        }
        scope.currentScript = null;
      });
      this.addElementToDocument(script);
    },
    nextToParse: function() {
      this._mayParse = [];
      return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());
    },
    nextToParseInDoc: function(doc, link) {
      if (doc && this._mayParse.indexOf(doc) < 0) {
        this._mayParse.push(doc);
        var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));
        for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
          if (!this.isParsed(n)) {
            if (this.hasResource(n)) {
              return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;
            } else {
              return;
            }
          }
        }
      }
      return link;
    },
    nextToParseDynamic: function() {
      return this.dynamicElements[0];
    },
    parseSelectorsForNode: function(node) {
      var doc = node.ownerDocument || node;
      return doc === rootDocument ? this.documentSelectors : this.importsSelectors;
    },
    isParsed: function(node) {
      return node.__importParsed;
    },
    needsDynamicParsing: function(elt) {
      return this.dynamicElements.indexOf(elt) >= 0;
    },
    hasResource: function(node) {
      if (nodeIsImport(node) && node.__doc === undefined) {
        return false;
      }
      return true;
    }
  };
  function nodeIsImport(elt) {
    return elt.localName === "link" && elt.rel === IMPORT_LINK_TYPE;
  }
  function generateScriptDataUrl(script) {
    var scriptContent = generateScriptContent(script);
    return "data:text/javascript;charset=utf-8," + encodeURIComponent(scriptContent);
  }
  function generateScriptContent(script) {
    return script.textContent + generateSourceMapHint(script);
  }
  function generateSourceMapHint(script) {
    var owner = script.ownerDocument;
    owner.__importedScripts = owner.__importedScripts || 0;
    var moniker = script.ownerDocument.baseURI;
    var num = owner.__importedScripts ? "-" + owner.__importedScripts : "";
    owner.__importedScripts++;
    return "\n//# sourceURL=" + moniker + num + ".js\n";
  }
  function cloneStyle(style) {
    var clone = style.ownerDocument.createElement("style");
    clone.textContent = style.textContent;
    path.resolveUrlsInStyle(clone);
    return clone;
  }
  scope.parser = importParser;
  scope.IMPORT_SELECTOR = IMPORT_SELECTOR;
});

window.HTMLImports.addModule(function(scope) {
  var flags = scope.flags;
  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
  var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;
  var rootDocument = scope.rootDocument;
  var Loader = scope.Loader;
  var Observer = scope.Observer;
  var parser = scope.parser;
  var importer = {
    documents: {},
    documentPreloadSelectors: IMPORT_SELECTOR,
    importsPreloadSelectors: [ IMPORT_SELECTOR ].join(","),
    loadNode: function(node) {
      importLoader.addNode(node);
    },
    loadSubtree: function(parent) {
      var nodes = this.marshalNodes(parent);
      importLoader.addNodes(nodes);
    },
    marshalNodes: function(parent) {
      return parent.querySelectorAll(this.loadSelectorsForNode(parent));
    },
    loadSelectorsForNode: function(node) {
      var doc = node.ownerDocument || node;
      return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;
    },
    loaded: function(url, elt, resource, err, redirectedUrl) {
      flags.load && console.log("loaded", url, elt);
      elt.__resource = resource;
      elt.__error = err;
      if (isImportLink(elt)) {
        var doc = this.documents[url];
        if (doc === undefined) {
          doc = err ? null : makeDocument(resource, redirectedUrl || url);
          if (doc) {
            doc.__importLink = elt;
            this.bootDocument(doc);
          }
          this.documents[url] = doc;
        }
        elt.__doc = doc;
      }
      parser.parseNext();
    },
    bootDocument: function(doc) {
      this.loadSubtree(doc);
      this.observer.observe(doc);
      parser.parseNext();
    },
    loadedAll: function() {
      parser.parseNext();
    }
  };
  var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));
  importer.observer = new Observer();
  function isImportLink(elt) {
    return isLinkRel(elt, IMPORT_LINK_TYPE);
  }
  function isLinkRel(elt, rel) {
    return elt.localName === "link" && elt.getAttribute("rel") === rel;
  }
  function hasBaseURIAccessor(doc) {
    return !!Object.getOwnPropertyDescriptor(doc, "baseURI");
  }
  function makeDocument(resource, url) {
    var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);
    doc._URL = url;
    var base = doc.createElement("base");
    base.setAttribute("href", url);
    if (!doc.baseURI && !hasBaseURIAccessor(doc)) {
      Object.defineProperty(doc, "baseURI", {
        value: url
      });
    }
    var meta = doc.createElement("meta");
    meta.setAttribute("charset", "utf-8");
    doc.head.appendChild(meta);
    doc.head.appendChild(base);
    doc.body.innerHTML = resource;
    if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {
      HTMLTemplateElement.bootstrap(doc);
    }
    return doc;
  }
  if (!document.baseURI) {
    var baseURIDescriptor = {
      get: function() {
        var base = document.querySelector("base");
        return base ? base.href : window.location.href;
      },
      configurable: true
    };
    Object.defineProperty(document, "baseURI", baseURIDescriptor);
    Object.defineProperty(rootDocument, "baseURI", baseURIDescriptor);
  }
  scope.importer = importer;
  scope.importLoader = importLoader;
});

window.HTMLImports.addModule(function(scope) {
  var parser = scope.parser;
  var importer = scope.importer;
  var dynamic = {
    added: function(nodes) {
      var owner, parsed, loading;
      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
        if (!owner) {
          owner = n.ownerDocument;
          parsed = parser.isParsed(owner);
        }
        loading = this.shouldLoadNode(n);
        if (loading) {
          importer.loadNode(n);
        }
        if (this.shouldParseNode(n) && parsed) {
          parser.parseDynamic(n, loading);
        }
      }
    },
    shouldLoadNode: function(node) {
      return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));
    },
    shouldParseNode: function(node) {
      return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));
    }
  };
  importer.observer.addCallback = dynamic.added.bind(dynamic);
  var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;
});

(function(scope) {
  var initializeModules = scope.initializeModules;
  var isIE = scope.isIE;
  if (scope.useNative) {
    return;
  }
  initializeModules();
  var rootDocument = scope.rootDocument;
  function bootstrap() {
    window.HTMLImports.importer.bootDocument(rootDocument);
  }
  if (document.readyState === "complete" || document.readyState === "interactive" && !window.attachEvent) {
    bootstrap();
  } else {
    document.addEventListener("DOMContentLoaded", bootstrap);
  }
})(window.HTMLImports);

window.CustomElements = window.CustomElements || {
  flags: {}
};

(function(scope) {
  var flags = scope.flags;
  var modules = [];
  var addModule = function(module) {
    modules.push(module);
  };
  var initializeModules = function() {
    modules.forEach(function(module) {
      module(scope);
    });
  };
  scope.addModule = addModule;
  scope.initializeModules = initializeModules;
  scope.hasNative = Boolean(document.registerElement);
  scope.isIE = /Trident/.test(navigator.userAgent);
  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);
})(window.CustomElements);

window.CustomElements.addModule(function(scope) {
  var IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : "none";
  function forSubtree(node, cb) {
    findAllElements(node, function(e) {
      if (cb(e)) {
        return true;
      }
      forRoots(e, cb);
    });
    forRoots(node, cb);
  }
  function findAllElements(node, find, data) {
    var e = node.firstElementChild;
    if (!e) {
      e = node.firstChild;
      while (e && e.nodeType !== Node.ELEMENT_NODE) {
        e = e.nextSibling;
      }
    }
    while (e) {
      if (find(e, data) !== true) {
        findAllElements(e, find, data);
      }
      e = e.nextElementSibling;
    }
    return null;
  }
  function forRoots(node, cb) {
    var root = node.shadowRoot;
    while (root) {
      forSubtree(root, cb);
      root = root.olderShadowRoot;
    }
  }
  function forDocumentTree(doc, cb) {
    _forDocumentTree(doc, cb, []);
  }
  function _forDocumentTree(doc, cb, processingDocuments) {
    doc = window.wrap(doc);
    if (processingDocuments.indexOf(doc) >= 0) {
      return;
    }
    processingDocuments.push(doc);
    var imports = doc.querySelectorAll("link[rel=" + IMPORT_LINK_TYPE + "]");
    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {
      if (n.import) {
        _forDocumentTree(n.import, cb, processingDocuments);
      }
    }
    cb(doc);
  }
  scope.forDocumentTree = forDocumentTree;
  scope.forSubtree = forSubtree;
});

window.CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  var forSubtree = scope.forSubtree;
  var forDocumentTree = scope.forDocumentTree;
  function addedNode(node, isAttached) {
    return added(node, isAttached) || addedSubtree(node, isAttached);
  }
  function added(node, isAttached) {
    if (scope.upgrade(node, isAttached)) {
      return true;
    }
    if (isAttached) {
      attached(node);
    }
  }
  function addedSubtree(node, isAttached) {
    forSubtree(node, function(e) {
      if (added(e, isAttached)) {
        return true;
      }
    });
  }
  var hasThrottledAttached = window.MutationObserver._isPolyfilled && flags["throttle-attached"];
  scope.hasPolyfillMutations = hasThrottledAttached;
  scope.hasThrottledAttached = hasThrottledAttached;
  var isPendingMutations = false;
  var pendingMutations = [];
  function deferMutation(fn) {
    pendingMutations.push(fn);
    if (!isPendingMutations) {
      isPendingMutations = true;
      setTimeout(takeMutations);
    }
  }
  function takeMutations() {
    isPendingMutations = false;
    var $p = pendingMutations;
    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
      p();
    }
    pendingMutations = [];
  }
  function attached(element) {
    if (hasThrottledAttached) {
      deferMutation(function() {
        _attached(element);
      });
    } else {
      _attached(element);
    }
  }
  function _attached(element) {
    if (element.__upgraded__ && !element.__attached) {
      element.__attached = true;
      if (element.attachedCallback) {
        element.attachedCallback();
      }
    }
  }
  function detachedNode(node) {
    detached(node);
    forSubtree(node, function(e) {
      detached(e);
    });
  }
  function detached(element) {
    if (hasThrottledAttached) {
      deferMutation(function() {
        _detached(element);
      });
    } else {
      _detached(element);
    }
  }
  function _detached(element) {
    if (element.__upgraded__ && element.__attached) {
      element.__attached = false;
      if (element.detachedCallback) {
        element.detachedCallback();
      }
    }
  }
  function inDocument(element) {
    var p = element;
    var doc = window.wrap(document);
    while (p) {
      if (p == doc) {
        return true;
      }
      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;
    }
  }
  function watchShadow(node) {
    if (node.shadowRoot && !node.shadowRoot.__watched) {
      flags.dom && console.log("watching shadow-root for: ", node.localName);
      var root = node.shadowRoot;
      while (root) {
        observe(root);
        root = root.olderShadowRoot;
      }
    }
  }
  function handler(root, mutations) {
    if (flags.dom) {
      var mx = mutations[0];
      if (mx && mx.type === "childList" && mx.addedNodes) {
        if (mx.addedNodes) {
          var d = mx.addedNodes[0];
          while (d && d !== document && !d.host) {
            d = d.parentNode;
          }
          var u = d && (d.URL || d._URL || d.host && d.host.localName) || "";
          u = u.split("/?").shift().split("/").pop();
        }
      }
      console.group("mutations (%d) [%s]", mutations.length, u || "");
    }
    var isAttached = inDocument(root);
    mutations.forEach(function(mx) {
      if (mx.type === "childList") {
        forEach(mx.addedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          addedNode(n, isAttached);
        });
        forEach(mx.removedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          detachedNode(n);
        });
      }
    });
    flags.dom && console.groupEnd();
  }
  function takeRecords(node) {
    node = window.wrap(node);
    if (!node) {
      node = window.wrap(document);
    }
    while (node.parentNode) {
      node = node.parentNode;
    }
    var observer = node.__observer;
    if (observer) {
      handler(node, observer.takeRecords());
      takeMutations();
    }
  }
  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  function observe(inRoot) {
    if (inRoot.__observer) {
      return;
    }
    var observer = new MutationObserver(handler.bind(this, inRoot));
    observer.observe(inRoot, {
      childList: true,
      subtree: true
    });
    inRoot.__observer = observer;
  }
  function upgradeDocument(doc) {
    doc = window.wrap(doc);
    flags.dom && console.group("upgradeDocument: ", doc.baseURI.split("/").pop());
    var isMainDocument = doc === window.wrap(document);
    addedNode(doc, isMainDocument);
    observe(doc);
    flags.dom && console.groupEnd();
  }
  function upgradeDocumentTree(doc) {
    forDocumentTree(doc, upgradeDocument);
  }
  var originalCreateShadowRoot = Element.prototype.createShadowRoot;
  if (originalCreateShadowRoot) {
    Element.prototype.createShadowRoot = function() {
      var root = originalCreateShadowRoot.call(this);
      window.CustomElements.watchShadow(this);
      return root;
    };
  }
  scope.watchShadow = watchShadow;
  scope.upgradeDocumentTree = upgradeDocumentTree;
  scope.upgradeDocument = upgradeDocument;
  scope.upgradeSubtree = addedSubtree;
  scope.upgradeAll = addedNode;
  scope.attached = attached;
  scope.takeRecords = takeRecords;
});

window.CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  function upgrade(node, isAttached) {
    if (node.localName === "template") {
      if (window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
        HTMLTemplateElement.decorate(node);
      }
    }
    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {
      var is = node.getAttribute("is");
      var definition = scope.getRegisteredDefinition(node.localName) || scope.getRegisteredDefinition(is);
      if (definition) {
        if (is && definition.tag == node.localName || !is && !definition.extends) {
          return upgradeWithDefinition(node, definition, isAttached);
        }
      }
    }
  }
  function upgradeWithDefinition(element, definition, isAttached) {
    flags.upgrade && console.group("upgrade:", element.localName);
    if (definition.is) {
      element.setAttribute("is", definition.is);
    }
    implementPrototype(element, definition);
    element.__upgraded__ = true;
    created(element);
    if (isAttached) {
      scope.attached(element);
    }
    scope.upgradeSubtree(element, isAttached);
    flags.upgrade && console.groupEnd();
    return element;
  }
  function implementPrototype(element, definition) {
    if (Object.__proto__) {
      element.__proto__ = definition.prototype;
    } else {
      customMixin(element, definition.prototype, definition.native);
      element.__proto__ = definition.prototype;
    }
  }
  function customMixin(inTarget, inSrc, inNative) {
    var used = {};
    var p = inSrc;
    while (p !== inNative && p !== HTMLElement.prototype) {
      var keys = Object.getOwnPropertyNames(p);
      for (var i = 0, k; k = keys[i]; i++) {
        if (!used[k]) {
          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));
          used[k] = 1;
        }
      }
      p = Object.getPrototypeOf(p);
    }
  }
  function created(element) {
    if (element.createdCallback) {
      element.createdCallback();
    }
  }
  scope.upgrade = upgrade;
  scope.upgradeWithDefinition = upgradeWithDefinition;
  scope.implementPrototype = implementPrototype;
});

window.CustomElements.addModule(function(scope) {
  var isIE = scope.isIE;
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  var upgradeAll = scope.upgradeAll;
  var upgradeWithDefinition = scope.upgradeWithDefinition;
  var implementPrototype = scope.implementPrototype;
  var useNative = scope.useNative;
  function register(name, options) {
    var definition = options || {};
    if (!name) {
      throw new Error("document.registerElement: first argument `name` must not be empty");
    }
    if (name.indexOf("-") < 0) {
      throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(name) + "'.");
    }
    if (isReservedTag(name)) {
      throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(name) + "'. The type name is invalid.");
    }
    if (getRegisteredDefinition(name)) {
      throw new Error("DuplicateDefinitionError: a type with name '" + String(name) + "' is already registered");
    }
    if (!definition.prototype) {
      definition.prototype = Object.create(HTMLElement.prototype);
    }
    definition.__name = name.toLowerCase();
    if (definition.extends) {
      definition.extends = definition.extends.toLowerCase();
    }
    definition.lifecycle = definition.lifecycle || {};
    definition.ancestry = ancestry(definition.extends);
    resolveTagName(definition);
    resolvePrototypeChain(definition);
    overrideAttributeApi(definition.prototype);
    registerDefinition(definition.__name, definition);
    definition.ctor = generateConstructor(definition);
    definition.ctor.prototype = definition.prototype;
    definition.prototype.constructor = definition.ctor;
    if (scope.ready) {
      upgradeDocumentTree(document);
    }
    return definition.ctor;
  }
  function overrideAttributeApi(prototype) {
    if (prototype.setAttribute._polyfilled) {
      return;
    }
    var setAttribute = prototype.setAttribute;
    prototype.setAttribute = function(name, value) {
      changeAttribute.call(this, name, value, setAttribute);
    };
    var removeAttribute = prototype.removeAttribute;
    prototype.removeAttribute = function(name) {
      changeAttribute.call(this, name, null, removeAttribute);
    };
    prototype.setAttribute._polyfilled = true;
  }
  function changeAttribute(name, value, operation) {
    name = name.toLowerCase();
    var oldValue = this.getAttribute(name);
    operation.apply(this, arguments);
    var newValue = this.getAttribute(name);
    if (this.attributeChangedCallback && newValue !== oldValue) {
      this.attributeChangedCallback(name, oldValue, newValue);
    }
  }
  function isReservedTag(name) {
    for (var i = 0; i < reservedTagList.length; i++) {
      if (name === reservedTagList[i]) {
        return true;
      }
    }
  }
  var reservedTagList = [ "annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph" ];
  function ancestry(extnds) {
    var extendee = getRegisteredDefinition(extnds);
    if (extendee) {
      return ancestry(extendee.extends).concat([ extendee ]);
    }
    return [];
  }
  function resolveTagName(definition) {
    var baseTag = definition.extends;
    for (var i = 0, a; a = definition.ancestry[i]; i++) {
      baseTag = a.is && a.tag;
    }
    definition.tag = baseTag || definition.__name;
    if (baseTag) {
      definition.is = definition.__name;
    }
  }
  function resolvePrototypeChain(definition) {
    if (!Object.__proto__) {
      var nativePrototype = HTMLElement.prototype;
      if (definition.is) {
        var inst = document.createElement(definition.tag);
        nativePrototype = Object.getPrototypeOf(inst);
      }
      var proto = definition.prototype, ancestor;
      var foundPrototype = false;
      while (proto) {
        if (proto == nativePrototype) {
          foundPrototype = true;
        }
        ancestor = Object.getPrototypeOf(proto);
        if (ancestor) {
          proto.__proto__ = ancestor;
        }
        proto = ancestor;
      }
      if (!foundPrototype) {
        console.warn(definition.tag + " prototype not found in prototype chain for " + definition.is);
      }
      definition.native = nativePrototype;
    }
  }
  function instantiate(definition) {
    return upgradeWithDefinition(domCreateElement(definition.tag), definition);
  }
  var registry = {};
  function getRegisteredDefinition(name) {
    if (name) {
      return registry[name.toLowerCase()];
    }
  }
  function registerDefinition(name, definition) {
    registry[name] = definition;
  }
  function generateConstructor(definition) {
    return function() {
      return instantiate(definition);
    };
  }
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  function createElementNS(namespace, tag, typeExtension) {
    if (namespace === HTML_NAMESPACE) {
      return createElement(tag, typeExtension);
    } else {
      return domCreateElementNS(namespace, tag);
    }
  }
  function createElement(tag, typeExtension) {
    if (tag) {
      tag = tag.toLowerCase();
    }
    if (typeExtension) {
      typeExtension = typeExtension.toLowerCase();
    }
    var definition = getRegisteredDefinition(typeExtension || tag);
    if (definition) {
      if (tag == definition.tag && typeExtension == definition.is) {
        return new definition.ctor();
      }
      if (!typeExtension && !definition.is) {
        return new definition.ctor();
      }
    }
    var element;
    if (typeExtension) {
      element = createElement(tag);
      element.setAttribute("is", typeExtension);
      return element;
    }
    element = domCreateElement(tag);
    if (tag.indexOf("-") >= 0) {
      implementPrototype(element, HTMLElement);
    }
    return element;
  }
  var domCreateElement = document.createElement.bind(document);
  var domCreateElementNS = document.createElementNS.bind(document);
  var isInstance;
  if (!Object.__proto__ && !useNative) {
    isInstance = function(obj, ctor) {
      if (obj instanceof ctor) {
        return true;
      }
      var p = obj;
      while (p) {
        if (p === ctor.prototype) {
          return true;
        }
        p = p.__proto__;
      }
      return false;
    };
  } else {
    isInstance = function(obj, base) {
      return obj instanceof base;
    };
  }
  function wrapDomMethodToForceUpgrade(obj, methodName) {
    var orig = obj[methodName];
    obj[methodName] = function() {
      var n = orig.apply(this, arguments);
      upgradeAll(n);
      return n;
    };
  }
  wrapDomMethodToForceUpgrade(Node.prototype, "cloneNode");
  wrapDomMethodToForceUpgrade(document, "importNode");
  document.registerElement = register;
  document.createElement = createElement;
  document.createElementNS = createElementNS;
  scope.registry = registry;
  scope.instanceof = isInstance;
  scope.reservedTagList = reservedTagList;
  scope.getRegisteredDefinition = getRegisteredDefinition;
  document.register = document.registerElement;
});

(function(scope) {
  var useNative = scope.useNative;
  var initializeModules = scope.initializeModules;
  var isIE = scope.isIE;
  if (useNative) {
    var nop = function() {};
    scope.watchShadow = nop;
    scope.upgrade = nop;
    scope.upgradeAll = nop;
    scope.upgradeDocumentTree = nop;
    scope.upgradeSubtree = nop;
    scope.takeRecords = nop;
    scope.instanceof = function(obj, base) {
      return obj instanceof base;
    };
  } else {
    initializeModules();
  }
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  var upgradeDocument = scope.upgradeDocument;
  if (!window.wrap) {
    if (window.ShadowDOMPolyfill) {
      window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;
      window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;
    } else {
      window.wrap = window.unwrap = function(node) {
        return node;
      };
    }
  }
  if (window.HTMLImports) {
    window.HTMLImports.__importsParsingHook = function(elt) {
      if (elt.import) {
        upgradeDocument(wrap(elt.import));
      }
    };
  }
  function bootstrap() {
    upgradeDocumentTree(window.wrap(document));
    window.CustomElements.ready = true;
    var requestAnimationFrame = window.requestAnimationFrame || function(f) {
      setTimeout(f, 16);
    };
    requestAnimationFrame(function() {
      setTimeout(function() {
        window.CustomElements.readyTime = Date.now();
        if (window.HTMLImports) {
          window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;
        }
        document.dispatchEvent(new CustomEvent("WebComponentsReady", {
          bubbles: true
        }));
      });
    });
  }
  if (document.readyState === "complete" || scope.flags.eager) {
    bootstrap();
  } else if (document.readyState === "interactive" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {
    bootstrap();
  } else {
    var loadEvent = window.HTMLImports && !window.HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
    window.addEventListener(loadEvent, bootstrap);
  }
})(window.CustomElements);

(function(scope) {
  var style = document.createElement("style");
  style.textContent = "" + "body {" + "transition: opacity ease-in 0.2s;" + " } \n" + "body[unresolved] {" + "opacity: 0; display: block; overflow: hidden; position: relative;" + " } \n";
  var head = document.querySelector("head");
  head.insertBefore(style, head.firstChild);
})(window.WebComponents);
},{}],79:[function(require,module,exports){
(function (global){
/* istanbul ignore next */
if (global.layer && global.layer.Client) {
  console.error('ERROR: It appears that you have multiple copies of the Layer WebSDK in your build!');
  module.exports = global.layer;
} else {
  /* istanbul ignore next */
  if (!global.layer) global.layer = {};

  /* istanbul ignore next */
  if (!global.layer.plugins) global.layer.plugins = {};

  const layer = global.layer;
  layer.Root = require('./lib/root');
  layer.Client = require('./lib/client');
  layer.ClientAuthenticator = require('./lib/client-authenticator');
  layer.Syncable = require('./lib/models/syncable');
  layer.Conversation = require('./lib/models/conversation');
  layer.Channel = require('./lib/models/channel');
  layer.Container = require('./lib/models/container');
  layer.Message = require('./lib/models/message');
  layer.Message.ConversationMessage = require('./lib/models/conversation-message');
  layer.Message.ChannelMessage = require('./lib/models/channel-message');
  layer.Announcement = require('./lib/models/announcement');
  layer.MessagePart = require('./lib/models/message-part');
  layer.Content = require('./lib/models/content');
  layer.Query = require('./lib/queries/query');
  layer.QueryBuilder = require('./lib/queries/query-builder');
  layer.xhr = require('./lib/xhr');
  layer.Identity = require('./lib/models/identity');
  layer.Membership = require('./lib/models/membership');
  layer.LayerError = require('./lib/layer-error');
  layer.LayerEvent = require('./lib/layer-event');
  layer.SyncManager = require('./lib/sync-manager');
  layer.SyncEvent = require('./lib/sync-event').SyncEvent;
  layer.XHRSyncEvent = require('./lib/sync-event').XHRSyncEvent;
  layer.WebsocketSyncEvent = require('./lib/sync-event').WebsocketSyncEvent;
  layer.Websockets = {
    SocketManager: require('./lib/websockets/socket-manager'),
    RequestManager: require('./lib/websockets/request-manager'),
    ChangeManager: require('./lib/websockets/change-manager'),
  };
  layer.OnlineStateManager = require('./lib/online-state-manager');
  layer.DbManager = require('./lib/db-manager');
  layer.Constants = require('./lib/const');
  layer.Util = require('./lib/client-utils');
  layer.TypingIndicators = require('./lib/typing-indicators/typing-indicators');
  layer.TypingIndicators.TypingListener = require('./lib/typing-indicators/typing-listener');
  layer.TypingIndicators.TypingPublisher = require('./lib/typing-indicators/typing-publisher');

  module.exports = layer;
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib/client":83,"./lib/client-authenticator":80,"./lib/client-utils":82,"./lib/const":84,"./lib/db-manager":85,"./lib/layer-error":86,"./lib/layer-event":87,"./lib/models/announcement":95,"./lib/models/channel":97,"./lib/models/channel-message":96,"./lib/models/container":98,"./lib/models/content":99,"./lib/models/conversation":101,"./lib/models/conversation-message":100,"./lib/models/identity":102,"./lib/models/membership":103,"./lib/models/message":105,"./lib/models/message-part":104,"./lib/models/syncable":106,"./lib/online-state-manager":107,"./lib/queries/query":115,"./lib/queries/query-builder":114,"./lib/root":116,"./lib/sync-event":117,"./lib/sync-manager":118,"./lib/typing-indicators/typing-indicators":120,"./lib/typing-indicators/typing-listener":121,"./lib/typing-indicators/typing-publisher":122,"./lib/websockets/change-manager":123,"./lib/websockets/request-manager":124,"./lib/websockets/socket-manager":125,"./lib/xhr":126}],80:[function(require,module,exports){
(function (global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Layer Client.  Access the layer by calling create and receiving it
 * from the "ready" callback.

  var client = new layer.Client({
    appId: "layer:///apps/staging/ffffffff-ffff-ffff-ffff-ffffffffffff",
    isTrustedDevice: false,
    challenge: function(evt) {
      myAuthenticator({
        nonce: evt.nonce,
        onSuccess: evt.callback
      });
    },
    ready: function(client) {
      alert("Yay, I finally got my client!");
    }
  }).connect("sampleuserId");

 * The Layer Client/ClientAuthenticator classes have been divided into:
 *
 * 1. ClientAuthenticator: Manages all authentication and connectivity related issues
 * 2. Client: Manages access to Conversations, Queries, Messages, Events, etc...
 *
 * @class layer.ClientAuthenticator
 * @private
 * @extends layer.Root
 * @author Michael Kantor
 *
 */

var xhr = require('./xhr');
var Root = require('./root');
var SocketManager = require('./websockets/socket-manager');
var WebsocketChangeManager = require('./websockets/change-manager');
var WebsocketRequestManager = require('./websockets/request-manager');
var LayerError = require('./layer-error');
var OnlineManager = require('./online-state-manager');
var SyncManager = require('./sync-manager');
var DbManager = require('./db-manager');
var Identity = require('./models/identity');

var _require = require('./sync-event');

var XHRSyncEvent = _require.XHRSyncEvent;
var WebsocketSyncEvent = _require.WebsocketSyncEvent;

var _require2 = require('./const');

var ACCEPT = _require2.ACCEPT;
var LOCALSTORAGE_KEYS = _require2.LOCALSTORAGE_KEYS;

var logger = require('./logger');
var Util = require('./client-utils');

var MAX_XHR_RETRIES = 3;

var ClientAuthenticator = function (_Root) {
  _inherits(ClientAuthenticator, _Root);

  /**
   * Create a new Client.
   *
   * The appId is the only required parameter:
   *
   *      var client = new Client({
   *          appId: "layer:///apps/staging/uuid"
   *      });
   *
   * For trusted devices, you can enable storage of data to indexedDB and localStorage with the `isTrustedDevice` and `isPersistenceEnabled` property:
   *
   *      var client = new Client({
   *          appId: "layer:///apps/staging/uuid",
   *          isTrustedDevice: true,
   *          isPersistenceEnabled: true
   *      });
   *
   * @method constructor
   * @param  {Object} options
   * @param  {string} options.appId           - "layer:///apps/production/uuid"; Identifies what
   *                                            application we are connecting to.
   * @param  {string} [options.url=https://api.layer.com] - URL to log into a different REST server
   * @param {number} [options.logLevel=ERROR] - Provide a log level that is one of layer.Constants.LOG.NONE, layer.Constants.LOG.ERROR,
   *                                            layer.Constants.LOG.WARN, layer.Constants.LOG.INFO, layer.Constants.LOG.DEBUG
   * @param {boolean} [options.isTrustedDevice=false] - If this is not a trusted device, no data will be written to indexedDB nor localStorage,
   *                                            regardless of any values in layer.Client.persistenceFeatures.
   * @param {Object} [options.isPersistenceEnabled=false] If layer.Client.isPersistenceEnabled is true, then indexedDB will be used to manage a cache
   *                                            allowing Query results, messages sent, and all local modifications to be persisted between page reloads.
   */
  function ClientAuthenticator(options) {
    _classCallCheck(this, ClientAuthenticator);

    // Validate required parameters
    if (!options.appId) throw new Error(LayerError.dictionary.appIdMissing);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(ClientAuthenticator).call(this, options));
  }

  /**
   * Initialize the subcomponents of the ClientAuthenticator
   *
   * @method _initComponents
   * @private
   */


  _createClass(ClientAuthenticator, [{
    key: '_initComponents',
    value: function _initComponents() {
      // Setup the websocket manager; won't connect until we trigger an authenticated event
      this.socketManager = new SocketManager({
        client: this
      });

      this.socketChangeManager = new WebsocketChangeManager({
        client: this,
        socketManager: this.socketManager
      });

      this.socketRequestManager = new WebsocketRequestManager({
        client: this,
        socketManager: this.socketManager
      });

      this.onlineManager = new OnlineManager({
        socketManager: this.socketManager,
        testUrl: this.url + '/nonces?connection-test',
        connected: this._handleOnlineChange.bind(this),
        disconnected: this._handleOnlineChange.bind(this)
      });

      this.syncManager = new SyncManager({
        onlineManager: this.onlineManager,
        socketManager: this.socketManager,
        requestManager: this.socketRequestManager,
        client: this
      });
    }

    /**
     * Destroy the subcomponents of the ClientAuthenticator
     *
     * @method _destroyComponents
     * @private
     */

  }, {
    key: '_destroyComponents',
    value: function _destroyComponents() {
      this.syncManager.destroy();
      this.onlineManager.destroy();
      this.socketManager.destroy();
      this.socketChangeManager.destroy();
      this.socketRequestManager.destroy();
      if (this.dbManager) this.dbManager.destroy();
    }

    /**
     * Is Persisted Session Tokens disabled?
     *
     * @method _isPersistedSessionsDisabled
     * @returns {Boolean}
     * @private
     */

  }, {
    key: '_isPersistedSessionsDisabled',
    value: function _isPersistedSessionsDisabled() {
      return !global.localStorage || this.persistenceFeatures && !this.persistenceFeatures.sessionToken;
    }

    /**
     * Restore the sessionToken from localStorage.
     *
     * This sets the sessionToken rather than returning the token.
     *
     * @method _restoreLastSession
     * @private
     */

  }, {
    key: '_restoreLastSession',
    value: function _restoreLastSession() {
      if (this._isPersistedSessionsDisabled()) return;
      try {
        var sessionData = global.localStorage[LOCALSTORAGE_KEYS.SESSIONDATA + this.appId];
        if (!sessionData) return;
        var parsedData = JSON.parse(sessionData);
        if (parsedData.expires < Date.now()) {
          global.localStorage.removeItem(LOCALSTORAGE_KEYS.SESSIONDATA + this.appId);
        } else {
          this.sessionToken = parsedData.sessionToken;
        }
      } catch (error) {
        // No-op
      }
    }

    /**
     * Restore the Identity for the session owner from localStorage.
     *
     * @method _restoreLastSession
     * @private
     * @return {layer.Identity}
     */

  }, {
    key: '_restoreLastUser',
    value: function _restoreLastUser() {
      try {
        var sessionData = global.localStorage[LOCALSTORAGE_KEYS.SESSIONDATA + this.appId];
        if (!sessionData) return null;
        var userObj = JSON.parse(sessionData).user;
        return new Identity({
          clientId: this.appId,
          sessionOwner: true,
          fromServer: userObj
        });
      } catch (error) {
        return null;
      }
    }

    /**
     * Has the userID changed since the last login?
     *
     * @method _hasUserIdChanged
     * @param {string} userId
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_hasUserIdChanged',
    value: function _hasUserIdChanged(userId) {
      try {
        var sessionData = global.localStorage[LOCALSTORAGE_KEYS.SESSIONDATA + this.appId];
        if (!sessionData) return true;
        return JSON.parse(sessionData).user.user_id !== userId;
      } catch (error) {
        return true;
      }
    }

    /**
     * Initiates the connection.
     *
     * Called by constructor().
     *
     * Will either attempt to validate the cached sessionToken by getting conversations,
     * or if no sessionToken, will call /nonces to start process of getting a new one.
     *
     * ```javascript
     * var client = new layer.Client({appId: myAppId});
     * client.connect('Frodo-the-Dodo');
     * ```
     *
     * @method connect
     * @param {string} userId - User ID of the user you are logging in as
     * @returns {layer.ClientAuthenticator} this
     */

  }, {
    key: 'connect',
    value: function connect() {
      var _this2 = this;

      var userId = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

      var user = void 0;
      this.isConnected = false;
      this.user = null;
      this.onlineManager.start();
      if (!this.isTrustedDevice || !userId || this._isPersistedSessionsDisabled() || this._hasUserIdChanged(userId)) {
        this._clearStoredData();
      }

      if (this.isTrustedDevice && userId) {
        this._restoreLastSession(userId);
        user = this._restoreLastUser();
        if (user) this.user = user;
      }

      if (!this.user) {
        this.user = new Identity({
          userId: userId,
          sessionOwner: true,
          clientId: this.appId,
          id: userId ? Identity.prefixUUID + encodeURIComponent(userId) : ''
        });
      }

      if (this.sessionToken && this.user.userId) {
        this._sessionTokenRestored();
      } else {
        this.xhr({
          url: '/nonces',
          method: 'POST',
          sync: false
        }, function (result) {
          return _this2._connectionResponse(result);
        });
      }
      return this;
    }

    /**
     * Initiates the connection with a session token.
     *
     * This call is for use when you have received a Session Token from some other source; such as your server,
     * and wish to use that instead of doing a full auth process.
     *
     * The Client will presume the token to be valid, and will asynchronously trigger the `ready` event.
     * If the token provided is NOT valid, this won't be detected until a request is made using this token,
     * at which point the `challenge` method will trigger.
     *
     * NOTE: The `connected` event will not be triggered on this path.
     *
     * ```javascript
     * var client = new layer.Client({appId: myAppId});
     * client.connectWithSession('Frodo-the-Dodo', mySessionToken);
     * ```
     *
     * @method connectWithSession
     * @param {String} userId
     * @param {String} sessionToken
     * @returns {layer.ClientAuthenticator} this
     */

  }, {
    key: 'connectWithSession',
    value: function connectWithSession(userId, sessionToken) {
      var _this3 = this;

      var user = void 0;
      this.user = null;
      if (!userId || !sessionToken) throw new Error(LayerError.dictionary.sessionAndUserRequired);
      if (!this.isTrustedDevice || this._isPersistedSessionsDisabled() || this._hasUserIdChanged(userId)) {
        this._clearStoredData();
      }
      if (this.isTrustedDevice) {
        user = this._restoreLastUser();
        if (user) this.user = user;
      }

      this.onlineManager.start();

      if (!this.user) {
        this.user = new Identity({
          userId: userId,
          sessionOwner: true,
          clientId: this.appId,
          id: Identity.prefixUUID + encodeURIComponent(userId)
        });
      }

      this.isConnected = true;
      setTimeout(function () {
        return _this3._authComplete({
          session_token: sessionToken
        }, false);
      }, 1);
      return this;
    }

    /**
     * Called when our request for a nonce gets a response.
     *
     * If there is an error, calls _connectionError.
     *
     * If there is nonce, calls _connectionComplete.
     *
     * @method _connectionResponse
     * @private
     * @param  {Object} result
     */

  }, {
    key: '_connectionResponse',
    value: function _connectionResponse(result) {
      if (!result.success) {
        this._connectionError(result.data);
      } else {
        this._connectionComplete(result.data);
      }
    }

    /**
     * We are now connected (we have a nonce).
     *
     * If we have successfully retrieved a nonce, then
     * we have entered a "connected" but not "authenticated" state.
     * Set the state, trigger any events, and then start authentication.
     *
     * @method _connectionComplete
     * @private
     * @param  {Object} result
     * @param  {string} result.nonce - The nonce provided by the server
     *
     * @fires connected
     */

  }, {
    key: '_connectionComplete',
    value: function _connectionComplete(result) {
      this.isConnected = true;
      this.trigger('connected');
      this._authenticate(result.nonce);
    }

    /**
     * Called when we fail to get a nonce.
     *
     * @method _connectionError
     * @private
     * @param  {layer.LayerError} err
     *
     * @fires connected-error
     */

  }, {
    key: '_connectionError',
    value: function _connectionError(error) {
      this.trigger('connected-error', { error: error });
    }

    /* CONNECT METHODS END */

    /* AUTHENTICATE METHODS BEGIN */

    /**
     * Start the authentication step.
     *
     * We start authentication by triggering a "challenge" event that
     * tells the app to use the nonce to obtain an identity_token.
     *
     * @method _authenticate
     * @private
     * @param  {string} nonce - The nonce to provide your identity provider service
     *
     * @fires challenge
     */

  }, {
    key: '_authenticate',
    value: function _authenticate(nonce) {
      if (nonce) {
        this.trigger('challenge', {
          nonce: nonce,
          callback: this.answerAuthenticationChallenge.bind(this)
        });
      }
    }

    /**
     * Accept an identityToken and use it to create a session.
     *
     * Typically, this method is called using the function pointer provided by
     * the challenge event, but it can also be called directly.
     *
     *      getIdentityToken(nonce, function(identityToken) {
     *          client.answerAuthenticationChallenge(identityToken);
     *      });
     *
     * @method answerAuthenticationChallenge
     * @param  {string} identityToken - Identity token provided by your identity provider service
     */

  }, {
    key: 'answerAuthenticationChallenge',
    value: function answerAuthenticationChallenge(identityToken) {
      var _this4 = this;

      // Report an error if no identityToken provided
      if (!identityToken) {
        throw new Error(LayerError.dictionary.identityTokenMissing);
      } else {
        var userData = Util.decode(identityToken.split('.')[1]);
        var identityObj = JSON.parse(userData);

        if (!identityObj.prn) {
          throw new Error('Your identity token prn (user id) is empty');
        }

        if (this.user.userId && this.user.userId !== identityObj.prn) {
          throw new Error(LayerError.dictionary.invalidUserIdChange);
        }

        this.user._setUserId(identityObj.prn);

        if (identityObj.display_name) this.user.displayName = identityObj.display_name;
        if (identityObj.avatar_url) this.user.avatarUrl = identityObj.avatar_url;

        this.xhr({
          url: '/sessions',
          method: 'POST',
          sync: false,
          data: {
            identity_token: identityToken,
            app_id: this.appId
          }
        }, function (result) {
          return _this4._authResponse(result, identityToken);
        });
      }
    }

    /**
     * Called when our request for a sessionToken receives a response.
     *
     * @private
     * @method _authResponse
     * @param  {Object} result
     * @param  {string} identityToken
     */

  }, {
    key: '_authResponse',
    value: function _authResponse(result, identityToken) {
      if (!result.success) {
        this._authError(result.data, identityToken);
      } else {
        this._authComplete(result.data, false);
      }
    }

    /**
     * Authentication is completed, update state and trigger events.
     *
     * @method _authComplete
     * @private
     * @param  {Object} result
     * @param  {Boolean} fromPersistence
     * @param  {string} result.session_token - Session token received from the server
     *
     * @fires authenticated
     */

  }, {
    key: '_authComplete',
    value: function _authComplete(result, fromPersistence) {
      if (!result || !result.session_token) {
        throw new Error(LayerError.dictionary.sessionTokenMissing);
      }
      this.sessionToken = result.session_token;

      // If _authComplete was called because we accepted an auth loaded from storage
      // we don't need to update storage.
      if (!this._isPersistedSessionsDisabled() && !fromPersistence) {
        try {
          global.localStorage[LOCALSTORAGE_KEYS.SESSIONDATA + this.appId] = JSON.stringify({
            sessionToken: this.sessionToken || '',
            user: DbManager.prototype._getIdentityData([this.user], true)[0],
            expires: Date.now() + 30 * 60 * 60 * 24 * 1000
          });
        } catch (e) {
          // Do nothing
        }
      }

      this._clientAuthenticated();
    }

    /**
     * Authentication has failed.
     *
     * @method _authError
     * @private
     * @param  {layer.LayerError} result
     * @param  {string} identityToken Not currently used
     *
     * @fires authenticated-error
     */

  }, {
    key: '_authError',
    value: function _authError(error, identityToken) {
      this.trigger('authenticated-error', { error: error });
    }

    /**
     * Sets state and triggers events for both connected and authenticated.
     *
     * If reusing a sessionToken cached in localStorage,
     * use this method rather than _authComplete.
     *
     * @method _sessionTokenRestored
     * @private
     *
     * @fires connected, authenticated
     */

  }, {
    key: '_sessionTokenRestored',
    value: function _sessionTokenRestored() {
      this.isConnected = true;
      this.trigger('connected');
      this._clientAuthenticated();
    }

    /**
     * The client is now authenticated, and doing some setup
     * before calling _clientReady.
     *
     * @method _clientAuthenticated
     * @private
     */

  }, {
    key: '_clientAuthenticated',
    value: function _clientAuthenticated() {
      var _this5 = this;

      // Update state and trigger the event
      this.isAuthenticated = true;
      this.trigger('authenticated');

      if (!this.isTrustedDevice) this.isPersistenceEnabled = false;

      // If no persistenceFeatures are specified, set them all
      // to true or false to match isTrustedDevice.
      if (!this.persistenceFeatures || !this.isPersistenceEnabled) {
        var sessionToken = void 0;
        if (this.persistenceFeatures && 'sessionToken' in this.persistenceFeatures) {
          sessionToken = Boolean(this.persistenceFeatures.sessionToken);
        } else {
          sessionToken = this.isTrustedDevice;
        }
        this.persistenceFeatures = {
          conversations: this.isPersistenceEnabled,
          channels: this.isPersistenceEnabled,
          messages: this.isPersistenceEnabled,
          identities: this.isPersistenceEnabled,
          syncQueue: this.isPersistenceEnabled,
          sessionToken: sessionToken
        };
      }

      // Setup the Database Manager
      if (!this.dbManager) {
        this.dbManager = new DbManager({
          client: this,
          tables: this.persistenceFeatures,
          enabled: this.isPersistenceEnabled
        });
      }

      // Before calling _clientReady, load the session owner's full Identity.
      if (this.isPersistenceEnabled) {
        this.dbManager.onOpen(function () {
          return _this5._loadUser();
        });
      } else {
        this._loadUser();
      }
    }

    /**
     * Load the session owner's full identity.
     *
     * Note that failure to load the identity will not prevent
     * _clientReady, but is certainly not a desired outcome.
     *
     * @method _loadUser
     */

  }, {
    key: '_loadUser',
    value: function _loadUser() {
      var _this6 = this;

      // We're done if we got the full identity from localStorage.
      if (this.user.isFullIdentity) {
        this._clientReady();
      } else {
        // load the user's full Identity so we have presence;
        this.user._load();
        this.user.once('identities:loaded', function () {
          if (!_this6._isPersistedSessionsDisabled()) {
            _this6._writeSessionOwner();
            _this6.user.on('identities:change', _this6._writeSessionOwner, _this6);
          }
          _this6._clientReady();
        }).once('identities:loaded-error', function () {
          if (!_this6.user.displayName) _this6.user.displayName = _this6.defaultOwnerDisplayName;
          _this6._clientReady();
        });
      }
    }

    /**
     * Write the latest state of the Session's Identity object to localStorage
     *
     * @method _writeSessionOwner
     * @private
     */

  }, {
    key: '_writeSessionOwner',
    value: function _writeSessionOwner() {
      try {
        // Update the session data in localStorage with our full Identity.
        var sessionData = JSON.parse(global.localStorage[LOCALSTORAGE_KEYS.SESSIONDATA + this.appId]);
        sessionData.user = DbManager.prototype._getIdentityData([this.user])[0];
        global.localStorage[LOCALSTORAGE_KEYS.SESSIONDATA + this.appId] = JSON.stringify(sessionData);
      } catch (e) {
        // no-op
      }
    }

    /**
     * Called to flag the client as ready for action.
     *
     * This method is called after authenication AND
     * after initial conversations have been loaded.
     *
     * @method _clientReady
     * @private
     * @fires ready
     */

  }, {
    key: '_clientReady',
    value: function _clientReady() {
      if (!this.isReady) {
        this.isReady = true;
        this.trigger('ready');
      }
    }

    /* CONNECT METHODS END */

    /* START SESSION MANAGEMENT METHODS */

    /**
     * Deletes your sessionToken from the server, and removes all user data from the Client.
     * Call `client.connect()` to restart the authentication process.
     *
     * This call is asynchronous; some browsers (ahem, safari...) may not have completed the deletion of
     * persisted data if you
     * navigate away from the page.  Use the callback to determine when all necessary cleanup has completed
     * prior to navigating away.
     *
     * Note that while all data should be purged from the browser/device, if you are offline when this is called,
     * your session token will NOT be deleted from the web server.  Why not? Because it would involve retaining the
     * request after all of the user's data has been deleted, or NOT deleting the user's data until we are online.
     *
     * @method logout
     * @param {Function} callback
     * @return {layer.ClientAuthenticator} this
     */

  }, {
    key: 'logout',
    value: function logout(callback) {
      var callbackCount = 1,
          counter = 0;
      if (this.isAuthenticated) {
        callbackCount++;
        this.xhr({
          method: 'DELETE',
          url: '/sessions/' + escape(this.sessionToken),
          sync: false
        }, function () {
          counter++;
          if (counter === callbackCount && callback) callback();
        });
      }

      // Clear data even if isAuthenticated is false
      // Session may have expired, but data still cached.
      this._clearStoredData(function () {
        counter++;
        if (counter === callbackCount && callback) callback();
      });

      this._resetSession();
      return this;
    }
  }, {
    key: '_clearStoredData',
    value: function _clearStoredData(callback) {
      if (global.localStorage) localStorage.removeItem(LOCALSTORAGE_KEYS.SESSIONDATA + this.appId);
      if (this.dbManager) {
        this.dbManager.deleteTables(callback);
      } else if (callback) {
        callback();
      }
    }

    /**
     * Log out/clear session information.
     *
     * Use this to clear the sessionToken and all information from this session.
     *
     * @method _resetSession
     * @private
     */

  }, {
    key: '_resetSession',
    value: function _resetSession() {
      this.isReady = false;
      this.isConnected = false;
      this.isAuthenticated = false;

      if (this.sessionToken) {
        this.sessionToken = '';
        if (global.localStorage) {
          localStorage.removeItem(LOCALSTORAGE_KEYS.SESSIONDATA + this.appId);
        }
      }

      this.trigger('deauthenticated');
      this.onlineManager.stop();
    }

    /**
     * Register your IOS device to receive notifications.
     * For use with native code only (Cordova, React Native, Titanium, etc...)
     *
     * @method registerIOSPushToken
     * @param {Object} options
     * @param {string} options.deviceId - Your IOS device's device ID
     * @param {string} options.iosVersion - Your IOS device's version number
     * @param {string} options.token - Your Apple APNS Token
     * @param {string} [options.bundleId] - Your Apple APNS Bundle ID ("com.layer.bundleid")
     * @param {Function} [callback=null] - Optional callback
     * @param {layer.LayerError} callback.error - LayerError if there was an error; null if successful
     */

  }, {
    key: 'registerIOSPushToken',
    value: function registerIOSPushToken(options, callback) {
      this.xhr({
        url: 'push_tokens',
        method: 'POST',
        sync: false,
        data: {
          token: options.token,
          type: 'apns',
          device_id: options.deviceId,
          ios_version: options.iosVersion,
          apns_bundle_id: options.bundleId
        }
      }, function (result) {
        return callback(result.data);
      });
    }

    /**
     * Register your Android device to receive notifications.
     * For use with native code only (Cordova, React Native, Titanium, etc...)
     *
     * @method registerAndroidPushToken
     * @param {Object} options
     * @param {string} options.deviceId - Your IOS device's device ID
     * @param {string} options.token - Your GCM push Token
     * @param {string} options.senderId - Your GCM Sender ID/Project Number
     * @param {Function} [callback=null] - Optional callback
     * @param {layer.LayerError} callback.error - LayerError if there was an error; null if successful
     */

  }, {
    key: 'registerAndroidPushToken',
    value: function registerAndroidPushToken(options, callback) {
      this.xhr({
        url: 'push_tokens',
        method: 'POST',
        sync: false,
        data: {
          token: options.token,
          type: 'gcm',
          device_id: options.deviceId,
          gcm_sender_id: options.senderId
        }
      }, function (result) {
        return callback(result.data);
      });
    }

    /**
     * Register your Android device to receive notifications.
     * For use with native code only (Cordova, React Native, Titanium, etc...)
     *
     * @method unregisterPushToken
     * @param {string} deviceId - Your IOS device's device ID
     * @param {Function} [callback=null] - Optional callback
     * @param {layer.LayerError} callback.error - LayerError if there was an error; null if successful
     */

  }, {
    key: 'unregisterPushToken',
    value: function unregisterPushToken(deviceId, callback) {
      this.xhr({
        url: 'push_tokens/' + deviceId,
        method: 'DELETE'
      }, function (result) {
        return callback(result.data);
      });
    }

    /* SESSION MANAGEMENT METHODS END */

    /* ACCESSOR METHODS BEGIN */

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any attempt to execute `this.userAppId = 'xxx'` will cause an error to be thrown
     * if the client is already connected.
     *
     * @private
     * @method __adjustAppId
     * @param {string} value - New appId value
     */

  }, {
    key: '__adjustAppId',
    value: function __adjustAppId() {
      if (this.isConnected) throw new Error(LayerError.dictionary.cantChangeIfConnected);
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any attempt to execute `this.user = userIdentity` will cause an error to be thrown
     * if the client is already connected.
     *
     * @private
     * @method __adjustUser
     * @param {string} user - new Identity object
     */

  }, {
    key: '__adjustUser',
    value: function __adjustUser(user) {
      if (this.isConnected) {
        throw new Error(LayerError.dictionary.cantChangeIfConnected);
      }
    }

    // Virtual methods

  }, {
    key: '_addIdentity',
    value: function _addIdentity(identity) {}
  }, {
    key: '_removeIdentity',
    value: function _removeIdentity(identity) {}

    /* ACCESSOR METHODS END */

    /* COMMUNICATIONS METHODS BEGIN */

  }, {
    key: 'sendSocketRequest',
    value: function sendSocketRequest(data, callback) {
      var isChangesArray = Boolean(data.isChangesArray);

      if (data.sync) {
        var target = data.sync.target;
        var depends = data.sync.depends;
        if (target && !depends) depends = [target];

        this.syncManager.request(new WebsocketSyncEvent({
          data: data.body,
          operation: data.method,
          returnChangesArray: isChangesArray,
          target: target,
          depends: depends,
          callback: callback
        }));
      } else {
        if (typeof data.data === 'function') data.data = data.data();
        this.socketRequestManager.sendRequest({ data: data, isChangesArray: isChangesArray, callback: callback });
      }
    }

    /**
     * This event handler receives events from the Online State Manager and generates an event for those subscribed
     * to client.on('online')
     *
     * @method _handleOnlineChange
     * @private
     * @param {layer.LayerEvent} evt
     */

  }, {
    key: '_handleOnlineChange',
    value: function _handleOnlineChange(evt) {
      if (!this.isAuthenticated) return;
      var duration = evt.offlineDuration;
      var isOnline = evt.eventName === 'connected';
      var obj = { isOnline: isOnline };
      if (isOnline) {
        obj.reset = duration > ClientAuthenticator.ResetAfterOfflineDuration;
      }
      this.trigger('online', obj);
    }

    /**
     * Main entry point for sending xhr requests or for queing them in the syncManager.
     *
     * This call adjust arguments for our REST server.
     *
     * @method xhr
     * @protected
     * @param  {Object}   options
     * @param  {string}   options.url - URL relative client's url: "/conversations"
     * @param  {Function} callback
     * @param  {Object}   callback.result
     * @param  {Mixed}    callback.result.data - If an error occurred, this is a layer.LayerError;
     *                                          If the response was application/json, this will be an object
     *                                          If the response was text/empty, this will be text/empty
     * @param  {XMLHttpRequest} callback.result.xhr - Native xhr request object for detailed analysis
     * @param  {Object}         callback.result.Links - Hash of Link headers
     * @return {layer.ClientAuthenticator} this
     */

  }, {
    key: 'xhr',
    value: function xhr(options, callback) {
      if (!options.sync || !options.sync.target) {
        options.url = this._xhrFixRelativeUrls(options.url || '');
      }

      options.withCredentials = true;
      if (!options.method) options.method = 'GET';
      if (!options.headers) options.headers = {};
      this._xhrFixHeaders(options.headers);
      this._xhrFixAuth(options.headers);

      // Note: this is not sync vs async; this is syncManager vs fire it now
      if (options.sync === false) {
        this._nonsyncXhr(options, callback, 0);
      } else {
        this._syncXhr(options, callback);
      }
      return this;
    }

    /**
     * For xhr calls that go through the sync manager, queue it up.
     *
     * @method _syncXhr
     * @private
     * @param  {Object}   options
     * @param  {Function} callback
     */

  }, {
    key: '_syncXhr',
    value: function _syncXhr(options, callback) {
      var _this7 = this;

      if (!options.sync) options.sync = {};
      var innerCallback = function innerCallback(result) {
        _this7._xhrResult(result, callback);
      };
      var target = options.sync.target;
      var depends = options.sync.depends;
      if (target && !depends) depends = [target];

      this.syncManager.request(new XHRSyncEvent({
        url: options.url,
        data: options.data,
        method: options.method,
        operation: options.sync.operation || options.method,
        headers: options.headers,
        callback: innerCallback,
        target: target,
        depends: depends
      }));
    }

    /**
     * For xhr calls that don't go through the sync manager,
     * fire the request, and if it fails, refire it up to 3 tries
     * before reporting an error.  1 second delay between requests
     * so whatever issue is occuring is a tiny bit more likely to resolve,
     * and so we don't hammer the server every time there's a problem.
     *
     * @method _nonsyncXhr
     * @private
     * @param  {Object}   options
     * @param  {Function} callback
     * @param  {number}   retryCount
     */

  }, {
    key: '_nonsyncXhr',
    value: function _nonsyncXhr(options, callback, retryCount) {
      var _this8 = this;

      xhr(options, function (result) {
        if ([502, 503, 504].indexOf(result.status) !== -1 && retryCount < MAX_XHR_RETRIES) {
          setTimeout(function () {
            return _this8._nonsyncXhr(options, callback, retryCount + 1);
          }, 1000);
        } else {
          _this8._xhrResult(result, callback);
        }
      });
    }

    /**
     * Fix authentication header for an xhr request
     *
     * @method _xhrFixAuth
     * @private
     * @param  {Object} headers
     */

  }, {
    key: '_xhrFixAuth',
    value: function _xhrFixAuth(headers) {
      if (this.sessionToken && !headers.Authorization) {
        headers.authorization = 'Layer session-token="' + this.sessionToken + '"'; // eslint-disable-line
      }
    }

    /**
     * Fix relative URLs to create absolute URLs needed for CORS requests.
     *
     * @method _xhrFixRelativeUrls
     * @private
     * @param  {string} relative or absolute url
     * @return {string} absolute url
     */

  }, {
    key: '_xhrFixRelativeUrls',
    value: function _xhrFixRelativeUrls(url) {
      var result = url;
      if (url.indexOf('https://') === -1) {
        if (url[0] === '/') {
          result = this.url + url;
        } else {
          result = this.url + '/' + url;
        }
      }
      return result;
    }

    /**
     * Fixup all headers in preparation for an xhr call.
     *
     * 1. All headers use lower case names for standard/easy lookup
     * 2. Set the accept header
     * 3. If needed, set the content-type header
     *
     * @method _xhrFixHeaders
     * @private
     * @param  {Object} headers
     */

  }, {
    key: '_xhrFixHeaders',
    value: function _xhrFixHeaders(headers) {
      // Replace all headers in arbitrary case with all lower case
      // for easy matching.
      var headerNameList = Object.keys(headers);
      headerNameList.forEach(function (headerName) {
        if (headerName !== headerName.toLowerCase()) {
          headers[headerName.toLowerCase()] = headers[headerName];
          delete headers[headerName];
        }
      });

      if (!headers.accept) headers.accept = ACCEPT;

      if (!headers['content-type']) headers['content-type'] = 'application/json';
    }

    /**
     * Handle the result of an xhr call
     *
     * @method _xhrResult
     * @private
     * @param  {Object}   result     Standard xhr response object from the xhr lib
     * @param  {Function} [callback] Callback on completion
     */

  }, {
    key: '_xhrResult',
    value: function _xhrResult(result, callback) {
      if (this.isDestroyed) return;

      if (!result.success) {
        // Replace the response with a LayerError instance
        if (result.data && _typeof(result.data) === 'object') {
          this._generateError(result);
        }

        // If its an authentication error, reauthenticate
        // don't call _resetSession as that wipes all data and screws with UIs, and the user
        // is still authenticated on the customer's app even if not on Layer.
        if (result.status === 401 && this.isAuthenticated) {
          logger.warn('SESSION EXPIRED!');
          this.isAuthenticated = false;
          this.isReady = false;
          if (global.localStorage) localStorage.removeItem(LOCALSTORAGE_KEYS.SESSIONDATA + this.appId);
          this.trigger('deauthenticated');
          this._authenticate(result.data.getNonce());
        }
      }
      if (callback) callback(result);
    }

    /**
     * Transforms xhr error response into a layer.LayerError instance.
     *
     * Adds additional information to the result object including
     *
     * * url
     * * data
     *
     * @method _generateError
     * @private
     * @param  {Object} result - Result of the xhr call
     */

  }, {
    key: '_generateError',
    value: function _generateError(result) {
      result.data = new LayerError(result.data);
      if (!result.data.httpStatus) result.data.httpStatus = result.status;
      result.data.log();
    }

    /* END COMMUNICATIONS METHODS */

  }]);

  return ClientAuthenticator;
}(Root);

/**
 * State variable; indicates that client is currently authenticated by the server.
 * Should never be true if isConnected is false.
 * @type {Boolean}
 * @readonly
 */


ClientAuthenticator.prototype.isAuthenticated = false;

/**
 * State variable; indicates that client is currently connected to server
 * (may not be authenticated yet)
 * @type {Boolean}
 * @readonly
 */
ClientAuthenticator.prototype.isConnected = false;

/**
 * State variable; indicates that client is ready for the app to use.
 * Use the 'ready' event to be notified when this value changes to true.
 *
 * @type {boolean}
 * @readonly
 */
ClientAuthenticator.prototype.isReady = false;

/**
 * If presence is enabled, then your presence can be set/restored.
 *
 * @type {Boolean} [isPresenceEnabled=true]
 */
ClientAuthenticator.prototype.isPresenceEnabled = true;

/**
 * Your Layer Application ID. Can not be changed once connected.
 *
 * To find your Layer Application ID, see your Layer Developer Dashboard.
 *
 * @type {String}
 */
ClientAuthenticator.prototype.appId = '';

/**
 * Identity information about the authenticated user.
 *
 * @type {layer.Identity}
 */
ClientAuthenticator.prototype.user = null;

/**
 * Your current session token that authenticates your requests.
 *
 * @type {String}
 * @readonly
 */
ClientAuthenticator.prototype.sessionToken = '';

/**
 * URL to Layer's Web API server.
 *
 * Only muck with this if told to by Layer Staff.
 * @type {String}
 */
ClientAuthenticator.prototype.url = 'https://api.layer.com';

/**
 * URL to Layer's Websocket server.
 *
 * Only muck with this if told to by Layer Staff.
 * @type {String}
 */
ClientAuthenticator.prototype.websocketUrl = 'wss://websockets.layer.com';

/**
 * Web Socket Manager
 * @type {layer.Websockets.SocketManager}
 */
ClientAuthenticator.prototype.socketManager = null;

/**
 * Web Socket Request Manager
 * @type {layer.Websockets.RequestManager}
 */
ClientAuthenticator.prototype.socketRequestManager = null;

/**
 * Web Socket Manager
 * @type {layer.Websockets.ChangeManager}
 */
ClientAuthenticator.prototype.socketChangeManager = null;

/**
 * Service for managing online as well as offline server requests
 * @type {layer.SyncManager}
 */
ClientAuthenticator.prototype.syncManager = null;

/**
 * Service for managing online/offline state and events
 * @type {layer.OnlineStateManager}
 */
ClientAuthenticator.prototype.onlineManager = null;

/**
 * If this is a trusted device, then we can write personal data to persistent memory.
 * @type {boolean}
 */
ClientAuthenticator.prototype.isTrustedDevice = false;

/**
 * To enable indexedDB storage of query data, set this true.  Experimental.
 *
 * @property {boolean}
 */
ClientAuthenticator.prototype.isPersistenceEnabled = false;

/**
 * If this layer.Client.isTrustedDevice is true, then you can control which types of data are persisted.
 *
 * Note that values here are ignored if `isPersistenceEnabled` hasn't been set to `true`.
 *
 * Properties of this Object can be:
 *
 * * identities: Write identities to indexedDB? This allows for faster initialization.
 * * conversations: Write conversations to indexedDB? This allows for faster rendering
 *                  of a Conversation List
 * * messages: Write messages to indexedDB? This allows for full offline access
 * * syncQueue: Write requests made while offline to indexedDB?  This allows the app
 *              to complete sending messages after being relaunched.
 * * sessionToken: Write the session token to localStorage for quick reauthentication on relaunching the app.
 *
 *      new layer.Client({
 *        isTrustedDevice: true,
 *        persistenceFeatures: {
 *          conversations: true,
 *          identities: true,
 *          messages: false,
 *          syncQueue: false,
 *          sessionToken: true
 *        }
 *      });
 *
 * @type {Object}
 */
ClientAuthenticator.prototype.persistenceFeatures = null;

/**
 * Database Manager for read/write to IndexedDB
 * @type {layer.DbManager}
 */
ClientAuthenticator.prototype.dbManager = null;

/**
 * If a display name is not loaded for the session owner, use this name.
 *
 * @type {string}
 */
ClientAuthenticator.prototype.defaultOwnerDisplayName = 'You';

/**
 * Is true if the client is authenticated and connected to the server;
 *
 * Typically used to determine if there is a connection to the server.
 *
 * Typically used in conjunction with the `online` event.
 *
 * @type {boolean}
 */
Object.defineProperty(ClientAuthenticator.prototype, 'isOnline', {
  enumerable: true,
  get: function get() {
    return this.onlineManager && this.onlineManager.isOnline;
  }
});

/**
 * Log levels; one of:
 *
 *    * layer.Constants.LOG.NONE
 *    * layer.Constants.LOG.ERROR
 *    * layer.Constants.LOG.WARN
 *    * layer.Constants.LOG.INFO
 *    * layer.Constants.LOG.DEBUG
 *
 * @type {number}
 */
Object.defineProperty(ClientAuthenticator.prototype, 'logLevel', {
  enumerable: false,
  get: function get() {
    return logger.level;
  },
  set: function set(value) {
    logger.level = value;
  }
});

/**
 * Short hand for getting the userId of the authenticated user.
 *
 * Could also just use client.user.userId
 *
 * @type {string} userId
 */
Object.defineProperty(ClientAuthenticator.prototype, 'userId', {
  enumerable: true,
  get: function get() {
    return this.user ? this.user.userId : '';
  },
  set: function set() {}
});

/**
 * Time to be offline after which we don't do a WebSocket Events.replay,
 * but instead just refresh all our Query data.  Defaults to 30 hours.
 *
 * @type {number}
 * @static
 */
ClientAuthenticator.ResetAfterOfflineDuration = 1000 * 60 * 60 * 30;

/**
 * List of events supported by this class
 * @static
 * @protected
 * @type {string[]}
 */
ClientAuthenticator._supportedEvents = [
/**
 * The client is ready for action
 *
 *      client.on('ready', function(evt) {
 *          renderMyUI();
 *      });
 *
 * @event
 */
'ready',

/**
 * Fired when connected to the server.
 * Currently just means we have a nonce.
 * Not recommended for typical applications.
 * @event connected
 */
'connected',

/**
 * Fired when unsuccessful in obtaining a nonce.
 *
 * Not recommended for typical applications.
 * @event connected-error
 * @param {Object} event
 * @param {layer.LayerError} event.error
 */
'connected-error',

/**
 * We now have a session and any requests we send aught to work.
 * Typically you should use the ready event instead of the authenticated event.
 * @event authenticated
 */
'authenticated',

/**
 * Failed to authenticate your client.
 *
 * Either your identity-token was invalid, or something went wrong
 * using your identity-token.
 *
 * @event authenticated-error
 * @param {Object} event
 * @param {layer.LayerError} event.error
 */
'authenticated-error',

/**
 * This event fires when a session has expired or when `layer.Client.logout` is called.
 * Typically, it is enough to subscribe to the challenge event
 * which will let you reauthenticate; typical applications do not need
 * to subscribe to this.
 *
 * @event deauthenticated
 */
'deauthenticated',

/**
 * @event challenge
 * Verify the user's identity.
 *
 * This event is where you verify that the user is who we all think the user is,
 * and provide an identity token to validate that.
 *
 * ```javascript
 * client.on('challenge', function(evt) {
 *    myGetIdentityForNonce(evt.nonce, function(identityToken) {
 *      evt.callback(identityToken);
 *    });
 * });
 * ```
 *
 * @param {Object} event
 * @param {string} event.nonce - A nonce for you to provide to your identity provider
 * @param {Function} event.callback - Call this once you have an identity-token
 * @param {string} event.callback.identityToken - Identity token provided by your identity provider service
 */
'challenge',

/**
 * @event session-terminated
 * If your session has been terminated in such a way as to prevent automatic reconnect,
 *
 * this event will fire.  Common scenario: user has two tabs open;
 * one tab the user logs out (or you call client.logout()).
 * The other tab will detect that the sessionToken has been removed,
 * and will terminate its session as well.  In this scenario we do not want
 * to automatically trigger a challenge and restart the login process.
 */
'session-terminated',

/**
 * @event online
 *
 * This event is used to detect when the client is online (connected to the server)
 * or offline (still able to accept API calls but no longer able to sync to the server).
 *
 *      client.on('online', function(evt) {
 *         if (evt.isOnline) {
 *             statusDiv.style.backgroundColor = 'green';
 *         } else {
 *             statusDiv.style.backgroundColor = 'red';
 *         }
 *      });
 *
 * @param {Object} event
 * @param {boolean} event.isOnline
 */
'online'].concat(Root._supportedEvents);

Root.initClass.apply(ClientAuthenticator, [ClientAuthenticator, 'ClientAuthenticator']);

module.exports = ClientAuthenticator;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./client-utils":82,"./const":84,"./db-manager":85,"./layer-error":86,"./logger":88,"./models/identity":102,"./online-state-manager":107,"./root":116,"./sync-event":117,"./sync-manager":118,"./websockets/change-manager":123,"./websockets/request-manager":124,"./websockets/socket-manager":125,"./xhr":126}],81:[function(require,module,exports){
"use strict";

/**
 * Allows all components to have a clientId instead of a client pointer.
 * Allows an app to have multiple Clients, each with its own appId.
 * Provides a global utility that can be required by all modules for accessing
 * the client.
 *
 * @class  layer.ClientRegistry
 * @private
 */

var registry = {};

/**
 * Register a new Client; will destroy any previous client with the same appId.
 *
 * @method register
 * @param  {layer.Client} client
 */
function register(client) {
  var appId = client.appId;
  if (registry[appId] && !registry[appId].isDestroyed) {
    registry[appId].destroy();
  }
  registry[appId] = client;
}

/**
 * Removes a Client.
 *
 * @method unregister
 * @param  {layer.Client} client
 */
function unregister(client) {
  if (registry[client.appId]) delete registry[client.appId];
}

/**
 * Get a Client by appId
 *
 * @method get
 * @param  {string} appId
 * @return {layer.Client}
 */
function get(appId) {
  return registry[appId] || null;
}

function getAll() {
  return Object.keys(registry).map(function (key) {
    return registry[key];
  });
}

module.exports = {
  get: get,
  getAll: getAll,
  register: register,
  unregister: unregister
};


},{}],82:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

/**
 * Utility methods
 *
 * @class layer.ClientUtils
 */

var LayerParser = require('layer-patch');
var uuid = require('uuid');
var atob = typeof window === 'undefined' ? require('atob') : window.atob;

/* istanbul ignore next */
var LocalFileReader = typeof window === 'undefined' ? require('filereader') : window.FileReader;

/**
 * Generate a random UUID
 *
 * @method
 * @return {string}
 */
exports.generateUUID = uuid.v4;

/**
 * Returns the 'type' portion of a Layer ID.
 *
 *         switch(Utils.typeFromID(id)) {
 *             case 'conversations':
 *                 ...
 *             case 'message':
 *                 ...
 *             case: 'queries':
 *                 ...
 *         }
 *
 * Does not currently handle Layer App IDs.
 *
 * @method
 * @param  {string} id
 * @return {string}
 */
exports.typeFromID = function (id) {
  var matches = id.match(/([^/]*)(\/[^/]*)$/);
  return matches ? matches[1] : '';
};

/**
 * Returns the UUID portion of a Layer ID
 *
 * @method
 * @param  {string} id
 * @return {string}
 */
exports.uuid = function (id) {
  return (id || '').replace(/^.*\//, '');
};

exports.isEmpty = function (obj) {
  return Object.prototype.toString.apply(obj) === '[object Object]' && Object.keys(obj).length === 0;
};

/**
 * Simplified sort method.
 *
 * Provides a function to return the value to compare rather than do the comparison.
 *
 *      sortBy([{v: 3}, {v: 1}, v: 33}], function(value) {
 *          return value.v;
 *      }, false);
 *
 * @method
 * @param  {Mixed[]}   inArray      Array to sort
 * @param  {Function} fn            Function that will return a value to compare
 * @param  {Function} fn.value      Current value from inArray we are comparing, and from which a value should be extracted
 * @param  {boolean}  [reverse=false] Sort ascending (false) or descending (true)
 */
exports.sortBy = function (inArray, fn, reverse) {
  reverse = reverse ? -1 : 1;
  return inArray.sort(function (valueA, valueB) {
    var aa = fn(valueA);
    var bb = fn(valueB);
    if (aa === undefined && bb === undefined) return 0;
    if (aa === undefined && bb !== undefined) return 1;
    if (aa !== undefined && bb === undefined) return -1;
    if (aa > bb) return 1 * reverse;
    if (aa < bb) return -1 * reverse;
    return 0;
  });
};

/**
 * Quick and easy clone method.
 *
 * Does not work on circular references; should not be used
 * on objects with event listeners.
 *
 *      var newObj = Utils.clone(oldObj);
 *
 * @method
 * @param  {Object}     Object to clone
 * @return {Object}     New Object
 */
exports.clone = function (obj) {
  return JSON.parse(JSON.stringify(obj));
};

/**
 * Execute this function immediately after current processing is complete.
 *
 * A depth of up to 10 is allowed.  That means that functions you schedule using defer
 * can in turn schedule further actions.  The original actions are depth = 0; the actions scheduled
 * by your actions are depth = 1.  These new actions may in turn schedule further actions, which happen at depth = 3.
 * But to avoid infinite loops, if depth reaches 10, it clears the queue and ignores them.
 *
 * @method defer
 * @param {Function} f
 */
var setImmediateId = 0,
    setImmediateDepth = 0,


// Have we scheduled the queue to be processed? If not, this is false
setImmediateIsPending = false,


// Queue of functions to call and depth integers
setImmediateQueue = [];

// If a setImmediate callback itself calls setImmediate which in turn calls setImmediate, at what point do we suspect we have an infinite loop?
// A depth of 10 is currently considered OK, but this may need to be increased.
var setImmediateMaxDepth = 10;

// Process all callbacks in the setImmediateQueue
function setImmediateProcessor() {
  // Processing the queue is no longer scheduled; clear any scheduling info.
  setImmediateIsPending = false;
  clearTimeout(setImmediateId);
  setImmediateId = 0;

  // Our initial depth is depth 0
  setImmediateDepth = 0;
  setImmediateQueue.push(setImmediateDepth);

  // Process all functions and depths in the queue starting always with the item at index 0,
  // and removing them from the queue before processing them.
  while (setImmediateQueue.length) {
    var item = setImmediateQueue.shift();
    if (typeof item === 'function') {
      try {
        item();
      } catch (err) {
        console.error(err);
      }
    } else if (item >= setImmediateMaxDepth) {
      setImmediateQueue = [];
      console.error('Layer Error: setImmediate Max Queue Depth Exceded');
    }
  }
}

// Schedule the function to be called by adding it to the queue, and setting up scheduling if its needed.
function defer(func) {
  if (typeof func !== 'function') throw new Error('Function expected in defer');
  setImmediateQueue.push(func);

  // If postMessage has not already been called, call it
  if (!setImmediateIsPending) {
    setImmediateIsPending = true;
    if (typeof document !== 'undefined') {
      window.postMessage({ type: 'layer-set-immediate' }, '*');
    } else {
      // React Native reportedly lacks a document, and throws errors on the second parameter
      window.postMessage({ type: 'layer-set-immediate' });
    }

    // Having seen scenarios where postMessage failed to trigger, set a backup using setTimeout that will be canceled
    // if postMessage is succesfully called.
    setImmediateId = setTimeout(setImmediateProcessor, 0);
  }
}

// For Unit Testing
defer.flush = function () {
  return setImmediateProcessor();
};

addEventListener('message', function (event) {
  if (event.data.type !== 'layer-set-immediate') return;
  setImmediateProcessor();
});

exports.defer = defer;

/**
 * URL Decode a URL Encoded base64 string
 *
 * Copied from https://github.com/auth0-blog/angular-token-auth, but
 * appears in many places on the web.
 *
 * @method decode
 * @param {String} str   base64 string
 * @return str   Decoded string
 */
/* istanbul ignore next */
exports.decode = function (str) {
  var output = str.replace('-', '+').replace('_', '/');
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += '==';
      break;
    case 3:
      output += '=';
      break;
    default:
      throw new Error('Illegal base64url string!');
  }
  return atob(output);
};

/**
 * Returns a delay in seconds needed to follow an exponential
 * backoff pattern of delays for retrying a connection.
 *
 * Algorithm has two motivations:
 *
 * 1. Retry with increasingly long intervals up to some maximum interval
 * 2. Randomize the retry interval enough so that a thousand clients
 * all following the same algorithm at the same time will not hit the
 * server at the exact same times.
 *
 * The following are results before jitter for some values of counter:

      0: 0.1
      1: 0.2
      2: 0.4
      3: 0.8
      4: 1.6
      5: 3.2
      6: 6.4
      7: 12.8
      8: 25.6
      9: 51.2
      10: 102.4
      11. 204.8
      12. 409.6
      13. 819.2
      14. 1638.4 (27 minutes)

 * @method getExponentialBackoffSeconds
 * @param  {number} maxSeconds - This is not the maximum seconds delay, but rather
 * the maximum seconds delay BEFORE adding a randomized value.
 * @param  {number} counter - Current counter to use for calculating the delay; should be incremented up to some reasonable maximum value for each use.
 * @return {number}     Delay in seconds/fractions of a second
 */
exports.getExponentialBackoffSeconds = function getExponentialBackoffSeconds(maxSeconds, counter) {
  var secondsWaitTime = Math.pow(2, counter) / 10,
      secondsOffset = Math.random(); // value between 0-1 seconds.
  if (counter < 2) secondsOffset = secondsOffset / 4; // values less than 0.2 should be offset by 0-0.25 seconds
  else if (counter < 6) secondsOffset = secondsOffset / 2; // values between 0.2 and 1.0 should be offset by 0-0.5 seconds

  if (secondsWaitTime >= maxSeconds) secondsWaitTime = maxSeconds;

  return secondsWaitTime + secondsOffset;
};

/**
 * Is this data a blob?
 *
 * @method isBlob
 * @param {Mixed} value
 * @returns {Boolean} - True if its a blob, false if not.
 */
exports.isBlob = function (value) {
  return typeof Blob !== 'undefined' && value instanceof Blob;
};

/**
 * Given a blob return a base64 string.
 *
 * @method blobToBase64
 * @param {Blob} blob - data to convert to base64
 * @param {Function} callback
 * @param {String} callback.result - Your base64 string result
 */
exports.blobToBase64 = function (blob, callback) {
  var reader = new LocalFileReader();
  reader.readAsDataURL(blob);
  reader.onloadend = function () {
    return callback(reader.result.replace(/^.*?,/, ''));
  };
};

/**
 * Given a base64 string return a blob.
 *
 * @method base64ToBlob
 * @param {String} b64Data - base64 string data without any type prefixes
 * @param {String} contentType - mime type of the data
 * @returns {Blob}
 */
exports.base64ToBlob = function (b64Data, contentType) {
  try {
    var sliceSize = 512;
    var byteCharacters = atob(b64Data);
    var byteArrays = [];
    var offset = void 0;

    for (offset = 0; offset < byteCharacters.length; offset += sliceSize) {
      var i = void 0;
      var slice = byteCharacters.slice(offset, offset + sliceSize);
      var byteNumbers = new Array(slice.length);
      for (i = 0; i < slice.length; i++) {
        byteNumbers[i] = slice.charCodeAt(i);
      }

      var byteArray = new Uint8Array(byteNumbers);

      byteArrays.push(byteArray);
    }

    var blob = new Blob(byteArrays, { type: contentType });
    return blob;
  } catch (e) {
    // noop
  }
  return null;
};

/**
 * Does window.btao() in a unicode-safe way
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa#Unicode_strings
 *
 * @method utoa
 * @param {String} str
 * @return {String}
 */
exports.utoa = function (str) {
  return btoa(unescape(encodeURIComponent(str)));
};

/**
 * Does window.atob() in a way that can decode data from utoa()
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa#Unicode_strings
 *
 * @method atou
 * @param {String} str
 * @return {String}
 */
exports.atou = function (str) {
  return decodeURIComponent(escape(atob(str)));
};

/**
 * Given a File/Blob return a string.
 *
 * Assumes blob represents textual data.
 *
 * @method fetchTextFromFile
 * @param {Blob} file
 * @param {Function} callback
 * @param {String} callback.result
 */
exports.fetchTextFromFile = function (file, callback) {
  if (typeof file === 'string') return callback(file);
  var reader = new LocalFileReader();
  reader.addEventListener('loadend', function () {
    callback(reader.result);
  });
  reader.readAsText(file);
};

var parser = void 0;

/**
 * Creates a LayerParser
 *
 * @method
 * @private
 * @param {Object} request - see layer.ClientUtils.layerParse
 */
function createParser(request) {
  request.client.once('destroy', function () {
    return parser = null;
  });

  parser = new LayerParser({
    camelCase: true,
    getObjectCallback: function getObjectCallback(id) {
      return request.client.getObject(id);
    },
    createObjectCallback: function createObjectCallback(id, obj) {
      return request.client._createObject(obj);
    },
    propertyNameMap: {
      Conversation: {
        unreadMessageCount: 'unreadCount'
      },
      Identity: {
        presence: '_presence'
      }
    },
    changeCallbacks: {
      Message: {
        all: function all(updateObject, newValue, oldValue, paths) {
          updateObject._handlePatchEvent(newValue, oldValue, paths);
        }
      },
      Conversation: {
        all: function all(updateObject, newValue, oldValue, paths) {
          updateObject._handlePatchEvent(newValue, oldValue, paths);
        }
      },
      Channel: {
        all: function all(updateObject, newValue, oldValue, paths) {
          updateObject._handlePatchEvent(newValue, oldValue, paths);
        }
      },
      Identity: {
        all: function all(updateObject, newValue, oldValue, paths) {
          updateObject._handlePatchEvent(newValue, oldValue, paths);
        }
      }
    }
  });
}

/**
 * Run the Layer Parser on the request.
 *
 * Parameters here
 * are the parameters specied in [Layer-Patch](https://github.com/layerhq/node-layer-patch), plus
 * a client object.
 *
 *      Util.layerParse({
 *          object: conversation,
 *          type: 'Conversation',
 *          operations: layerPatchOperations,
 *          client: client
 *      });
 *
 * @method
 * @param {Object} request - layer-patch parameters
 * @param {Object} request.object - Object being updated  by the operations
 * @param {string} request.type - Type of object being updated
 * @param {Object[]} request.operations - Array of change operations to perform upon the object
 * @param {layer.Client} request.client
 */
exports.layerParse = function (request) {
  if (!parser) createParser(request);
  parser.parse(request);
};

/**
 * Object comparison.
 *
 * Does a recursive traversal of two objects verifying that they are the same.
 * Is able to make metadata-restricted assumptions such as that
 * all values are either plain Objects or strings.
 *
 *      if (Utils.doesObjectMatch(conv1.metadata, conv2.metadata)) {
 *          alert('These two metadata objects are the same');
 *      }
 *
 * @method
 * @param  {Object} requestedData
 * @param  {Object} actualData
 * @return {boolean}
 */
exports.doesObjectMatch = function (requestedData, actualData) {
  if (!requestedData && actualData || requestedData && !actualData) return false;
  var requestedKeys = Object.keys(requestedData).sort();
  var actualKeys = Object.keys(actualData).sort();

  // If there are a different number of keys, fail.
  if (requestedKeys.length !== actualKeys.length) return false;

  // Compare key name and value at each index
  for (var index = 0; index < requestedKeys.length; index++) {
    var k1 = requestedKeys[index];
    var k2 = actualKeys[index];
    var v1 = requestedData[k1];
    var v2 = actualData[k2];
    if (k1 !== k2) return false;
    if (v1 && (typeof v1 === 'undefined' ? 'undefined' : _typeof(v1)) === 'object') {
      // Array comparison is not used by the Web SDK at this time.
      if (Array.isArray(v1)) {
        throw new Error('Array comparison not handled yet');
      } else if (!exports.doesObjectMatch(v1, v2)) {
        return false;
      }
    } else if (v1 !== v2) {
      return false;
    }
  }
  return true;
};

/**
 * Simple array inclusion test
 * @method includes
 * @param {Mixed[]} items
 * @param {Mixed} value
 * @returns {boolean}
 */
exports.includes = function (items, value) {
  return items.indexOf(value) !== -1;
};

/**
 * Some ASCII art when client initializes
 */
exports.asciiInit = function (version) {
  if (!version) return 'Missing version';

  var split = version.split('-');
  var line1 = split[0] || '',
      line2 = split[1] || '';

  line1 += new Array(13 - line1.length).join(' ');
  line2 += new Array(14 - line2.length).join(' ');

  return '\n    /hNMMMMMMMMMMMMMMMMMMMms.\n  hMMy+/////////////////omMN-        \'oo.\n  MMN                    oMMo        .MM/\n  MMN                    oMMo        .MM/              ....                       ....            ...\n  MMN       Web SDK      oMMo        .MM/           ohdddddddo\' +md.      smy  -sddddddho.   hmosddmm.\n  MMM-                   oMMo        .MM/           ::.\'  \'.mM+ \'hMd\'    +Mm. +Nm/\'   .+Nm-  mMNs-\'.\n  MMMy      v' + line1 + 'oMMo        .MM/             .-:/+yNMs  .mMs   /MN: .MMs///////dMh  mMy\n  MMMMo     ' + line2 + 'oMMo        .MM/          .ymhyso+:hMs   :MM/ -NM/  :MMsooooooooo+  mM+\n  MMMMMy.                oMMo        .MM/          dMy\'    \'dMs    +MN:mM+   \'NMo            mM+\n  MMMMMMNy:\'             oMMo        .MMy++++++++: sMm/---/dNMs     yMMMs     -dMd+:-:/smy\'  mM+\n  NMMMMMMMMmy+:-.\'      \'yMM/        \'yyyyyyyyyyyo  :shhhys:+y/     .MMh       \'-oyhhhys:\'   sy:\n  :dMMMMMMMMMMMMNNNNNNNNNMNs                                        hMd\'\n   -/+++++++++++++++++++:\'                                      sNmdo\'';
};


},{"atob":10,"filereader":10,"layer-patch":128,"uuid":130}],83:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Layer Client; this is the top level component for any Layer based application.

    var client = new layer.Client({
      appId: 'layer:///apps/staging/ffffffff-ffff-ffff-ffff-ffffffffffff',
      challenge: function(evt) {
        myAuthenticator({
          nonce: evt.nonce,
          onSuccess: evt.callback
        });
      },
      ready: function(client) {
        alert('I am Client; Server: Serve me!');
      }
    }).connect('Fred')
 *
 * You can also initialize this as

    var client = new layer.Client({
      appId: 'layer:///apps/staging/ffffffff-ffff-ffff-ffff-ffffffffffff'
    });

    client.on('challenge', function(evt) {
      myAuthenticator({
        nonce: evt.nonce,
        onSuccess: evt.callback
      });
    });

    client.on('ready', function(client) {
      alert('I am Client; Server: Serve me!');
    });

    client.connect('Fred');
 *
 * ## API Synopsis:
 *
 * The following Properties, Methods and Events are the most commonly used ones.  See the full API below
 * for the rest of the API.
 *
 * ### Properties:
 *
 * * layer.Client.userId: User ID of the authenticated user
 * * layer.Client.appId: The ID for your application
 *
 *
 * ### Methods:
 *
 * * layer.Client.createConversation(): Create a new layer.Conversation.
 * * layer.Client.createQuery(): Create a new layer.Query.
 * * layer.Client.getMessage(): Input a Message ID, and output a layer.Message or layer.Announcement from cache.
 * * layer.Client.getConversation(): Input a Conversation ID, and output a layer.Conversation from cache.
 * * layer.Client.on() and layer.Conversation.off(): event listeners
 * * layer.Client.destroy(): Cleanup all resources used by this client, including all Messages and Conversations.
 *
 * ### Events:
 *
 * * `challenge`: Provides a nonce and a callback; you call the callback once you have an Identity Token.
 * * `ready`: Your application can now start using the Layer services
 * * `messages:notify`: Used to notify your application of new messages for which a local notification may be suitable.
 *
 * ## Logging:
 *
 * There are two ways to change the log level for Layer's logger:
 *
 *     layer.Client.prototype.logLevel = layer.Constants.LOG.INFO;
 *
 * or
 *
 *     var client = new layer.Client({
 *        appId: 'layer:///apps/staging/ffffffff-ffff-ffff-ffff-ffffffffffff',
 *        logLevel: layer.Constants.LOG.INFO
 *     });
 *
 * @class  layer.Client
 * @extends layer.ClientAuthenticator
 * @mixin layer.mixins.ClientIdentities
 * //@ mixin layer.mixins.ClientMembership
 * @mixin layer.mixins.ClientConversations
 * //@ mixin layer.mixins.ClientChannels
 * @mixin layer.mixins.ClientMessages
 * @mixin layer.mixins.ClientQueries
 */

var ClientAuth = require('./client-authenticator');
var Conversation = require('./models/conversation');
var Channel = require('./models/channel');
var ErrorDictionary = require('./layer-error').dictionary;
var ConversationMessage = require('./models/conversation-message');
var ChannelMessage = require('./models/channel-message');
var Announcement = require('./models/announcement');
var Identity = require('./models/identity');
var Membership = require('./models/membership');
var TypingIndicatorListener = require('./typing-indicators/typing-indicator-listener');
var Util = require('./client-utils');
var Root = require('./root');
var ClientRegistry = require('./client-registry');
var logger = require('./logger');
var TypingListener = require('./typing-indicators/typing-listener');
var TypingPublisher = require('./typing-indicators/typing-publisher');

var Client = function (_ClientAuth) {
  _inherits(Client, _ClientAuth);

  /*
   * Adds conversations, messages and websockets on top of the authentication client.
   * jsdocs on parent class constructor.
   */
  function Client(options) {
    _classCallCheck(this, Client);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Client).call(this, options));

    ClientRegistry.register(_this);
    _this._models = {};
    _this._runMixins('constructor', [options]);

    // Initialize Properties
    _this._scheduleCheckAndPurgeCacheItems = [];

    _this._initComponents();

    _this.on('online', _this._connectionRestored.bind(_this));

    logger.info(Util.asciiInit(Client.version));
    return _this;
  }

  /* See parent method docs */


  _createClass(Client, [{
    key: '_initComponents',
    value: function _initComponents() {
      _get(Object.getPrototypeOf(Client.prototype), '_initComponents', this).call(this);

      this._typingIndicators = new TypingIndicatorListener({
        clientId: this.appId
      });
    }

    /**
     * Cleanup all resources (Conversations, Messages, etc...) prior to destroy or reauthentication.
     *
     * @method _cleanup
     * @private
     */

  }, {
    key: '_cleanup',
    value: function _cleanup() {
      if (this.isDestroyed) return;
      this._inCleanup = true;

      try {
        this._runMixins('cleanup', []);
      } catch (e) {
        logger.error(e);
      }

      if (this.socketManager) this.socketManager.close();
      this._inCleanup = false;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      // Cleanup all resources (Conversations, Messages, etc...)
      this._cleanup();

      this._destroyComponents();

      ClientRegistry.unregister(this);

      _get(Object.getPrototypeOf(Client.prototype), 'destroy', this).call(this);
      this._inCleanup = false;
    }
  }, {
    key: '__adjustAppId',
    value: function __adjustAppId() {
      if (this.appId) throw new Error(ErrorDictionary.appIdImmutable);
    }

    /**
     * Takes an array of Identity instances, User IDs, Identity IDs, Identity objects,
     * or Server formatted Identity Objects and returns an array of Identity instances.
     *
     * @method _fixIdentities
     * @private
     * @param {Mixed[]} identities - Something that tells us what Identity to return
     * @return {layer.Identity[]}
     */

  }, {
    key: '_fixIdentities',
    value: function _fixIdentities(identities) {
      var _this2 = this;

      return identities.map(function (identity) {
        if (identity instanceof Identity) return identity;
        if (typeof identity === 'string') {
          return _this2.getIdentity(identity, true);
        } else if (identity && (typeof identity === 'undefined' ? 'undefined' : _typeof(identity)) === 'object') {
          if ('userId' in identity) {
            return _this2.getIdentity(identity.id || identity.userId);
          } else if ('user_id' in identity) {
            return _this2._createObject(identity);
          }
        }
        return null;
      });
    }

    /**
     * Takes as input an object id, and either calls getConversation() or getMessage() as needed.
     *
     * Will only get cached objects, will not get objects from the server.
     *
     * This is not a public method mostly so there's no ambiguity over using getXXX
     * or getObject.  getXXX typically has an option to load the resource, which this
     * does not.
     *
     * @method getObject
     * @param  {string} id - Message, Conversation or Query id
     * @param  {boolean} [canLoad=false] - Pass true to allow loading a object from
     *                                     the server if not found (not supported for all objects)
     * @return {layer.Message|layer.Conversation|layer.Query}
     */

  }, {
    key: 'getObject',
    value: function getObject(id) {
      var canLoad = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      switch (Util.typeFromID(id)) {
        case 'messages':
        case 'announcements':
          return this.getMessage(id, canLoad);
        case 'conversations':
          return this.getConversation(id, canLoad);
        case 'channels':
          return this.getChannel(id, canLoad);
        case 'queries':
          return this.getQuery(id);
        case 'identities':
          return this.getIdentity(id, canLoad);
        case 'members':
          return this.getMember(id, canLoad);
      }
      return null;
    }

    /**
     * Takes an object description from the server and either updates it (if cached)
     * or creates and caches it .
     *
     * @method _createObject
     * @protected
     * @param  {Object} obj - Plain javascript object representing a Message or Conversation
     */

  }, {
    key: '_createObject',
    value: function _createObject(obj) {
      var item = this.getObject(obj.id);
      if (item) {
        item._populateFromServer(obj);
        return item;
      } else {
        switch (Util.typeFromID(obj.id)) {
          case 'messages':
            if (obj.conversation) {
              return ConversationMessage._createFromServer(obj, this);
            } else if (obj.channel) {
              return ChannelMessage._createFromServer(obj, this);
            }
            break;
          case 'announcements':
            return Announcement._createFromServer(obj, this);
          case 'conversations':
            return Conversation._createFromServer(obj, this);
          case 'channels':
            return Channel._createFromServer(obj, this);
          case 'identities':
            return Identity._createFromServer(obj, this);
          case 'members':
            return Membership._createFromServer(obj, this);
        }
      }
      return null;
    }

    /**
     * When a layer.Container's ID changes, we need to update
     * a variety of things and trigger events.
     *
     * @method _updateContainerId
     * @param {layer.Container} container
     * @param {String} oldId
     */

  }, {
    key: '_updateContainerId',
    value: function _updateContainerId(container, oldId) {
      if (container instanceof Conversation) {
        this._updateConversationId(container, oldId);
      } else {
        this._updateChannelId(container, oldId);
      }
    }

    /**
     * Merge events into smaller numbers of more complete events.
     *
     * Before any delayed triggers are fired, fold together all of the conversations:add
     * and conversations:remove events so that 100 conversations:add events can be fired as
     * a single event.
     *
     * @method _processDelayedTriggers
     * @private
     */

  }, {
    key: '_processDelayedTriggers',
    value: function _processDelayedTriggers() {
      if (this.isDestroyed) return;

      var addConversations = this._delayedTriggers.filter(function (evt) {
        return evt[0] === 'conversations:add';
      });
      var removeConversations = this._delayedTriggers.filter(function (evt) {
        return evt[0] === 'conversations:remove';
      });
      this._foldEvents(addConversations, 'conversations', this);
      this._foldEvents(removeConversations, 'conversations', this);

      var addMessages = this._delayedTriggers.filter(function (evt) {
        return evt[0] === 'messages:add';
      });
      var removeMessages = this._delayedTriggers.filter(function (evt) {
        return evt[0] === 'messages:remove';
      });

      this._foldEvents(addMessages, 'messages', this);
      this._foldEvents(removeMessages, 'messages', this);

      var addIdentities = this._delayedTriggers.filter(function (evt) {
        return evt[0] === 'identities:add';
      });
      var removeIdentities = this._delayedTriggers.filter(function (evt) {
        return evt[0] === 'identities:remove';
      });

      this._foldEvents(addIdentities, 'identities', this);
      this._foldEvents(removeIdentities, 'identities', this);

      _get(Object.getPrototypeOf(Client.prototype), '_processDelayedTriggers', this).call(this);
    }
  }, {
    key: 'trigger',
    value: function trigger(eventName, evt) {
      this._triggerLogger(eventName, evt);
      _get(Object.getPrototypeOf(Client.prototype), 'trigger', this).call(this, eventName, evt);
    }

    /**
     * Does logging on all triggered events.
     *
     * All logging is done at `debug` or `info` levels.
     *
     * @method _triggerLogger
     * @private
     */

  }, {
    key: '_triggerLogger',
    value: function _triggerLogger(eventName, evt) {
      var infoEvents = ['conversations:add', 'conversations:remove', 'conversations:change', 'messages:add', 'messages:remove', 'messages:change', 'identities:add', 'identities:remove', 'identities:change', 'challenge', 'ready'];
      if (infoEvents.indexOf(eventName) !== -1) {
        if (evt && evt.isChange) {
          logger.info('Client Event: ' + eventName + ' ' + evt.changes.map(function (change) {
            return change.property;
          }).join(', '));
        } else {
          var text = '';
          if (evt) {
            // If the triggered event has these messages, use a simpler way of rendering info about them
            if (evt.message) text = evt.message.id;
            if (evt.messages) text = evt.messages.length + ' messages';
            if (evt.conversation) text = evt.conversation.id;
            if (evt.conversations) text = evt.conversations.length + ' conversations';
            if (evt.channel) text = evt.channel.id;
            if (evt.channels) text = evt.channels.length + ' channels';
          }
          logger.info('Client Event: ' + eventName + ' ' + text);
        }
        if (evt) logger.debug(evt);
      } else {
        logger.debug(eventName, evt);
      }
    }

    /**
     * If the session has been reset, dump all data.
     *
     * @method _resetSession
     * @private
     */

  }, {
    key: '_resetSession',
    value: function _resetSession() {
      this._cleanup();
      this._runMixins('reset', []);
      return _get(Object.getPrototypeOf(Client.prototype), '_resetSession', this).call(this);
    }

    /**
     * Check to see if the specified objects can safely be removed from cache.
     *
     * Removes from cache if an object is not part of any Query's result set.
     *
     * @method _checkAndPurgeCache
     * @private
     * @param  {layer.Root[]} objects - Array of Messages or Conversations
     */

  }, {
    key: '_checkAndPurgeCache',
    value: function _checkAndPurgeCache(objects) {
      var _this3 = this;

      objects.forEach(function (obj) {
        if (!obj.isDestroyed && !_this3._isCachedObject(obj)) {
          if (obj instanceof Root === false) obj = _this3.getObject(obj.id);
          if (obj) obj.destroy();
        }
      });
    }

    /**
     * Schedules _runScheduledCheckAndPurgeCache if needed, and adds this object
     * to the list of objects it will validate for uncaching.
     *
     * Note that any object that does not exist on the server (!isSaved()) is an object that the
     * app created and can only be purged by the app and not by the SDK.  Once its been
     * saved, and can be reloaded from the server when needed, its subject to standard caching.
     *
     * @method _scheduleCheckAndPurgeCache
     * @private
     * @param {layer.Root} object
     */

  }, {
    key: '_scheduleCheckAndPurgeCache',
    value: function _scheduleCheckAndPurgeCache(object) {
      var _this4 = this;

      if (object.isSaved()) {
        if (this._scheduleCheckAndPurgeCacheAt < Date.now()) {
          this._scheduleCheckAndPurgeCacheAt = Date.now() + Client.CACHE_PURGE_INTERVAL;
          setTimeout(function () {
            return _this4._runScheduledCheckAndPurgeCache();
          }, Client.CACHE_PURGE_INTERVAL);
        }
        this._scheduleCheckAndPurgeCacheItems.push(object);
      }
    }

    /**
     * Calls _checkAndPurgeCache on accumulated objects and resets its state.
     *
     * @method _runScheduledCheckAndPurgeCache
     * @private
     */

  }, {
    key: '_runScheduledCheckAndPurgeCache',
    value: function _runScheduledCheckAndPurgeCache() {
      var list = this._scheduleCheckAndPurgeCacheItems;
      this._scheduleCheckAndPurgeCacheItems = [];
      this._checkAndPurgeCache(list);
      this._scheduleCheckAndPurgeCacheAt = 0;
    }

    /**
     * Returns true if the specified object should continue to be part of the cache.
     *
     * Result is based on whether the object is part of the data for a Query.
     *
     * @method _isCachedObject
     * @private
     * @param  {layer.Root} obj - A Message or Conversation Instance
     * @return {Boolean}
     */

  }, {
    key: '_isCachedObject',
    value: function _isCachedObject(obj) {
      var list = Object.keys(this._models.queries);
      for (var i = 0; i < list.length; i++) {
        var query = this._models.queries[list[i]];
        if (query._getItem(obj.id)) return true;
      }
      return false;
    }

    /**
     * On restoring a connection, determine what steps need to be taken to update our data.
     *
     * A reset boolean property is passed; set based on  layer.ClientAuthenticator.ResetAfterOfflineDuration.
     *
     * Note it is possible for an application to have logic that causes queries to be created/destroyed
     * as a side-effect of layer.Query.reset destroying all data. So we must test to see if queries exist.
     *
     * @method _connectionRestored
     * @private
     * @param {boolean} reset - Should the session reset/reload all data or attempt to resume where it left off?
     */

  }, {
    key: '_connectionRestored',
    value: function _connectionRestored(evt) {
      var _this5 = this;

      if (evt.reset) {
        logger.debug('Client Connection Restored; Resetting all Queries');
        this.dbManager.deleteTables(function () {
          _this5.dbManager._open();
          Object.keys(_this5._models.queries).forEach(function (id) {
            var query = _this5._models.queries[id];
            if (query) query.reset();
          });
        });
      }
    }

    /**
     * Creates a layer.TypingIndicators.TypingListener instance
     * bound to the specified dom node.
     *
     *      var typingListener = client.createTypingListener(document.getElementById('myTextBox'));
     *      typingListener.setConversation(mySelectedConversation);
     *
     * Use this method to instantiate a listener, and call
     * layer.TypingIndicators.TypingListener.setConversation every time you want to change which Conversation
     * it reports your user is typing into.
     *
     * @method createTypingListener
     * @param  {HTMLElement} inputNode - Text input to watch for keystrokes
     * @return {layer.TypingIndicators.TypingListener}
     */

  }, {
    key: 'createTypingListener',
    value: function createTypingListener(inputNode) {
      return new TypingListener({
        clientId: this.appId,
        input: inputNode
      });
    }

    /**
     * Creates a layer.TypingIndicators.TypingPublisher.
     *
     * The TypingPublisher lets you manage your Typing Indicators without using
     * the layer.TypingIndicators.TypingListener.
     *
     *      var typingPublisher = client.createTypingPublisher();
     *      typingPublisher.setConversation(mySelectedConversation);
     *      typingPublisher.setState(layer.TypingIndicators.STARTED);
     *
     * Use this method to instantiate a listener, and call
     * layer.TypingIndicators.TypingPublisher.setConversation every time you want to change which Conversation
     * it reports your user is typing into.
     *
     * Use layer.TypingIndicators.TypingPublisher.setState to inform other users of your current state.
     * Note that the `STARTED` state only lasts for 2.5 seconds, so you
     * must repeatedly call setState for as long as this state should continue.
     * This is typically done by simply calling it every time a user hits
     * a key.
     *
     * @method createTypingPublisher
     * @return {layer.TypingIndicators.TypingPublisher}
     */

  }, {
    key: 'createTypingPublisher',
    value: function createTypingPublisher() {
      return new TypingPublisher({
        clientId: this.appId
      });
    }

    /**
     * Get the current typing indicator state of a specified Conversation.
     *
     * Typically used to see if anyone is currently typing when first opening a Conversation.
     *
     * @method getTypingState
     * @param {String} conversationId
     */

  }, {
    key: 'getTypingState',
    value: function getTypingState(conversationId) {
      return this._typingIndicators.getState(conversationId);
    }

    /**
     * Accessor for getting a Client by appId.
     *
     * Most apps will only have one client,
     * and will not need this method.
     *
     * @method getClient
     * @static
     * @param  {string} appId
     * @return {layer.Client}
     */

  }], [{
    key: 'getClient',
    value: function getClient(appId) {
      return ClientRegistry.get(appId);
    }
  }, {
    key: 'destroyAllClients',
    value: function destroyAllClients() {
      ClientRegistry.getAll().forEach(function (client) {
        return client.destroy();
      });
    }
  }]);

  return Client;
}(ClientAuth);

/**
 * Array of items to be checked to see if they can be uncached.
 *
 * @private
 * @type {layer.Root[]}
 */


Client.prototype._scheduleCheckAndPurgeCacheItems = null;

/**
 * Time that the next call to _runCheckAndPurgeCache() is scheduled for in ms since 1970.
 *
 * @private
 * @type {number}
 */
Client.prototype._scheduleCheckAndPurgeCacheAt = 0;

/**
 * Get the version of the Client library.
 *
 * @static
 * @type {String}
 */
Client.version = '3.2.0';

/**
 * Any Conversation or Message that is part of a Query's results are kept in memory for as long as it
 * remains in that Query.  However, when a websocket event delivers new Messages and Conversations that
 * are NOT part of a Query, how long should they stick around in memory?  Why have them stick around?
 * Perhaps an app wants to post a notification of a new Message or Conversation... and wants to keep
 * the object local for a little while.  Default is 10 minutes before checking to see if
 * the object is part of a Query or can be uncached.  Value is in miliseconds.
 * @static
 * @type {number}
 */
Client.CACHE_PURGE_INTERVAL = 10 * 60 * 1000;

Client._ignoredEvents = ['conversations:loaded', 'conversations:loaded-error'];

Client._supportedEvents = [
/**
 * A Typing Indicator state has changed.
 *
 * Either a change has been received
 * from the server, or a typing indicator state has expired.
 *
 *      client.on('typing-indicator-change', function(evt) {
 *          if (evt.conversationId === myConversationId) {
 *              alert(evt.typing.join(', ') + ' are typing');
 *              alert(evt.paused.join(', ') + ' are paused');
 *          }
 *      });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {string} conversationId - ID of the Conversation users are typing into
 * @param {string[]} typing - Array of user IDs who are currently typing
 * @param {string[]} paused - Array of user IDs who are currently paused;
 *                            A paused user still has text in their text box.
 */
'typing-indicator-change'].concat(ClientAuth._supportedEvents);

Client.mixins = [require('./mixins/client-queries'), require('./mixins/client-identities'), require('./mixins/client-members'), require('./mixins/client-conversations'), require('./mixins/client-channels'), require('./mixins/client-messages')];
Root.initClass.apply(Client, [Client, 'Client']);
module.exports = Client;


},{"./client-authenticator":80,"./client-registry":81,"./client-utils":82,"./layer-error":86,"./logger":88,"./mixins/client-channels":89,"./mixins/client-conversations":90,"./mixins/client-identities":91,"./mixins/client-members":92,"./mixins/client-messages":93,"./mixins/client-queries":94,"./models/announcement":95,"./models/channel":97,"./models/channel-message":96,"./models/conversation":101,"./models/conversation-message":100,"./models/identity":102,"./models/membership":103,"./root":116,"./typing-indicators/typing-indicator-listener":119,"./typing-indicators/typing-listener":121,"./typing-indicators/typing-publisher":122}],84:[function(require,module,exports){
'use strict';

/**
 * Layer Constants are stored in two places:
 *
 * 1. As part of the layer.Constants singleton
 * 2. As static properties on classes.
 *
 * Typically the static property constants are designed to be changed by developers to customize behaviors,
 * and tend to only be used by that single class.
 *
 * @class layer.Constants
 * @singleton
 */
module.exports = {
  /**
   * Is the object synchronized with the server?
   * @property {Object} [SYNC_STATE=null]
   * @property {string} SYNC_STATE.NEW      - Object is newly created, was created locally, not from server data, and has not yet been sent to the server.
   * @property {string} SYNC_STATE.SAVING   - Object is newly created and is being sent to the server.
   * @property {string} SYNC_STATE.SYNCING  - Object exists both locally and on server but is being synced with changes.
   * @property {string} SYNC_STATE.SYNCED   - Object exists both locally and on server and at last check was in sync.
   * @property {string} SYNC_STATE.LOADING  - Object is being loaded from the server and may not have its properties set yet.
   */
  SYNC_STATE: {
    NEW: 'NEW',
    SAVING: 'SAVING',
    SYNCING: 'SYNCING',
    SYNCED: 'SYNCED',
    LOADING: 'LOADING'
  },

  /**
   * Values for readStatus/deliveryStatus
   * @property {Object} [RECIPIENT_STATE=]
   * @property {string} RECIPIENT_STATE.NONE - No users have read (or received) this Message
   * @property {string} RECIPIENT_STATE.SOME - Some users have read (or received) this Message
   * @property {string} RECIPIENT_STATE.ALL  - All users have read (or received) this Message
   */
  RECIPIENT_STATE: {
    NONE: 'NONE',
    SOME: 'SOME',
    ALL: 'ALL'
  },

  /**
   * Values for recipientStatus
   * @property {Object} [RECEIPT_STATE=]
   * @property {string} RECEIPT_STATE.SENT      - The Message has been sent to the specified user but it has not yet been received by their device.
   * @property {string} RECEIPT_STATE.DELIVERED - The Message has been delivered to the specified use but has not yet been read.
   * @property {string} RECEIPT_STATE.READ      - The Message has been read by the specified user.
   * @property {string} RECEIPT_STATE.PENDING   - The request to send this Message to the specified user has not yet been received by the server.
   */
  RECEIPT_STATE: {
    SENT: 'sent',
    DELIVERED: 'delivered',
    READ: 'read',
    PENDING: 'pending'
  },
  LOCALSTORAGE_KEYS: {
    SESSIONDATA: 'layer-session-data-'
  },
  ACCEPT: 'application/vnd.layer+json; version=2.0',
  WEBSOCKET_PROTOCOL: 'layer-2.0',

  /**
   * Log levels
   * @property {Object} [LOG=]
   * @property {number} LOG.DEBUG     Log detailed information about requests, responses, events, state changes, etc...
   * @property {number} LOG.INFO      Log sparse information about requests, responses and events
   * @property {number} LOG.WARN      Log failures that are expected, normal, handled, but suggests that an operation didn't complete as intended
   * @property {number} LOG.ERROR     Log failures that are not expected or could not be handled
   * @property {number} LOG.NONE      Logs? Who needs em?
   */
  LOG: {
    DEBUG: 4,
    INFO: 3,
    WARN: 2,
    ERROR: 1,
    NONE: 0
  },

  /**
   * Deletion Modes
   * @property {Object} [DELETION_MODE=]
   * @property {number} DELETION_MODE.ALL          Delete Message/Conversation for All users but remain in the Conversation;
   *                                               new Messages will restore this Conversation minus any Message History prior to deletion.
   * @property {number} DELETION_MODE.MY_DEVICES   Delete Message or Conversation; but see layer.Conversation.leave if you want to delete
   *                                               a Conversation and not have it come back.
   */
  DELETION_MODE: {
    ALL: 'all_participants',
    MY_DEVICES: 'my_devices'
  }
};


},{}],85:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Persistence manager.
 *
 * This class manages all indexedDB access.  It is not responsible for any localStorage access, though it may
 * receive configurations related to data stored in localStorage.  It will simply ignore those configurations.
 *
 * Rich Content will be written to IndexedDB as long as its small; see layer.DbManager.MaxPartSize for more info.
 *
 * TODO:
 * 0. Redesign this so that knowledge of the data is not hard-coded in
 * @class layer.DbManager
 * @protected
 */

var Root = require('./root');
var logger = require('./logger');
var SyncEvent = require('./sync-event');
var Constants = require('./const');
var Util = require('./client-utils');
var Announcement = require('./models/announcement');

var DB_VERSION = 5;
var MAX_SAFE_INTEGER = 9007199254740991;
var SYNC_NEW = Constants.SYNC_STATE.NEW;

function getDate(inDate) {
  return inDate ? inDate.toISOString() : null;
}

var TABLES = [{
  name: 'conversations',
  indexes: {
    created_at: ['created_at'],
    last_message_sent: ['last_message_sent']
  }
}, {
  name: 'channels',
  indexes: {
    created_at: ['created_at']
  }
}, {
  name: 'messages',
  indexes: {
    conversationId: ['conversationId', 'position']
  }
}, {
  name: 'identities',
  indexes: {}
}, {
  name: 'syncQueue',
  indexes: {}
}];

var DbManager = function (_Root) {
  _inherits(DbManager, _Root);

  /**
   * Create the DB Manager
   *
   * Key configuration is the layer.DbManager.persistenceFeatures property.
   *
   * @method constructor
   * @param {Object} options
   * @param {layer.Client} options.client
   * @param {Object} options.persistenceFeatures
   * @return {layer.DbManager} this
   */
  function DbManager(options) {
    _classCallCheck(this, DbManager);

    // If no indexedDB, treat everything as disabled.
    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(DbManager).call(this, options));

    if (!window.indexedDB || !options.enabled) {
      options.tables = {};
    } else {
      // Test if Arrays as keys supported, disable persistence if not
      var enabled = true;

      /* istanbul ignore next */
      try {
        window.IDBKeyRange.bound(['announcement', 0], ['announcement', MAX_SAFE_INTEGER]);
      } catch (e) {
        options.tables = {};
        enabled = false;
      }

      // If Client is a layer.ClientAuthenticator, it won't support these events; this affects Unit Tests
      if (enabled && _this.client.constructor._supportedEvents.indexOf('conversations:add') !== -1) {
        _this.client.on('conversations:add', function (evt) {
          return _this.writeConversations(evt.conversations);
        }, _this);
        _this.client.on('conversations:change', function (evt) {
          return _this._updateConversation(evt.target, evt.changes);
        }, _this);
        _this.client.on('conversations:delete conversations:sent-error', function (evt) {
          return _this.deleteObjects('conversations', [evt.target]);
        }, _this);

        _this.client.on('channels:add', function (evt) {
          return _this.writeChannels(evt.channels);
        }, _this);
        _this.client.on('channels:change', function (evt) {
          return _this._updateChannel(evt.target, evt.changes);
        }, _this);
        _this.client.on('channels:delete channels:sent-error', function (evt) {
          return _this.deleteObjects('channels', [evt.target]);
        }, _this);

        _this.client.on('messages:add', function (evt) {
          return _this.writeMessages(evt.messages);
        }, _this);
        _this.client.on('messages:change', function (evt) {
          return _this.writeMessages([evt.target]);
        }, _this);
        _this.client.on('messages:delete messages:sent-error', function (evt) {
          return _this.deleteObjects('messages', [evt.target]);
        }, _this);

        _this.client.on('identities:add', function (evt) {
          return _this.writeIdentities(evt.identities);
        }, _this);
        _this.client.on('identities:change', function (evt) {
          return _this.writeIdentities([evt.target]);
        }, _this);
        _this.client.on('identities:unfollow', function (evt) {
          return _this.deleteObjects('identities', [evt.target]);
        }, _this);
      }

      // Sync Queue only really works properly if we have the Messages and Conversations written to the DB; turn it off
      // if that won't be the case.
      if (!options.tables.conversations && !options.tables.channels || !options.tables.messages) {
        options.tables.syncQueue = false;
      }
    }

    TABLES.forEach(function (tableDef) {
      _this['_permission_' + tableDef.name] = Boolean(options.tables[tableDef.name]);
    });
    _this._open(false);
    return _this;
  }

  _createClass(DbManager, [{
    key: '_getDbName',
    value: function _getDbName() {
      return 'LayerWebSDK_' + this.client.appId;
    }

    /**
     * Open the Database Connection.
     *
     * This is only called by the constructor.
     * @method _open
     * @param {Boolean} retry
     * @private
     */

  }, {
    key: '_open',
    value: function _open(retry) {
      var _this2 = this;

      if (this.db) {
        this.db.close();
        delete this.db;
      }

      // Abort if all tables are disabled
      var enabledTables = TABLES.filter(function (tableDef) {
        return _this2['_permission_' + tableDef.name];
      });
      if (enabledTables.length === 0) {
        this._isOpenError = true;
        this.trigger('error', { error: 'Persistence is disabled by application' });
        return;
      }

      // Open the database
      var request = window.indexedDB.open(this._getDbName(), DB_VERSION);

      try {
        /* istanbul ignore next */
        request.onerror = function (evt) {
          if (!retry) {
            _this2.deleteTables(function () {
              return _this2._open(true);
            });
          }

          // Triggered by Firefox private browsing window
          else {
              _this2._isOpenError = true;
              logger.warn('Database Unable to Open (common cause: private browsing window)', evt.target.error);
              _this2.trigger('error', { error: evt });
            }
        };

        request.onupgradeneeded = function (evt) {
          return _this2._onUpgradeNeeded(evt);
        };
        request.onsuccess = function (evt) {
          _this2.db = evt.target.result;
          _this2.isOpen = true;
          _this2.trigger('open');

          _this2.db.onversionchange = function () {
            _this2.db.close();
            _this2.isOpen = false;
          };

          _this2.db.onerror = function (err) {
            return logger.error('db-manager Error: ', err);
          };
        };
      }

      /* istanbul ignore next */
      catch (err) {
        // Safari Private Browsing window will fail on request.onerror
        this._isOpenError = true;
        logger.error('Database Unable to Open: ', err);
        this.trigger('error', { error: err });
      }
    }

    /**
     * Use this to setup a call to happen as soon as the database is open.
     *
     * Typically, this call will immediately, synchronously call your callback.
     * But if the DB is not open yet, your callback will be called once its open.
     * @method onOpen
     * @param {Function} callback
     */

  }, {
    key: 'onOpen',
    value: function onOpen(callback) {
      if (this.isOpen || this._isOpenError) callback();else this.once('open error', callback);
    }

    /**
     * The onUpgradeNeeded function is called by IndexedDB any time DB_VERSION is incremented.
     *
     * This invocation is part of the built-in lifecycle of IndexedDB.
     *
     * @method _onUpgradeNeeded
     * @param {IDBVersionChangeEvent} event
     * @private
     */
    /* istanbul ignore next */

  }, {
    key: '_onUpgradeNeeded',
    value: function _onUpgradeNeeded(event) {
      var _this3 = this;

      var db = event.target.result;
      var isComplete = false;

      // This appears to only get called once; its presumed this is because we're creating but not using a lot of transactions.
      var onComplete = function onComplete(evt) {
        if (!isComplete) {
          _this3.db = db;
          _this3.isComplete = true;
          _this3.isOpen = true;
          _this3.trigger('open');
        }
      };

      var currentTables = Array.prototype.slice.call(db.objectStoreNames);
      TABLES.forEach(function (tableDef) {
        try {
          if (currentTables.indexOf(tableDef.name) !== -1) db.deleteObjectStore(tableDef.name);
        } catch (e) {
          // Noop
        }
        try {
          (function () {
            var store = db.createObjectStore(tableDef.name, { keyPath: 'id' });
            Object.keys(tableDef.indexes).forEach(function (indexName) {
              return store.createIndex(indexName, tableDef.indexes[indexName], { unique: false });
            });
            store.transaction.oncomplete = onComplete;
          })();
        } catch (e) {
          // Noop
          /* istanbul ignore next */
          logger.error('Failed to create object store ' + tableDef.name, e);
        }
      });
    }

    /**
     * Convert array of Conversation instances into Conversation DB Entries.
     *
     * A Conversation DB entry looks a lot like the server representation, but
     * includes a sync_state property, and `last_message` contains a message ID not
     * a Message object.
     *
     * @method _getConversationData
     * @private
     * @param {layer.Conversation[]} conversations
     * @return {Object[]} conversations
     */

  }, {
    key: '_getConversationData',
    value: function _getConversationData(conversations) {
      var _this4 = this;

      return conversations.filter(function (conversation) {
        if (conversation._fromDB) {
          conversation._fromDB = false;
          return false;
        } else if (conversation.isLoading || conversation.syncState === SYNC_NEW) {
          return false;
        } else {
          return true;
        }
      }).map(function (conversation) {
        var item = {
          id: conversation.id,
          url: conversation.url,
          participants: _this4._getIdentityData(conversation.participants, true),
          distinct: conversation.distinct,
          created_at: getDate(conversation.createdAt),
          metadata: conversation.metadata,
          unread_message_count: conversation.unreadCount,
          last_message: conversation.lastMessage ? conversation.lastMessage.id : '',
          last_message_sent: conversation.lastMessage ? getDate(conversation.lastMessage.sentAt) : getDate(conversation.createdAt),
          sync_state: conversation.syncState
        };
        return item;
      });
    }
  }, {
    key: '_updateConversation',
    value: function _updateConversation(conversation, changes) {
      var _this5 = this;

      var idChanges = changes.filter(function (item) {
        return item.property === 'id';
      });
      if (idChanges.length) {
        this.deleteObjects('conversations', [{ id: idChanges[0].oldValue }], function () {
          _this5.writeConversations([conversation]);
        });
      } else {
        this.writeConversations([conversation]);
      }
    }

    /**
     * Writes an array of Conversations to the Database.
     *
     * @method writeConversations
     * @param {layer.Conversation[]} conversations - Array of Conversations to write
     * @param {Function} [callback]
     */

  }, {
    key: 'writeConversations',
    value: function writeConversations(conversations, callback) {
      this._writeObjects('conversations', this._getConversationData(conversations.filter(function (conversation) {
        return !conversation.isDestroyed;
      })), callback);
    }

    /**
     * Convert array of Channel instances into Channel DB Entries.
     *
     * A Channel DB entry looks a lot like the server representation, but
     * includes a sync_state property, and `last_message` contains a message ID not
     * a Message object.
     *
     * @method _getChannelData
     * @private
     * @param {layer.Channel[]} channels
     * @return {Object[]} channels
     */

  }, {
    key: '_getChannelData',
    value: function _getChannelData(channels) {
      return channels.filter(function (channel) {
        if (channel._fromDB) {
          channel._fromDB = false;
          return false;
        } else if (channel.isLoading || channel.syncState === SYNC_NEW) {
          return false;
        } else {
          return true;
        }
      }).map(function (channel) {
        var item = {
          id: channel.id,
          url: channel.url,
          created_at: getDate(channel.createdAt),
          sync_state: channel.syncState,
          // TODO: membership object should be written... but spec incomplete
          membership: null,
          name: channel.name,
          metadata: channel.metadata
        };
        return item;
      });
    }
  }, {
    key: '_updateChannel',
    value: function _updateChannel(channel, changes) {
      var _this6 = this;

      var idChanges = changes.filter(function (item) {
        return item.property === 'id';
      });
      if (idChanges.length) {
        this.deleteObjects('channels', [{ id: idChanges[0].oldValue }], function () {
          _this6.writeChannels([channel]);
        });
      } else {
        this.writeChannels([channel]);
      }
    }

    /**
     * Writes an array of Conversations to the Database.
     *
     * @method writeChannels
     * @param {layer.Channel[]} channels - Array of Channels to write
     * @param {Function} [callback]
     */

  }, {
    key: 'writeChannels',
    value: function writeChannels(channels, callback) {
      this._writeObjects('channels', this._getChannelData(channels.filter(function (channel) {
        return !channel.isDestroyed;
      })), callback);
    }

    /**
     * Convert array of Identity instances into Identity DB Entries.
     *
     * @method _getIdentityData
     * @private
     * @param {layer.Identity[]} identities
     * @param {boolean} writeBasicIdentity - Forces output as a Basic Identity
     * @return {Object[]} identities
     */

  }, {
    key: '_getIdentityData',
    value: function _getIdentityData(identities, writeBasicIdentity) {
      return identities.filter(function (identity) {
        if (identity.isDestroyed || !identity.isFullIdentity && !writeBasicIdentity) return false;

        if (identity._fromDB) {
          identity._fromDB = false;
          return false;
        } else if (identity.isLoading) {
          return false;
        } else {
          return true;
        }
      }).map(function (identity) {
        if (identity.isFullIdentity && !writeBasicIdentity) {
          return {
            id: identity.id,
            url: identity.url,
            user_id: identity.userId,
            first_name: identity.firstName,
            last_name: identity.lastName,
            display_name: identity.displayName,
            avatar_url: identity.avatarUrl,
            metadata: identity.metadata,
            public_key: identity.publicKey,
            phone_number: identity.phoneNumber,
            email_address: identity.emailAddress,
            sync_state: identity.syncState,
            type: identity.type
          };
        } else {
          return {
            id: identity.id,
            url: identity.url,
            user_id: identity.userId,
            display_name: identity.displayName,
            avatar_url: identity.avatarUrl
          };
        }
      });
    }

    /**
     * Writes an array of Identities to the Database.
     *
     * @method writeIdentities
     * @param {layer.Identity[]} identities - Array of Identities to write
     * @param {Function} [callback]
     */

  }, {
    key: 'writeIdentities',
    value: function writeIdentities(identities, callback) {
      this._writeObjects('identities', this._getIdentityData(identities), callback);
    }

    /**
     * Convert array of Message instances into Message DB Entries.
     *
     * A Message DB entry looks a lot like the server representation, but
     * includes a sync_state property.
     *
     * @method _getMessageData
     * @private
     * @param {layer.Message[]} messages
     * @param {Function} callback
     * @return {Object[]} messages
     */

  }, {
    key: '_getMessageData',
    value: function _getMessageData(messages, callback) {
      var _this7 = this;

      var dbMessages = messages.filter(function (message) {
        if (message._fromDB) {
          message._fromDB = false;
          return false;
        } else if (message.syncState === Constants.SYNC_STATE.LOADING) {
          return false;
        } else {
          return true;
        }
      }).map(function (message) {
        return {
          id: message.id,
          url: message.url,
          parts: message.parts.map(function (part) {
            var body = Util.isBlob(part.body) && part.body.size > DbManager.MaxPartSize ? null : part.body;
            return {
              body: body,
              id: part.id,
              encoding: part.encoding,
              mime_type: part.mimeType,
              content: !part._content ? null : {
                id: part._content.id,
                download_url: part._content.downloadUrl,
                expiration: part._content.expiration,
                refresh_url: part._content.refreshUrl,
                size: part._content.size
              }
            };
          }),
          position: message.position,
          sender: _this7._getIdentityData([message.sender], true)[0],
          recipient_status: message.recipientStatus,
          sent_at: getDate(message.sentAt),
          received_at: getDate(message.receivedAt),
          conversationId: message instanceof Announcement ? 'announcement' : message.conversationId,
          sync_state: message.syncState,
          is_unread: message.isUnread
        };
      });

      // Find all blobs and convert them to base64... because Safari 9.1 doesn't support writing blobs those Frelling Smurfs.
      var count = 0;
      var parts = [];
      dbMessages.forEach(function (message) {
        message.parts.forEach(function (part) {
          if (Util.isBlob(part.body)) parts.push(part);
        });
      });
      if (parts.length === 0) {
        callback(dbMessages);
      } else {
        parts.forEach(function (part) {
          Util.blobToBase64(part.body, function (base64) {
            part.body = base64;
            part.useBlob = true;
            count++;
            if (count === parts.length) callback(dbMessages);
          });
        });
      }
    }

    /**
     * Writes an array of Messages to the Database.
     *
     * @method writeMessages
     * @param {layer.Message[]} messages - Array of Messages to write
     * @param {Function} [callback]
     */

  }, {
    key: 'writeMessages',
    value: function writeMessages(messages, callback) {
      var _this8 = this;

      this._getMessageData(messages.filter(function (message) {
        return !message.isDestroyed;
      }), function (dbMessageData) {
        return _this8._writeObjects('messages', dbMessageData, callback);
      });
    }

    /**
     * Convert array of SyncEvent instances into SyncEvent DB Entries.
     *
     * @method _getSyncEventData
     * @param {layer.SyncEvent[]} syncEvents
     * @return {Object[]} syncEvents
     * @private
     */

  }, {
    key: '_getSyncEventData',
    value: function _getSyncEventData(syncEvents) {
      return syncEvents.filter(function (syncEvt) {
        if (syncEvt.fromDB) {
          syncEvt.fromDB = false;
          return false;
        } else {
          return true;
        }
      }).map(function (syncEvent) {
        var item = {
          id: syncEvent.id,
          target: syncEvent.target,
          depends: syncEvent.depends,
          isWebsocket: syncEvent instanceof SyncEvent.WebsocketSyncEvent,
          operation: syncEvent.operation,
          data: syncEvent.data,
          url: syncEvent.url || '',
          headers: syncEvent.headers || null,
          method: syncEvent.method || null,
          created_at: syncEvent.createdAt
        };
        return item;
      });
    }

    /**
     * Writes an array of SyncEvent to the Database.
     *
     * @method writeSyncEvents
     * @param {layer.SyncEvent[]} syncEvents - Array of Sync Events to write
     * @param {Function} [callback]
     */

  }, {
    key: 'writeSyncEvents',
    value: function writeSyncEvents(syncEvents, callback) {
      this._writeObjects('syncQueue', this._getSyncEventData(syncEvents), callback);
    }

    /**
     * Write an array of data to the specified Database table.
     *
     * @method _writeObjects
     * @param {string} tableName - The name of the table to write to
     * @param {Object[]} data - Array of POJO data to write
     * @param {Function} [callback] - Called when all data is written
     * @protected
     */

  }, {
    key: '_writeObjects',
    value: function _writeObjects(tableName, data, callback) {
      var _this9 = this;

      if (!this['_permission_' + tableName] || this._isOpenError) return callback ? callback() : null;

      // Just quit if no data to write
      if (!data.length) {
        if (callback) callback();
        return;
      }

      // PUT (udpate) or ADD (insert) each item of data one at a time, but all as part of one large transaction.
      this.onOpen(function () {
        _this9.getObjects(tableName, data.map(function (item) {
          return item.id;
        }), function (foundItems) {
          var updateIds = {};
          foundItems.forEach(function (item) {
            updateIds[item.id] = item;
          });

          var transaction = _this9.db.transaction([tableName], 'readwrite');
          var store = transaction.objectStore(tableName);
          transaction.oncomplete = transaction.onerror = callback;

          data.forEach(function (item) {
            try {
              if (updateIds[item.id]) {
                store.put(item);
              } else {
                store.add(item);
              }
            } catch (e) {
              /* istanbul ignore next */
              // Safari throws an error rather than use the onerror event.
              logger.error(e);
            }
          });
        });
      });
    }

    /**
     * Load all conversations from the database.
     *
     * @method loadConversations
     * @param {string} sortBy       - One of 'last_message' or 'created_at'; always sorts in DESC order
     * @param {string} [fromId=]    - For pagination, provide the conversationId to get Conversations after
     * @param {number} [pageSize=]  - To limit the number of results, provide a number for how many results to return.
     * @param {Function} [callback]  - Callback for getting results
     * @param {layer.Conversation[]} callback.result
     */

  }, {
    key: 'loadConversations',
    value: function loadConversations(sortBy, fromId, pageSize, callback) {
      var _this10 = this;

      try {
        var sortIndex = void 0,
            range = null;
        var fromConversation = fromId ? this.client.getConversation(fromId) : null;
        if (sortBy === 'last_message') {
          sortIndex = 'last_message_sent';
          if (fromConversation) {
            range = window.IDBKeyRange.upperBound([fromConversation.lastMessage ? getDate(fromConversation.lastMessage.sentAt) : getDate(fromConversation.createdAt)]);
          }
        } else {
          sortIndex = 'created_at';
          if (fromConversation) {
            range = window.IDBKeyRange.upperBound([getDate(fromConversation.createdAt)]);
          }
        }

        // Step 1: Get all Conversations
        this._loadByIndex('conversations', sortIndex, range, Boolean(fromId), pageSize, function (data) {
          // Step 2: Gather all Message IDs needed to initialize these Conversation's lastMessage properties.
          var messagesToLoad = data.map(function (item) {
            return item.last_message;
          }).filter(function (messageId) {
            return messageId && !_this10.client.getMessage(messageId);
          });

          // Step 3: Load all Messages needed to initialize these Conversation's lastMessage properties.
          _this10.getObjects('messages', messagesToLoad, function (messages) {
            _this10._loadConversationsResult(data, messages, callback);
          });
        });
      } catch (e) {
        // Noop -- handle browsers like IE that don't like these IDBKeyRanges
      }
    }

    /**
     * Assemble all LastMessages and Conversation POJOs into layer.Message and layer.Conversation instances.
     *
     * @method _loadConversationsResult
     * @private
     * @param {Object[]} conversations
     * @param {Object[]} messages
     * @param {Function} callback
     * @param {layer.Conversation[]} callback.result
     */

  }, {
    key: '_loadConversationsResult',
    value: function _loadConversationsResult(conversations, messages, callback) {
      var _this11 = this;

      // Instantiate and Register each Message
      messages.forEach(function (message) {
        return _this11._createMessage(message);
      });

      // Instantiate and Register each Conversation; will find any lastMessage that was registered.
      var newData = conversations.map(function (conversation) {
        return _this11._createConversation(conversation) || _this11.client.getConversation(conversation.id);
      }).filter(function (conversation) {
        return conversation;
      });

      // Return the data
      if (callback) callback(newData);
    }

    /**
     * Load all channels from the database.
     *
     * @method loadChannels
     * @param {string} sortBy       - One of 'last_message' or 'created_at'; always sorts in DESC order
     * @param {string} [fromId=]    - For pagination, provide the channelId to get Channel after
     * @param {number} [pageSize=]  - To limit the number of results, provide a number for how many results to return.
     * @param {Function} [callback]  - Callback for getting results
     * @param {layer.Channel[]} callback.result
     */

  }, {
    key: 'loadChannels',
    value: function loadChannels(fromId, pageSize, callback) {
      var _this12 = this;

      try {
        var sortIndex = 'created_at';
        var range = null;
        var fromChannel = fromId ? this.client.getChannel(fromId) : null;
        if (fromChannel) {
          range = window.IDBKeyRange.upperBound([getDate(fromChannel.createdAt)]);
        }

        this._loadByIndex('channels', sortIndex, range, Boolean(fromId), pageSize, function (data) {
          _this12._loadChannelsResult(data, callback);
        });
      } catch (e) {
        // Noop -- handle browsers like IE that don't like these IDBKeyRanges
      }
    }

    /**
     * Assemble all LastMessages and Conversation POJOs into layer.Message and layer.Conversation instances.
     *
     * @method _loadChannelsResult
     * @private
     * @param {Object[]} channels
     * @param {Function} callback
     * @param {layer.Channel[]} callback.result
     */

  }, {
    key: '_loadChannelsResult',
    value: function _loadChannelsResult(channels, callback) {
      var _this13 = this;

      // Instantiate and Register each Conversation; will find any lastMessage that was registered.
      var newData = channels.map(function (channel) {
        return _this13._createChannel(channel) || _this13.client.getChannel(channel.id);
      }).filter(function (conversation) {
        return conversation;
      });

      // Return the data
      if (callback) callback(newData);
    }

    /**
     * Load all messages for a given Conversation ID from the database.
     *
     * Use _loadAll if loading All Messages rather than all Messages for a Conversation.
     *
     * @method loadMessages
     * @param {string} conversationId - ID of the Conversation whose Messages are of interest.
     * @param {string} [fromId=]    - For pagination, provide the messageId to get Messages after
     * @param {number} [pageSize=]  - To limit the number of results, provide a number for how many results to return.
     * @param {Function} [callback]   - Callback for getting results
     * @param {layer.Message[]} callback.result
     */

  }, {
    key: 'loadMessages',
    value: function loadMessages(conversationId, fromId, pageSize, callback) {
      var _this14 = this;

      if (!this['_permission_messages'] || this._isOpenError) return callback([]);
      try {
        var fromMessage = fromId ? this.client.getMessage(fromId) : null;
        var query = window.IDBKeyRange.bound([conversationId, 0], [conversationId, fromMessage ? fromMessage.position : MAX_SAFE_INTEGER]);
        this._loadByIndex('messages', 'conversationId', query, Boolean(fromId), pageSize, function (data) {
          _this14._loadMessagesResult(data, callback);
        });
      } catch (e) {
        // Noop -- handle browsers like IE that don't like these IDBKeyRanges
      }
    }

    /**
     * Load all Announcements from the database.
     *
     * @method loadAnnouncements
     * @param {string} [fromId=]    - For pagination, provide the messageId to get Announcements after
     * @param {number} [pageSize=]  - To limit the number of results, provide a number for how many results to return.
     * @param {Function} [callback]
     * @param {layer.Announcement[]} callback.result
     */

  }, {
    key: 'loadAnnouncements',
    value: function loadAnnouncements(fromId, pageSize, callback) {
      var _this15 = this;

      if (!this['_permission_messages'] || this._isOpenError) return callback([]);
      try {
        var fromMessage = fromId ? this.client.getMessage(fromId) : null;
        var query = window.IDBKeyRange.bound(['announcement', 0], ['announcement', fromMessage ? fromMessage.position : MAX_SAFE_INTEGER]);
        this._loadByIndex('messages', 'conversationId', query, Boolean(fromId), pageSize, function (data) {
          _this15._loadMessagesResult(data, callback);
        });
      } catch (e) {
        // Noop -- handle browsers like IE that don't like these IDBKeyRanges
      }
    }
  }, {
    key: '_blobifyPart',
    value: function _blobifyPart(part) {
      if (part.useBlob) {
        part.body = Util.base64ToBlob(part.body);
        delete part.useBlob;
        part.encoding = null;
      }
    }

    /**
     * Registers and sorts the message objects from the database.
     *
     * TODO: Encode limits on this, else we are sorting tens of thousands
     * of messages in javascript.
     *
     * @method _loadMessagesResult
     * @private
     * @param {Object[]} Message objects from the database.
     * @param {Function} callback
     * @param {layer.Message} callback.result - Message instances created from the database
     */

  }, {
    key: '_loadMessagesResult',
    value: function _loadMessagesResult(messages, callback) {
      var _this16 = this;

      // Convert base64 to blob before sending it along...
      messages.forEach(function (message) {
        return message.parts.forEach(function (part) {
          return _this16._blobifyPart(part);
        });
      });

      // Instantiate and Register each Message
      var newData = messages.map(function (message) {
        return _this16._createMessage(message) || _this16.client.getMessage(message.id);
      }).filter(function (message) {
        return message;
      });

      // Return the results
      if (callback) callback(newData);
    }

    /**
     * Load all Identities from the database.
     *
     * @method loadIdentities
     * @param {Function} callback
     * @param {layer.Identity[]} callback.result
     */

  }, {
    key: 'loadIdentities',
    value: function loadIdentities(callback) {
      var _this17 = this;

      this._loadAll('identities', function (data) {
        _this17._loadIdentitiesResult(data, callback);
      });
    }

    /**
     * Assemble all LastMessages and Identityy POJOs into layer.Message and layer.Identityy instances.
     *
     * @method _loadIdentitiesResult
     * @private
     * @param {Object[]} identities
     * @param {Function} callback
     * @param {layer.Identity[]} callback.result
     */

  }, {
    key: '_loadIdentitiesResult',
    value: function _loadIdentitiesResult(identities, callback) {
      var _this18 = this;

      // Instantiate and Register each Identity.
      var newData = identities.map(function (identity) {
        return _this18._createIdentity(identity) || _this18.client.getIdentity(identity.id);
      }).filter(function (identity) {
        return identity;
      });

      // Return the data
      if (callback) callback(newData);
    }

    /**
     * Instantiate and Register the Conversation from a conversation DB Entry.
     *
     * If the layer.Conversation already exists, then its presumed that whatever is in
     * javascript cache is more up to date than whats in IndexedDB cache.
     *
     * Attempts to assign the lastMessage property to refer to appropriate Message.  If it fails,
     * it will be set to null.
     *
     * @method _createConversation
     * @private
     * @param {Object} conversation
     * @returns {layer.Conversation}
     */

  }, {
    key: '_createConversation',
    value: function _createConversation(conversation) {
      if (!this.client.getConversation(conversation.id)) {
        conversation._fromDB = true;
        var newConversation = this.client._createObject(conversation);
        newConversation.syncState = conversation.sync_state;
        return newConversation;
      }
    }

    /**
     * Instantiate and Register the Channel from a Channel DB Entry.
     *
     * If the layer.Channel already exists, then its presumed that whatever is in
     * javascript cache is more up to date than whats in IndexedDB cache.
     *
     * Attempts to assign the lastMessage property to refer to appropriate Message.  If it fails,
     * it will be set to null.
     *
     * @method _createChannel
     * @private
     * @param {Object} channel
     * @returns {layer.Channel}
     */

  }, {
    key: '_createChannel',
    value: function _createChannel(channel) {
      if (!this.client.getChannel(channel.id)) {
        channel._fromDB = true;
        var newChannel = this.client._createObject(channel);
        newChannel.syncState = channel.sync_state;
        return newChannel;
      }
    }

    /**
     * Instantiate and Register the Message from a message DB Entry.
     *
     * If the layer.Message already exists, then its presumed that whatever is in
     * javascript cache is more up to date than whats in IndexedDB cache.
     *
     * @method _createMessage
     * @private
     * @param {Object} message
     * @returns {layer.Message}
     */

  }, {
    key: '_createMessage',
    value: function _createMessage(message) {
      if (!this.client.getMessage(message.id)) {
        message._fromDB = true;
        if (message.conversationId.indexOf('layer:///conversations')) {
          message.conversation = {
            id: message.conversationId
          };
        } else if (message.conversationId.indexOf('layer:///channels')) {
          message.channel = {
            id: message.conversationId
          };
        }
        delete message.conversationId;
        var newMessage = this.client._createObject(message);
        newMessage.syncState = message.sync_state;
        return newMessage;
      }
    }

    /**
     * Instantiate and Register the Identity from an identities DB Entry.
     *
     * If the layer.Identity already exists, then its presumed that whatever is in
     * javascript cache is more up to date than whats in IndexedDB cache.
     *
     * @method _createIdentity
     * @param {Object} identity
     * @returns {layer.Identity}
     */

  }, {
    key: '_createIdentity',
    value: function _createIdentity(identity) {
      if (!this.client.getIdentity(identity.id)) {
        identity._fromDB = true;
        var newidentity = this.client._createObject(identity);
        newidentity.syncState = identity.sync_state;
        return newidentity;
      }
    }

    /**
     * Load all Sync Events from the database.
     *
     * @method loadSyncQueue
     * @param {Function} callback
     * @param {layer.SyncEvent[]} callback.result
     */

  }, {
    key: 'loadSyncQueue',
    value: function loadSyncQueue(callback) {
      var _this19 = this;

      this._loadAll('syncQueue', function (syncEvents) {
        return _this19._loadSyncEventRelatedData(syncEvents, callback);
      });
    }

    /**
     * Validate that we have appropriate data for each SyncEvent and instantiate it.
     *
     * Any operation that is not a DELETE must have a valid target found in the database or javascript cache,
     * otherwise it can not be executed.
     *
     * TODO: Need to cleanup sync entries that have invalid targets
     *
     * @method _loadSyncEventRelatedData
     * @private
     * @param {Object[]} syncEvents
     * @param {Function} callback
     * @param {layer.SyncEvent[]} callback.result
     */

  }, {
    key: '_loadSyncEventRelatedData',
    value: function _loadSyncEventRelatedData(syncEvents, callback) {
      var _this20 = this;

      // Gather all Message IDs that are targets of operations.
      var messageIds = syncEvents.filter(function (item) {
        return item.operation !== 'DELETE' && item.target && item.target.match(/messages/);
      }).map(function (item) {
        return item.target;
      });

      // Gather all Conversation IDs that are targets of operations.
      var conversationIds = syncEvents.filter(function (item) {
        return item.operation !== 'DELETE' && item.target && item.target.match(/conversations/);
      }).map(function (item) {
        return item.target;
      });

      var identityIds = syncEvents.filter(function (item) {
        return item.operation !== 'DELETE' && item.target && item.target.match(/identities/);
      }).map(function (item) {
        return item.target;
      });

      // Load any Messages/Conversations that are targets of operations.
      // Call _createMessage or _createConversation on all targets found.
      var counter = 0;
      var maxCounter = 3;
      this.getObjects('messages', messageIds, function (messages) {
        messages.forEach(function (message) {
          return _this20._createMessage(message);
        });
        counter++;
        if (counter === maxCounter) _this20._loadSyncEventResults(syncEvents, callback);
      });
      this.getObjects('conversations', conversationIds, function (conversations) {
        conversations.forEach(function (conversation) {
          return _this20._createConversation(conversation);
        });
        counter++;
        if (counter === maxCounter) _this20._loadSyncEventResults(syncEvents, callback);
      });
      this.getObjects('identities', identityIds, function (identities) {
        identities.forEach(function (identity) {
          return _this20._createIdentity(identity);
        });
        counter++;
        if (counter === maxCounter) _this20._loadSyncEventResults(syncEvents, callback);
      });
    }

    /**
     * Turn an array of Sync Event DB Entries into an array of layer.SyncEvent.
     *
     * @method _loadSyncEventResults
     * @private
     * @param {Object[]} syncEvents
     * @param {Function} callback
     * @param {layer.SyncEvent[]} callback.result
     */

  }, {
    key: '_loadSyncEventResults',
    value: function _loadSyncEventResults(syncEvents, callback) {
      var _this21 = this;

      // If the target is present in the sync event, but does not exist in the system,
      // do NOT attempt to instantiate this event... unless its a DELETE operation.
      var newData = syncEvents.filter(function (syncEvent) {
        var hasTarget = Boolean(syncEvent.target && _this21.client.getObject(syncEvent.target));
        return syncEvent.operation === 'DELETE' || hasTarget;
      }).map(function (syncEvent) {
        if (syncEvent.isWebsocket) {
          return new SyncEvent.WebsocketSyncEvent({
            target: syncEvent.target,
            depends: syncEvent.depends,
            operation: syncEvent.operation,
            id: syncEvent.id,
            data: syncEvent.data,
            fromDB: true,
            createdAt: syncEvent.created_at
          });
        } else {
          return new SyncEvent.XHRSyncEvent({
            target: syncEvent.target,
            depends: syncEvent.depends,
            operation: syncEvent.operation,
            id: syncEvent.id,
            data: syncEvent.data,
            method: syncEvent.method,
            headers: syncEvent.headers,
            url: syncEvent.url,
            fromDB: true,
            createdAt: syncEvent.created_at
          });
        }
      });

      // Sort the results and then return them.
      // TODO: Query results should come back sorted by database with proper Index
      Util.sortBy(newData, function (item) {
        return item.createdAt;
      });
      callback(newData);
    }

    /**
     * Load all data from the specified table.
     *
     * @method _loadAll
     * @protected
     * @param {String} tableName
     * @param {Function} callback
     * @param {Object[]} callback.result
     */

  }, {
    key: '_loadAll',
    value: function _loadAll(tableName, callback) {
      var _this22 = this;

      if (!this['_permission_' + tableName] || this._isOpenError) return callback([]);
      this.onOpen(function () {
        var data = [];
        _this22.db.transaction([tableName], 'readonly').objectStore(tableName).openCursor().onsuccess = function (evt) {
          /* istanbul ignore next */
          if (_this22.isDestroyed) return;
          var cursor = evt.target.result;
          if (cursor) {
            data.push(cursor.value);
            cursor.continue();
          } else if (!_this22.isDestroyed) {
            /* istanbul ignore next */
            callback(data);
          }
        };
      });
    }

    /**
     * Load all data from the specified table and with the specified index value.
     *
     * Results are always sorted in DESC order at this time.
     *
     * @method _loadByIndex
     * @protected
     * @param {String} tableName - 'messages', 'conversations', 'identities'
     * @param {String} indexName - Name of the index to query on
     * @param {IDBKeyRange} range - Range to Query for (null ok)
     * @param {Boolean} isFromId - If querying for results after a specified ID, then we want to skip the first result (which will be that ID) ("" is OK)
     * @param {number} pageSize - If a value is provided, return at most that number of results; else return all results.
     * @param {Function} callback
     * @param {Object[]} callback.result
     */

  }, {
    key: '_loadByIndex',
    value: function _loadByIndex(tableName, indexName, range, isFromId, pageSize, callback) {
      var _this23 = this;

      if (!this['_permission_' + tableName] || this._isOpenError) return callback([]);
      var shouldSkipNext = isFromId;
      this.onOpen(function () {
        var data = [];
        _this23.db.transaction([tableName], 'readonly').objectStore(tableName).index(indexName).openCursor(range, 'prev').onsuccess = function (evt) {
          /* istanbul ignore next */
          if (_this23.isDestroyed) return;
          var cursor = evt.target.result;
          if (cursor) {
            if (shouldSkipNext) {
              shouldSkipNext = false;
            } else {
              data.push(cursor.value);
            }
            if (pageSize && data.length >= pageSize) {
              callback(data);
            } else {
              cursor.continue();
            }
          } else {
            callback(data);
          }
        };
      });
    }

    /**
     * Deletes the specified objects from the specified table.
     *
     * Currently takes an array of data to delete rather than an array of IDs;
     * If you only have an ID, [{id: myId}] should work.
     *
     * @method deleteObjects
     * @param {String} tableName
     * @param {Object[]} data
     * @param {Function} [callback]
     */

  }, {
    key: 'deleteObjects',
    value: function deleteObjects(tableName, data, callback) {
      var _this24 = this;

      if (!this['_permission_' + tableName] || this._isOpenError) return callback ? callback() : null;
      this.onOpen(function () {
        var transaction = _this24.db.transaction([tableName], 'readwrite');
        var store = transaction.objectStore(tableName);
        transaction.oncomplete = callback;
        data.forEach(function (item) {
          return store.delete(item.id);
        });
      });
    }

    /**
     * Retrieve the identified objects from the specified database table.
     *
     * Turning these into instances is the responsibility of the caller.
     *
     * Inspired by http://www.codeproject.com/Articles/744986/How-to-do-some-magic-with-indexedDB
     *
     * @method getObjects
     * @param {String} tableName
     * @param {String[]} ids
     * @param {Function} callback
     * @param {Object[]} callback.result
     */

  }, {
    key: 'getObjects',
    value: function getObjects(tableName, ids, callback) {
      var _this25 = this;

      if (!this['_permission_' + tableName] || this._isOpenError) return callback([]);
      var data = [];

      // Gather, sort, and filter replica IDs
      var sortedIds = ids.sort();
      for (var i = sortedIds.length - 1; i > 0; i--) {
        if (sortedIds[i] === sortedIds[i - 1]) sortedIds.splice(i, 1);
      }
      var index = 0;

      // Iterate over the table searching for the specified IDs
      this.onOpen(function () {
        _this25.db.transaction([tableName], 'readonly').objectStore(tableName).openCursor().onsuccess = function (evt) {
          /* istanbul ignore next */
          if (_this25.isDestroyed) return;
          var cursor = evt.target.result;
          if (!cursor) {
            callback(data);
            return;
          }
          var key = cursor.key;

          // The cursor has passed beyond this key. Check next.
          while (key > sortedIds[index]) {
            index++;
          } // The cursor is pointing at one of our IDs, get it and check next.
          if (key === sortedIds[index]) {
            data.push(cursor.value);
            index++;
          }

          // Done or check next
          if (index === sortedIds.length) {
            /* istanbul ignore else */
            if (!_this25.isDestroyed) callback(data);
          } else {
            cursor.continue(sortedIds[index]);
          }
        };
      });
    }

    /**
     * A simplified getObjects() method that gets a single object, and also gets its related objects.
     *
     * @method getObject
     * @param {string} tableName
     * @param {string} id
     * @param {Function} callback
     * @param {Object} callback.data
     */

  }, {
    key: 'getObject',
    value: function getObject(tableName, id, callback) {
      var _this26 = this;

      if (!this['_permission_' + tableName] || this._isOpenError) return callback();

      this.onOpen(function () {
        _this26.db.transaction([tableName], 'readonly').objectStore(tableName).openCursor(window.IDBKeyRange.only(id)).onsuccess = function (evt) {
          var cursor = evt.target.result;
          if (!cursor) return callback(null);

          switch (tableName) {
            case 'messages':
              // Convert base64 to blob before sending it along...
              cursor.value.parts.forEach(function (part) {
                return _this26._blobifyPart(part);
              });
              return callback(cursor.value);
            case 'identities':
            case 'channels':
              return callback(cursor.value);
            case 'conversations':
              if (cursor.value.last_message) {
                var lastMessage = _this26.client.getMessage(cursor.value.last_message);
                if (lastMessage) {
                  return _this26._getMessageData([lastMessage], function (messages) {
                    cursor.value.last_message = messages[0];
                    callback(cursor.value);
                  });
                } else {
                  return _this26.getObject('messages', cursor.value.last_message, function (message) {
                    cursor.value.last_message = message;
                    callback(cursor.value);
                  });
                }
              } else {
                return callback(cursor.value);
              }
          }
        };
      });
    }

    /**
     * Claim a Sync Event.
     *
     * A sync event is claimed by locking the table,  validating that it is still in the table... and then deleting it from the table.
     *
     * @method claimSyncEvent
     * @param {layer.SyncEvent} syncEvent
     * @param {Function} callback
     * @param {Boolean} callback.result
     */

  }, {
    key: 'claimSyncEvent',
    value: function claimSyncEvent(syncEvent, callback) {
      var _this27 = this;

      if (!this._permission_syncQueue || this._isOpenError) return callback(true);
      this.onOpen(function () {
        var transaction = _this27.db.transaction(['syncQueue'], 'readwrite');
        var store = transaction.objectStore('syncQueue');
        store.get(syncEvent.id).onsuccess = function (evt) {
          return callback(Boolean(evt.target.result));
        };
        store.delete(syncEvent.id);
      });
    }

    /**
     * Delete all data from all tables.
     *
     * This should be called from layer.Client.logout()
     *
     * @method deleteTables
     * @param {Function} [calllback]
     */

  }, {
    key: 'deleteTables',
    value: function deleteTables() {
      var callback = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];

      try {
        var request = window.indexedDB.deleteDatabase(this._getDbName());
        request.onsuccess = request.onerror = callback;
        delete this.db;
      } catch (e) {
        logger.error('Failed to delete database', e);
        if (callback) callback(e);
      }
    }
  }]);

  return DbManager;
}(Root);

/**
 * @type {layer.Client} Layer Client instance
 */


DbManager.prototype.client = null;

/**
 * @type {boolean} is the db connection open
 */
DbManager.prototype.isOpen = false;

/**
 * @type {boolean} is the db connection will not open
 * @private
 */
DbManager.prototype._isOpenError = false;

/**
 * @type {boolean} Is reading/writing messages allowed?
 * @private
 */
DbManager.prototype._permission_messages = false;

/**
 * @type {boolean} Is reading/writing conversations allowed?
 * @private
 */
DbManager.prototype._permission_conversations = false;

/**
 * @type {boolean} Is reading/writing channels allowed?
 * @private
 */
DbManager.prototype._permission_channels = false;

/**
 * @type {boolean} Is reading/writing identities allowed?
 * @private
 */
DbManager.prototype._permission_identities = false;

/**
 * @type {boolean} Is reading/writing unsent server requests allowed?
 * @private
 */
DbManager.prototype._permission_syncQueue = false;

/**
 * @type IDBDatabase
 */
DbManager.prototype.db = null;

/**
 * Rich Content may be written to indexeddb and persisted... if its size is less than this number of bytes.
 *
 * This value can be customized; this example only writes Rich Content that is less than 5000 bytes
 *
 *    layer.DbManager.MaxPartSize = 5000;
 *
 * @static
 * @type {Number}
 */
DbManager.MaxPartSize = 250000;

DbManager._supportedEvents = ['open', 'error'].concat(Root._supportedEvents);

Root.initClass.apply(DbManager, [DbManager, 'DbManager']);
module.exports = DbManager;


},{"./client-utils":82,"./const":84,"./logger":88,"./models/announcement":95,"./root":116,"./sync-event":117}],86:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * This class represents a Layer Error.
 *
 * At this point, a LayerError is only used in response to an error from the server.
 * It may be extended to report on internal errors... but typically internal errors
 * are reported via `throw new Error(...);`
 *
 * Layer Error is passed as part of the layer.LayerEvent's data property.
 *
 * Throw an error:
 *
 *     object.trigger('xxx-error', new LayerEvent({
 *       data: new LayerError()
 *     }));
 *
 *  Receive an Error:
 *
 *     conversation.on('loaded-error', function(errEvt) {
 *        var error = errEvt.data;
 *        console.error(error.message);
 *     });
 *
 * @class layer.LayerError
 */
var Logger = require('./logger');

var LayerError = function () {
  function LayerError(options) {
    var _this = this;

    _classCallCheck(this, LayerError);

    if (options instanceof LayerError) {
      options = {
        errType: options.errType,
        httpStatus: options.httpStatus,
        message: options.message,
        code: options.code,
        url: options.url,
        data: options.data
      };
    } else if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
      options.errType = options.id;
    } else {
      options = {
        message: options
      };
    }

    Object.keys(options).forEach(function (name) {
      return _this[name] = options[name];
    });
    if (!this.data) this.data = {};
  }

  /**
   * Returns either '' or a nonce.
   *
   * If a nonce has been returned
   * by the server as part of a session-expiration error,
   * then this method will return that nonce.
   *
   * @method getNonce
   * @return {string} nonce
   */


  _createClass(LayerError, [{
    key: 'getNonce',
    value: function getNonce() {
      return this.data && this.data.nonce ? this.data.nonce : '';
    }

    /**
     * String representation of the error
     *
     * @method toString
     * @return {string}
     */

  }, {
    key: 'toString',
    value: function toString() {
      return this.code + ' (' + this.id + '): ' + this.message + '; (see ' + this.url + ')';
    }

    /**
     * Log the errors
     *
     * @method log
     * @deprecated see layer.Logger
     */

  }, {
    key: 'log',
    value: function log() {
      Logger.error('Layer-Error: ' + this.toString());
    }
  }]);

  return LayerError;
}();

/**
 * A string name for the event; these names are paired with codes.
 *
 * Codes can be looked up at https://github.com/layerhq/docs/blob/web-api/specs/rest-api.md#client-errors
 * @type {String}
 */


LayerError.prototype.errType = '';

/**
 * Numerical error code.
 *
 * https://developer.layer.com/docs/client/rest#full-list
 * @type {Number}
 */
LayerError.prototype.code = 0;

/**
 * URL to go to for more information on this error.
 * @type {String}
 */
LayerError.prototype.url = '';

/**
 * Detailed description of the error.
 * @type {String}
 */
LayerError.prototype.message = '';

/**
 * Http error code; no value if its a websocket response.
 * @type {Number}
 */
LayerError.prototype.httpStatus = 0;

/**
 * Contains data from the xhr request object.
 *
 *  * url: the url to the service endpoint
 *  * data: xhr.data,
 *  * xhr: XMLHttpRequest object
 *
 * @type {Object}
 */
LayerError.prototype.request = null;

/**
 * Any additional details about the error sent as additional properties.
 * @type {Object}
 */
LayerError.prototype.data = null;

/**
 * Pointer to the xhr object that fired the actual request and contains the response.
 * @type {XMLHttpRequest}
 */
LayerError.prototype.xhr = null;

/**
 * Dictionary of error messages
 * @property {Object} [dictionary={}]
 */
LayerError.dictionary = {
  appIdMissing: 'Property missing: appId is required',
  identityTokenMissing: 'Identity Token missing: answerAuthenticationChallenge requires an identity token',
  sessionTokenMissing: 'Session Token missing: _authComplete requires a {session_token: value} input',
  clientMissing: 'Property missing: client is required',
  conversationMissing: 'Property missing: conversation is required',
  partsMissing: 'Property missing: parts is required',
  moreParticipantsRequired: 'Conversation needs participants other than the current user',
  isDestroyed: 'Object is destroyed',
  urlRequired: 'Object needs a url property',
  invalidUrl: 'URL is invalid',
  invalidId: 'Identifier is invalid',
  idParamRequired: 'The ID Parameter is required',
  wrongClass: 'Parameter class error; should be: ',
  inProgress: 'Operation already in progress',
  cantChangeIfConnected: 'You can not change value after connecting',
  cantChangeUserId: 'You can not change the userId property',
  alreadySent: 'Already sent or sending',
  contentRequired: 'MessagePart requires rich content for this call',
  alreadyDestroyed: 'This object has already been destroyed',
  deletionModeUnsupported: 'Call to deletion was made with an unsupported deletion mode',
  sessionAndUserRequired: 'connectWithSession requires both a userId and a sessionToken',
  invalidUserIdChange: 'The prn field in the Identity Token must match the requested UserID',
  predicateNotSupported: 'The predicate is not supported for this value of model',
  invalidPredicate: 'The predicate does not match the expected format',
  appIdImmutable: 'The appId property cannot be changed',
  clientMustBeReady: 'The Client must have triggered its "ready" event before you can call this',
  modelImmutable: 'The model property cannot be changed',
  valueNotSupported: 'The value provided is not a supported value',
  permissionDenied: 'Operation not allowed on that object'
};

module.exports = LayerError;


},{"./logger":88}],87:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * This class represents a Layer Event, and is used as the parameter for all event handlers.
 *
 * Calls to
 *
 *      obj.trigger('eventName2', {hey: 'ho'});
 *
 * results in:
 *
 *      obj.on('eventName2', function(layerEvent) {
 *          alert(layerEvent.target.toString() + ' has fired a value of ' + layerEvent.hey);
 *      });
 *
 * Change events (events ending in ':change') get special handling:
 *
 *      obj.trigger('obj:change', {
 *          newValue: 55,
 *          oldValue: 25,
 *          property: 'hey'
 *      });
 *
 * results in your event data being wrapped in a `changes` array:
 *
 *      obj.on('obj:change', function(layerEvent) {
 *          layerEvent.changes.forEach(function(change) {
 *              alert(layerEvent.target.toString() + ' changed ' +
 *                    change.property + ' from ' + change.oldValue +
 *                    ' to ' + change.newValue);
 *          });
 *      });
 *
 * The `layer.LayerEvent.getChangesFor()` and `layer.LayerEvent.hasProperty()` methods
 * simplify working with xxx:change events so you don't need
 * to iterate over the `changes` array.
 *
 * @class layer.LayerEvent
 */

var LayerEvent = function () {
  /**
   * Constructor for LayerEvent.
   *
   * @method
   * @param  {Object} args - Properties to mixin to the event
   * @param  {string} eventName - Name of the event that generated this LayerEvent.
   * @return {layer.LayerEvent}
   */
  function LayerEvent(args, eventName) {
    var _this = this;

    _classCallCheck(this, LayerEvent);

    var ptr = this;

    // Is it a change event?  if so, setup the change properties.
    if (eventName.match(/:change$/)) {
      this.changes = [{}];
      // All args get copied into the changes object instead of this
      ptr = this.changes[0];
      this.isChange = true;
    } else {
      this.isChange = false;
    }

    // Copy the args into either this Event object... or into the change object.
    // Wouldn't be needed if this inherited from Root.
    Object.keys(args).forEach(function (name) {
      // Even if we are copying properties into the change object, target remains
      // a property of LayerEvent.
      if (ptr !== _this && name === 'target') {
        _this.target = args.target;
      } else {
        ptr[name] = args[name];
      }
    });
    this.eventName = eventName;
  }

  /**
   * Returns true if the specified property was changed.
   *
   * Returns false if this is not a change event.
   *
   *      if (layerEvent.hasProperty('age')) {
   *          handleAgeChange(obj.age);
   *      }
   *
   * @method hasProperty
   * @param  {string}  name - Name of the property
   * @return {Boolean}
   */


  _createClass(LayerEvent, [{
    key: 'hasProperty',
    value: function hasProperty(name) {
      if (!this.isChange) return false;
      return Boolean(this.changes.filter(function (change) {
        return change.property === name;
      }).length);
    }

    /**
     * Get all changes to the property.
     *
     * Returns an array of changes.
     * If this is not a change event, will return []
     * Changes are typically of the form:
     *
     *      layerEvent.getChangesFor('age');
     *      > [{
     *          oldValue: 10,
     *          newValue: 5,
     *          property: 'age'
     *      }]
     *
     * @method getChangesFor
     * @param  {string} name - Name of the property whose changes are of interest
     * @return {Object[]}
     */

  }, {
    key: 'getChangesFor',
    value: function getChangesFor(name) {
      if (!this.isChange) return [];
      return this.changes.filter(function (change) {
        return change.property === name;
      });
    }

    /**
     * Merge changes into a single changes array.
     *
     * The other event will need to be deleted.
     *
     * @method _mergeChanges
     * @protected
     * @param  {layer.LayerEvent} evt
     */

  }, {
    key: '_mergeChanges',
    value: function _mergeChanges(evt) {
      this.changes = this.changes.concat(evt.changes);
    }
  }]);

  return LayerEvent;
}();

/**
 * Indicates that this is a change event.
 *
 * If the event name ends with ':change' then
 * it is treated as a change event;  such
 * events are assumed to come with `newValue`, `oldValue` and `property` in the layer.LayerEvent.changes property.
 * @type {Boolean}
 */


LayerEvent.prototype.isChange = false;

/**
 * Array of changes (Change Events only).
 *
 * If its a Change Event, then the changes property contains an array of change objects
 * which each contain:
 *
 * * oldValue
 * * newValue
 * * property
 *
 * @type {Object[]}
 */
LayerEvent.prototype.changes = null;

/**
 * Component that was the source of the change.
 *
 * If one calls
 *
 *      obj.trigger('event');
 *
 * then obj will be the target.
 * @type {layer.Root}
 */
LayerEvent.prototype.target = null;

/**
 * The name of the event that created this instance.
 *
 * If one calls
 *
 *      obj.trigger('myevent');
 *
 * then eventName = 'myevent'
 *
 * @type {String}
 */
LayerEvent.prototype.eventName = '';

module.exports = LayerEvent;


},{}],88:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class layer.Logger
 * @private
 *
 */
var _require$LOG = require('./const').LOG;

var DEBUG = _require$LOG.DEBUG;
var INFO = _require$LOG.INFO;
var WARN = _require$LOG.WARN;
var ERROR = _require$LOG.ERROR;
var NONE = _require$LOG.NONE;

// Pretty arbitrary test that IE/edge fails and others don't.  Yes I could do a more direct
// test for IE/edge but its hoped that MS will fix this around the time they cleanup their internal console object.

var supportsConsoleFormatting = Boolean(console.assert && console.assert.toString().match(/assert/));
var LayerCss = 'color: #888; font-weight: bold;';
var Black = 'color: black';
/* istanbulify ignore next */

var Logger = function () {
  function Logger() {
    _classCallCheck(this, Logger);
  }

  _createClass(Logger, [{
    key: 'log',
    value: function log(msg, obj, type, color) {
      /* istanbul ignore else */
      if ((typeof msg === 'undefined' ? 'undefined' : _typeof(msg)) === 'object') {
        obj = msg;
        msg = '';
      }
      var timestamp = new Date().toLocaleTimeString();
      var op = void 0;
      switch (type) {
        case DEBUG:
          op = 'debug';
          break;
        case INFO:
          op = 'info';
          break;
        case WARN:
          op = 'warn';
          break;
        case ERROR:
          op = 'error';
          break;
        default:
          op = 'log';
      }
      if (obj) {
        if (supportsConsoleFormatting) {
          console[op]('%cLayer%c ' + op.toUpperCase() + '%c [' + timestamp + ']: ' + msg, LayerCss, 'color: ' + color, Black, obj);
        } else {
          console[op]('Layer ' + op.toUpperCase() + ' [' + timestamp + ']: ' + msg, obj);
        }
      } else if (supportsConsoleFormatting) {
        console[op]('%cLayer%c ' + op.toUpperCase() + '%c [' + timestamp + ']: ' + msg, LayerCss, 'color: ' + color, Black);
      } else {
        console[op]('Layer ' + op.toUpperCase() + ' [' + timestamp + ']: ' + msg);
      }
    }
  }, {
    key: 'debug',
    value: function debug(msg, obj) {
      /* istanbul ignore next */
      if (this.level >= DEBUG) this.log(msg, obj, DEBUG, '#888');
    }
  }, {
    key: 'info',
    value: function info(msg, obj) {
      /* istanbul ignore next */
      if (this.level >= INFO) this.log(msg, obj, INFO, 'black');
    }
  }, {
    key: 'warn',
    value: function warn(msg, obj) {
      /* istanbul ignore next */
      if (this.level >= WARN) this.log(msg, obj, WARN, 'orange');
    }
  }, {
    key: 'error',
    value: function error(msg, obj) {
      /* istanbul ignore next */
      if (this.level >= ERROR) this.log(msg, obj, ERROR, 'red');
    }
  }]);

  return Logger;
}();

/* istanbul ignore next */


Logger.prototype.level = typeof jasmine === 'undefined' ? ERROR : NONE;

var logger = new Logger();

module.exports = logger;


},{"./const":84}],89:[function(require,module,exports){
'use strict';

/**
 * Adds Channel handling to the layer.Client.
 *
 * @class layer.mixins.ClientChannels
 */

var Channel = require('../models/channel');
var ErrorDictionary = require('../layer-error').dictionary;

module.exports = {
  events: [
  /**
   * One or more layer.Channel objects have been added to the client.
   *
   * They may have been added via the websocket, or via the user creating
   * a new Channel locally.
   *
   *      client.on('channels:add', function(evt) {
   *          evt.channels.forEach(function(channel) {
   *              myView.addChannel(channel);
   *          });
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Channel[]} evt.channels - Array of channels added
   */
  'channels:add',

  /**
   * One or more layer.Channel objects have been removed.
   *
   * A removed Channel is not necessarily deleted, its just
   * no longer being held in local memory.
   *
   * Note that typically you will want the channels:delete event
   * rather than channels:remove.
   *
   *      client.on('channels:remove', function(evt) {
   *          evt.channels.forEach(function(channel) {
   *              myView.removeChannel(channel);
   *          });
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Channel[]} evt.channels - Array of channels removed
   */
  'channels:remove',

  /**
   * A channel had a change in its properties.
   *
   * This change may have been delivered from a remote user
   * or as a result of a local operation.
   *
   *      client.on('channels:change', function(evt) {
   *          var metadataChanges = evt.getChangesFor('metadata');
   *          var participantChanges = evt.getChangesFor('members');
   *          if (metadataChanges.length) {
   *              myView.renderTitle(evt.target.metadata.title);
   *          }
   *          if (participantChanges.length) {
   *              myView.rendermembers(evt.target.members);
   *          }
   *      });
   *
   * NOTE: Typically such rendering is done using Events on layer.Query.
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Channel} evt.target
   * @param {Object[]} evt.changes
   * @param {Mixed} evt.changes.newValue
   * @param {Mixed} evt.changes.oldValue
   * @param {string} evt.changes.property - Name of the property that has changed
   */
  'channels:change',

  /**
   * A call to layer.Channel.load has completed successfully
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Channel} evt.target
   */
  'channels:loaded',

  /**
   * A Channel has been deleted from the server.
   *
   * Caused by either a successful call to layer.Channel.delete() on the Channel
   * or by a remote user.
   *
   *      client.on('channels:delete', function(evt) {
   *          myView.removeChannel(evt.target);
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Channel} evt.target
   */
  'channels:delete',

  /**
   * The channel is now on the server.
   *
   * Called after creating the channel
   * on the server.  The Result property is one of:
   *
   * * layer.Channel.CREATED: A new Channel has been created
   * * layer.Channel.FOUND: A matching Channel has been found
   *
   * All of these results will also mean that the updated property values have been
   * copied into your Channel object.  That means your metadata property may no
   * longer be its initial value; it will be the value found on the server.
   *
   *      client.on('channels:sent', function(evt) {
   *          switch(evt.result) {
   *              case Channel.CREATED:
   *                  alert(evt.target.id + ' Created!');
   *                  break;
   *              case Channel.FOUND:
   *                  alert(evt.target.id + ' Found!');
   *                  break;
   *          }
   *      });
   *
   * @event
   * @param {layer.LayerEvent} event
   * @param {string} event.result
   * @param {layer.Channel} target
   */
  'channels:sent',

  /**
   * A channel failed to load or create on the server.
   *
   *      client.on('channels:sent-error', function(evt) {
   *          alert(evt.data.message);
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.LayerError} evt.data
   * @param {layer.Channel} target
   */
  'channels:sent-error'],
  lifecycle: {
    constructor: function constructor(options) {
      this._models.channels = {};
    },
    cleanup: function cleanup() {
      var _this = this;

      Object.keys(this._models.channels).forEach(function (id) {
        var channel = _this._models.channels[id];
        if (channel && !channel.isDestroyed) {
          channel.destroy();
        }
      });
      this._models.channels = null;
    },
    reset: function reset() {
      this._models.channels = {};
    }
  },
  methods: {
    /**
     * Retrieve a channel by Identifier.
     *
     *      var c = client.getChannel('layer:///channels/uuid');
     *
     * If there is not a channel with that id, it will return null.
     *
     * If you want it to load it from cache and then from server if not in cache, use the `canLoad` parameter.
     * If loading from the server, the method will return
     * a layer.Channel instance that has no data; the `channels:loaded` / `channels:loaded-error` events
     * will let you know when the channel has finished/failed loading from the server.
     *
     *      var c = client.getChannel('layer:///channels/123', true)
     *      .on('channels:loaded', function() {
     *          // Render the Channel with all of its details loaded
     *          myrerender(c);
     *      });
     *      // Render a placeholder for c until the details of c have loaded
     *      myrender(c);
     *
     * Note in the above example that the `channels:loaded` event will trigger even if the Channel has previously loaded.
     *
     * @method getChannel
     * @param  {string} id
     * @param  {boolean} [canLoad=false] - Pass true to allow loading a channel from
     *                                    the server if not found
     * @return {layer.Channel}
     */
    getChannel: function getChannel(id, canLoad) {
      if (typeof id !== 'string') throw new Error(ErrorDictionary.idParamRequired);
      if (!Channel.isValidId(id)) {
        id = Channel.prefixUUID + id;
      }
      if (this._models.channels[id]) {
        return this._models.channels[id];
      } else if (canLoad) {
        return Channel.load(id, this);
      }
      return null;
    },


    /**
     * Adds a channel to the client.
     *
     * Typically, you do not need to call this; the following code
     * automatically calls _addChannel for you:
     *
     *      var conv = new layer.Channel({
     *          client: client,
     *          members: ['a', 'b']
     *      });
     *
     *      // OR:
     *      var conv = client.createChannel(['a', 'b']);
     *
     * @method _addChannel
     * @protected
     * @param  {layer.Channel} c
     */
    _addChannel: function _addChannel(channel) {
      var id = channel.id;
      if (!this._models.channels[id]) {
        // Register the Channel
        this._models.channels[id] = channel;

        // Make sure the client is set so that the next event bubbles up
        if (channel.clientId !== this.appId) channel.clientId = this.appId;
        this._triggerAsync('channels:add', { channels: [channel] });

        this._scheduleCheckAndPurgeCache(channel);
      }
    },


    /**
     * Removes a channel from the client.
     *
     * Typically, you do not need to call this; the following code
     * automatically calls _removeChannel for you:
     *
     *      channel.destroy();
     *
     * @method _removeChannel
     * @protected
     * @param  {layer.Channel} c
     */
    _removeChannel: function _removeChannel(channel) {
      var _this2 = this;

      // Insure we do not get any events, such as message:remove
      channel.off(null, null, this);

      if (this._models.channels[channel.id]) {
        delete this._models.channels[channel.id];
        this._triggerAsync('channels:remove', { channels: [channel] });
      }

      // Remove any Message associated with this Channel
      Object.keys(this._models.messages).forEach(function (id) {
        if (_this2._models.messages[id].channelId === channel.id) {
          _this2._models.messages[id].destroy();
        }
      });
    },


    /**
     * If the Channel ID changes, we need to reregister the Channel
     *
     * @method _updateChannelId
     * @protected
     * @param  {layer.Channel} channel - Channel whose ID has changed
     * @param  {string} oldId - Previous ID
     */
    _updateChannelId: function _updateChannelId(channel, oldId) {
      var _this3 = this;

      if (this._models.channels[oldId]) {
        this._models.channels[channel.id] = channel;
        delete this._models.channels[oldId];

        // This is a nasty way to work... but need to find and update all
        // channelId properties of all Messages or the Query's won't
        // see these as matching the query.
        Object.keys(this._models.messages).filter(function (id) {
          return _this3._models.messages[id].conversationId === oldId;
        }).forEach(function (id) {
          return _this3._models.messages[id].conversationId = channel.id;
        });
      }
    },


    /**
     * Searches locally cached channels for a matching channel.
     *
     * Iterates over channels calling a matching function until
     * the channel is found or all channels tested.
     *
     *      var c = client.findCachedChannel(function(channel) {
     *          if (channel.participants.indexOf('a') != -1) return true;
     *      });
     *
     * @method findCachedChannel
     * @param  {Function} f - Function to call until we find a match
     * @param  {layer.Channel} f.channel - A channel to test
     * @param  {boolean} f.return - Return true if the channel is a match
     * @param  {Object} [context] - Optional context for the *this* object
     * @return {layer.Channel}
     *
     * @deprecated
     * This should be replaced by iterating over your layer.Query data.
     */
    findCachedChannel: function findCachedChannel(func, context) {
      var test = context ? func.bind(context) : func;
      var list = Object.keys(this._models.channels);
      var len = list.length;
      for (var index = 0; index < len; index++) {
        var key = list[index];
        var channel = this._models.channels[key];
        if (test(channel, index)) return channel;
      }
      return null;
    },


    /**
     * This method is recommended way to create a Channel.
     *
     * ```
     *         client.createChannel({
     *             members: ['layer:///identities/a', 'layer:///identities/b'],
     *             name: 'a-channel'
     *         });
     *         client.createChannel({
     *             members: [userIdentityObjectA, userIdentityObjectB],
     *             name: 'another-channel'
     *         });
     *
     *         client.createChannel({
     *             members: ['layer:///identities/a', 'layer:///identities/b'],
     *             name: 'a-channel-with-metadata',
     *             metadata: {
     *                 topicDetails: 'I am a detail'
     *             }
     *         });
     * ```
     *
     * If you try to create a Channel with a name that already exists,
     * you will get back an existing Channel, and any requested metadata and members
     * will NOT be set; you will get whatever metadata the matching Conversation
     * already had, and no members will be added/removed.
     *
     * Whether the Channel already exists or not, a 'channels:sent' event
     * will be triggered asynchronously and the Channel object will be ready
     * at that time.  Further, the event will provide details on the result:
     *
     * ```
     *       var channel = client.createChannel({
     *          members: ['a', 'b'],
     *          name: 'yet-another-channel-with-metadata',
     *          metadata: {
     *                 topicDetails: 'I am a detail'
     *          }
     *       });
     *       channel.on('channels:sent', function(evt) {
     *           switch(evt.result) {
     *               case Channel.CREATED:
     *                   alert(channel.id + ' was created');
     *                   break;
     *               case Channel.FOUND:
     *                   alert(channel.id + ' was found');
     *                   break;
     *               case Channel.FOUND_WITHOUT_REQUESTED_METADATA:
     *                   alert(channel.id + ' was found but it already has a topicDetails so your requested detail was not set');
     *                   break;
     *            }
     *       });
     * ```
     *
     * Warning: This method will throw an error if called when you are not (or are no longer) an authenticated user.
     * That means if authentication has expired, and you have not yet reauthenticated the user, this will throw an error.
     *
     *
     * @method createChannel
     * @param  {Object} options
     * @param {string[]/layer.Identity[]} options.members - Array of UserIDs or UserIdentities
     * @param {String} options.name - The unique name for this Channel
     * @param {Object} [options.metadata={}] Metadata for your Channel
     * @return {layer.Channel}
     */
    createChannel: function createChannel(options) {
      // If we aren't authenticated, then we don't yet have a UserID, and won't create the correct Channel
      if (!this.isAuthenticated) throw new Error(ErrorDictionary.clientMustBeReady);
      if (!('private' in options)) options.private = false;
      options.client = this;
      return Channel.create(options);
    }
  }
};


},{"../layer-error":86,"../models/channel":97}],90:[function(require,module,exports){
'use strict';

/**
 * Adds Conversation handling to the layer.Client.
 *
 * @class layer.mixins.ClientConversations
 */

var Conversation = require('../models/conversation');
var ErrorDictionary = require('../layer-error').dictionary;

module.exports = {
  events: [
  /**
   * One or more layer.Conversation objects have been added to the client.
   *
   * They may have been added via the websocket, or via the user creating
   * a new Conversation locally.
   *
   *      client.on('conversations:add', function(evt) {
   *          evt.conversations.forEach(function(conversation) {
   *              myView.addConversation(conversation);
   *          });
   *      });
   *
   * @event conversations_add
   * @param {layer.LayerEvent} evt
   * @param {layer.Conversation[]} evt.conversations - Array of conversations added
   */
  'conversations:add',

  /**
   * One or more layer.Conversation objects have been removed.
   *
   * A removed Conversation is not necessarily deleted, its just
   * no longer being held in local memory.
   *
   * Note that typically you will want the conversations:delete event
   * rather than conversations:remove.
   *
   *      client.on('conversations:remove', function(evt) {
   *          evt.conversations.forEach(function(conversation) {
   *              myView.removeConversation(conversation);
   *          });
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Conversation[]} evt.conversations - Array of conversations removed
   */
  'conversations:remove',

  /**
   * The conversation is now on the server.
   *
   * Called after creating the conversation
   * on the server.  The Result property is one of:
   *
   * * layer.Conversation.CREATED: A new Conversation has been created
   * * layer.Conversation.FOUND: A matching Distinct Conversation has been found
   * * layer.Conversation.FOUND_WITHOUT_REQUESTED_METADATA: A matching Distinct Conversation has been found
   *                       but note that the metadata is NOT what you requested.
   *
   * All of these results will also mean that the updated property values have been
   * copied into your Conversation object.  That means your metadata property may no
   * longer be its initial value; it will be the value found on the server.
   *
   *      client.on('conversations:sent', function(evt) {
   *          switch(evt.result) {
   *              case Conversation.CREATED:
   *                  alert(evt.target.id + ' Created!');
   *                  break;
   *              case Conversation.FOUND:
   *                  alert(evt.target.id + ' Found!');
   *                  break;
   *              case Conversation.FOUND_WITHOUT_REQUESTED_METADATA:
   *                  alert(evt.target.id + ' Found, but does not have the requested metadata!');
   *                  break;
   *          }
   *      });
   *
   * @event
   * @param {layer.LayerEvent} event
   * @param {string} event.result
   * @param {layer.Conversation} target
   */
  'conversations:sent',

  /**
   * A conversation failed to load or create on the server.
   *
   *      client.on('conversations:sent-error', function(evt) {
   *          alert(evt.data.message);
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.LayerError} evt.data
   * @param {layer.Conversation} target
   */
  'conversations:sent-error',

  /**
   * A conversation had a change in its properties.
   *
   * This change may have been delivered from a remote user
   * or as a result of a local operation.
   *
   *      client.on('conversations:change', function(evt) {
   *          var metadataChanges = evt.getChangesFor('metadata');
   *          var participantChanges = evt.getChangesFor('participants');
   *          if (metadataChanges.length) {
   *              myView.renderTitle(evt.target.metadata.title);
   *          }
   *          if (participantChanges.length) {
   *              myView.renderParticipants(evt.target.participants);
   *          }
   *      });
   *
   * NOTE: Typically such rendering is done using Events on layer.Query.
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Conversation} evt.target
   * @param {Object[]} evt.changes
   * @param {Mixed} evt.changes.newValue
   * @param {Mixed} evt.changes.oldValue
   * @param {string} evt.changes.property - Name of the property that has changed
   */
  'conversations:change',

  /**
   * A call to layer.Conversation.load has completed successfully
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Conversation} evt.target
   */
  'conversations:loaded',

  /**
   * A Conversation has been deleted from the server.
   *
   * Caused by either a successful call to layer.Conversation.delete() on the Conversation
   * or by a remote user.
   *
   *      client.on('conversations:delete', function(evt) {
   *          myView.removeConversation(evt.target);
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Conversation} evt.target
   */
  'conversations:delete'],
  lifecycle: {
    constructor: function constructor(options) {
      this._models.conversations = {};
    },
    cleanup: function cleanup() {
      var _this = this;

      Object.keys(this._models.conversations).forEach(function (id) {
        var conversation = _this._models.conversations[id];
        if (conversation && !conversation.isDestroyed) {
          conversation.destroy();
        }
      });
      this._models.conversations = null;
    },
    reset: function reset() {
      this._models.conversations = {};
    }
  },
  methods: {
    /**
     * Retrieve a conversation by Identifier.
     *
     *      var c = client.getConversation('layer:///conversations/uuid');
     *
     * If there is not a conversation with that id, it will return null.
     *
     * If you want it to load it from cache and then from server if not in cache, use the `canLoad` parameter.
     * If loading from the server, the method will return
     * a layer.Conversation instance that has no data; the `conversations:loaded` / `conversations:loaded-error` events
     * will let you know when the conversation has finished/failed loading from the server.
     *
     *      var c = client.getConversation('layer:///conversations/123', true)
     *      .on('conversations:loaded', function() {
     *          // Render the Conversation with all of its details loaded
     *          myrerender(c);
     *      });
     *      // Render a placeholder for c until the details of c have loaded
     *      myrender(c);
     *
     * Note in the above example that the `conversations:loaded` event will trigger even if the Conversation has previously loaded.
     *
     * @method getConversation
     * @param  {string} id
     * @param  {boolean} [canLoad=false] - Pass true to allow loading a conversation from
     *                                    the server if not found
     * @return {layer.Conversation}
     */
    getConversation: function getConversation(id, canLoad) {
      if (typeof id !== 'string') throw new Error(ErrorDictionary.idParamRequired);
      if (!Conversation.isValidId(id)) {
        id = Conversation.prefixUUID + id;
      }
      if (this._models.conversations[id]) {
        return this._models.conversations[id];
      } else if (canLoad) {
        return Conversation.load(id, this);
      }
      return null;
    },


    /**
     * Adds a conversation to the client.
     *
     * Typically, you do not need to call this; the following code
     * automatically calls _addConversation for you:
     *
     *      var conv = new layer.Conversation({
     *          client: client,
     *          participants: ['a', 'b']
     *      });
     *
     *      // OR:
     *      var conv = client.createConversation(['a', 'b']);
     *
     * @method _addConversation
     * @protected
     * @param  {layer.Conversation} c
     */
    _addConversation: function _addConversation(conversation) {
      var id = conversation.id;
      if (!this._models.conversations[id]) {
        // Register the Conversation
        this._models.conversations[id] = conversation;

        // Make sure the client is set so that the next event bubbles up
        if (conversation.clientId !== this.appId) conversation.clientId = this.appId;
        this._triggerAsync('conversations:add', { conversations: [conversation] });

        this._scheduleCheckAndPurgeCache(conversation);
      }
    },


    /**
     * Removes a conversation from the client.
     *
     * Typically, you do not need to call this; the following code
     * automatically calls _removeConversation for you:
     *
     *      conversation.destroy();
     *
     * @method _removeConversation
     * @protected
     * @param  {layer.Conversation} c
     */
    _removeConversation: function _removeConversation(conversation) {
      var _this2 = this;

      // Insure we do not get any events, such as message:remove
      conversation.off(null, null, this);

      if (this._models.conversations[conversation.id]) {
        delete this._models.conversations[conversation.id];
        this._triggerAsync('conversations:remove', { conversations: [conversation] });
      }

      // Remove any Message associated with this Conversation
      Object.keys(this._models.messages).forEach(function (id) {
        if (_this2._models.messages[id].conversationId === conversation.id) {
          _this2._models.messages[id].destroy();
        }
      });
    },


    /**
     * If the Conversation ID changes, we need to reregister the Conversation
     *
     * @method _updateConversationId
     * @protected
     * @param  {layer.Conversation} conversation - Conversation whose ID has changed
     * @param  {string} oldId - Previous ID
     */
    _updateConversationId: function _updateConversationId(conversation, oldId) {
      var _this3 = this;

      if (this._models.conversations[oldId]) {
        this._models.conversations[conversation.id] = conversation;
        delete this._models.conversations[oldId];

        // This is a nasty way to work... but need to find and update all
        // conversationId properties of all Messages or the Query's won't
        // see these as matching the query.
        Object.keys(this._models.messages).filter(function (id) {
          return _this3._models.messages[id].conversationId === oldId;
        }).forEach(function (id) {
          return _this3._models.messages[id].conversationId = conversation.id;
        });
      }
    },


    /**
     * Searches locally cached conversations for a matching conversation.
     *
     * Iterates over conversations calling a matching function until
     * the conversation is found or all conversations tested.
     *
     *      var c = client.findCachedConversation(function(conversation) {
     *          if (conversation.participants.indexOf('a') != -1) return true;
     *      });
     *
     * @method findCachedConversation
     * @param  {Function} f - Function to call until we find a match
     * @param  {layer.Conversation} f.conversation - A conversation to test
     * @param  {boolean} f.return - Return true if the conversation is a match
     * @param  {Object} [context] - Optional context for the *this* object
     * @return {layer.Conversation}
     *
     * @deprecated
     * This should be replaced by iterating over your layer.Query data.
     */
    findCachedConversation: function findCachedConversation(func, context) {
      var test = context ? func.bind(context) : func;
      var list = Object.keys(this._models.conversations);
      var len = list.length;
      for (var index = 0; index < len; index++) {
        var key = list[index];
        var conversation = this._models.conversations[key];
        if (test(conversation, index)) return conversation;
      }
      return null;
    },


    /**
     * This method is recommended way to create a Conversation.
     *
     * There are a few ways to invoke it; note that the default behavior is to create a Distinct Conversation
     * unless otherwise stated via the layer.Conversation.distinct property.
     *
     *         client.createConversation({participants: ['a', 'b']});
     *         client.createConversation({participants: [userIdentityA, userIdentityB]});
     *
     *         client.createConversation({
     *             participants: ['a', 'b'],
     *             distinct: false
     *         });
     *
     *         client.createConversation({
     *             participants: ['a', 'b'],
     *             metadata: {
     *                 title: 'I am a title'
     *             }
     *         });
     *
     * If you try to create a Distinct Conversation that already exists,
     * you will get back an existing Conversation, and any requested metadata
     * will NOT be set; you will get whatever metadata the matching Conversation
     * already had.
     *
     * The default value for distinct is `true`.
     *
     * Whether the Conversation already exists or not, a 'conversations:sent' event
     * will be triggered asynchronously and the Conversation object will be ready
     * at that time.  Further, the event will provide details on the result:
     *
     *       var conversation = client.createConversation({
     *          participants: ['a', 'b'],
     *          metadata: {
     *            title: 'I am a title'
     *          }
     *       });
     *       conversation.on('conversations:sent', function(evt) {
     *           switch(evt.result) {
     *               case Conversation.CREATED:
     *                   alert(conversation.id + ' was created');
     *                   break;
     *               case Conversation.FOUND:
     *                   alert(conversation.id + ' was found');
     *                   break;
     *               case Conversation.FOUND_WITHOUT_REQUESTED_METADATA:
     *                   alert(conversation.id + ' was found but it already has a title so your requested title was not set');
     *                   break;
     *            }
     *       });
     *
     * Warning: This method will throw an error if called when you are not (or are no longer) an authenticated user.
     * That means if authentication has expired, and you have not yet reauthenticated the user, this will throw an error.
     *
     *
     * @method createConversation
     * @param  {Object} options
     * @param {string[]/layer.Identity[]} participants - Array of UserIDs or UserIdentities
     * @param {Boolean} [options.distinct=true] Is this a distinct Conversation?
     * @param {Object} [options.metadata={}] Metadata for your Conversation
     * @return {layer.Conversation}
     */
    createConversation: function createConversation(options) {
      // If we aren't authenticated, then we don't yet have a UserID, and won't create the correct Conversation
      if (!this.isAuthenticated) throw new Error(ErrorDictionary.clientMustBeReady);
      if (!('distinct' in options)) options.distinct = true;
      options.client = this;
      return Conversation.create(options);
    }
  }
};


},{"../layer-error":86,"../models/conversation":101}],91:[function(require,module,exports){
'use strict';

/**
 * Adds Identity handling to the layer.Client.
 *
 * @class layer.mixins.ClientIdentities
 */

var Identity = require('../models/identity');
var ErrorDictionary = require('../layer-error').dictionary;
var Util = require('../client-utils');

var _require = require('../sync-event');

var WebsocketSyncEvent = _require.WebsocketSyncEvent;


module.exports = {
  events: [
  /**
   * A call to layer.Identity.load has completed successfully
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Identity} evt.target
   */
  'identities:loaded',

  /**
   * An Identity has had a change in its properties.
   *
   * Changes occur when new data arrives from the server.
   *
   *      client.on('identities:change', function(evt) {
   *          var displayNameChanges = evt.getChangesFor('displayName');
   *          if (displayNameChanges.length) {
   *              myView.renderStatus(evt.target);
   *          }
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Identity} evt.target
   * @param {Object[]} evt.changes
   * @param {Mixed} evt.changes.newValue
   * @param {Mixed} evt.changes.oldValue
   * @param {string} evt.changes.property - Name of the property that has changed
   */
  'identities:change',

  /**
   * Identities have been added to the Client.
   *
   * This event is triggered whenever a new layer.Identity (Full identity or not)
   * has been received by the Client.
   *
          client.on('identities:add', function(evt) {
              evt.identities.forEach(function(identity) {
                  myView.addIdentity(identity);
              });
          });
  *
  * @event
  * @param {layer.LayerEvent} evt
  * @param {layer.Identity[]} evt.identities
  */
  'identities:add',

  /**
   * Identities have been removed from the Client.
   *
   * This does not typically occur.
   *
          client.on('identities:remove', function(evt) {
              evt.identities.forEach(function(identity) {
                  myView.addIdentity(identity);
              });
          });
  *
  * @event
  * @param {layer.LayerEvent} evt
  * @param {layer.Identity[]} evt.identities
  */
  'identities:remove',

  /**
   * An Identity has been unfollowed or deleted.
   *
   * We do not delete such Identities entirely from the Client as
   * there are still Messages from these Identities to be rendered,
   * but we do downgrade them from Full Identity to Basic Identity.
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Identity} evt.target
   */
  'identities:unfollow'],
  lifecycle: {
    constructor: function constructor(options) {
      this._models.identities = {};
      this._loadPresenceIds = [];
    },
    cleanup: function cleanup() {
      var _this = this;

      Object.keys(this._models.identities).forEach(function (id) {
        var identity = _this._models.identities[id];
        if (identity && !identity.isDestroyed) {
          identity.destroy();
        }
      });
      this._models.identities = null;
    },
    reset: function reset() {
      this._models.identities = {};
    }
  },
  methods: {
    /**
     * Retrieve a identity by Identifier.
     *
     *      var identity = client.getIdentity('layer:///identities/user_id');
     *
     * If there is not an Identity with that id, it will return null.
     *
     * If you want it to load it from cache and then from server if not in cache, use the `canLoad` parameter.
     * This is only supported for User Identities, not Service Identities.
     *
     * If loading from the server, the method will return
     * a layer.Identity instance that has no data; the identities:loaded/identities:loaded-error events
     * will let you know when the identity has finished/failed loading from the server.
     *
     *      var user = client.getIdentity('layer:///identities/123', true)
     *      .on('identities:loaded', function() {
     *          // Render the user list with all of its details loaded
     *          myrerender(user);
     *      });
     *      // Render a placeholder for user until the details of user have loaded
     *      myrender(user);
     *
     * @method getIdentity
     * @param  {string} id - Accepts full Layer ID (layer:///identities/frodo-the-dodo) or just the UserID (frodo-the-dodo).
     * @param  {boolean} [canLoad=false] - Pass true to allow loading an identity from
     *                                    the server if not found
     * @return {layer.Identity}
     */
    getIdentity: function getIdentity(id, canLoad) {
      if (typeof id !== 'string') throw new Error(ErrorDictionary.idParamRequired);
      if (!Identity.isValidId(id)) {
        id = Identity.prefixUUID + encodeURIComponent(id);
      }

      if (this._models.identities[id]) {
        return this._models.identities[id];
      } else if (canLoad) {
        return Identity.load(id, this);
      }
      return null;
    },


    /**
     * Adds an identity to the client.
     *
     * Typically, you do not need to call this; the Identity constructor will call this.
     *
     * @method _addIdentity
     * @protected
     * @param  {layer.Identity} identity
     *
     * TODO: It should be possible to add an Identity whose userId is populated, but
     * other values are not yet loaded from the server.  Should add to _models.identities now
     * but trigger `identities:add` only when its got enough data to be renderable.
     */
    _addIdentity: function _addIdentity(identity) {
      var _this2 = this;

      var id = identity.id;
      if (id && !this._models.identities[id]) {
        // Register the Identity
        this._models.identities[id] = identity;
        this._triggerAsync('identities:add', { identities: [identity] });

        /* Bot messages from SAPI 1.0 generate an Identity that has no `id` */
        if (identity.id && identity._presence.status === null && !identity.sessionOwner) {
          this._loadPresenceIds.push(id);
          if (this._loadPresenceIds.length === 1) {
            setTimeout(function () {
              if (!_this2.isDestroyed) _this2._loadPresence();
            }, 150);
          }
        }
      }
    },


    /**
     * Removes an identity from the client.
     *
     * Typically, you do not need to call this; the following code
     * automatically calls _removeIdentity for you:
     *
     *      identity.destroy();
     *
     * @method _removeIdentity
     * @protected
     * @param  {layer.Identity} identity
     */
    _removeIdentity: function _removeIdentity(identity) {
      // Insure we do not get any events, such as message:remove
      identity.off(null, null, this);

      var id = identity.id;
      if (this._models.identities[id]) {
        delete this._models.identities[id];
        this._triggerAsync('identities:remove', { identities: [identity] });
      }
    },


    /**
     * Follow this user and get Full Identity, and websocket changes on Identity.
     *
     * @method followIdentity
     * @param  {string} id - Accepts full Layer ID (layer:///identities/frodo-the-dodo) or just the UserID (frodo-the-dodo).
     * @returns {layer.Identity}
     */
    followIdentity: function followIdentity(id) {
      if (!Identity.isValidId(id)) {
        id = Identity.prefixUUID + encodeURIComponent(id);
      }
      var identity = this.getIdentity(id);
      if (!identity) {
        identity = new Identity({
          id: id,
          clientId: this.appId,
          userId: id.substring(20)
        });
      }
      identity.follow();
      return identity;
    },


    /**
     * Unfollow this user and get only Basic Identity, and no websocket changes on Identity.
     *
     * @method unfollowIdentity
     * @param  {string} id - Accepts full Layer ID (layer:///identities/frodo-the-dodo) or just the UserID (frodo-the-dodo).
     * @returns {layer.Identity}
     */
    unfollowIdentity: function unfollowIdentity(id) {
      if (!Identity.isValidId(id)) {
        id = Identity.prefixUUID + encodeURIComponent(id);
      }
      var identity = this.getIdentity(id);
      if (!identity) {
        identity = new Identity({
          id: id,
          clientId: this.appId,
          userId: id.substring(20)
        });
      }
      identity.unfollow();
      return identity;
    },


    /**
     * Load presence data for a batch of Idenity IDs.
     *
     * TODO: This uses the syncManager to request presence because the syncManager
     *   knows how to wait until the websocket is connected, and retry until the request completes.
     *   BUT: this is not ideal, because it must wait if there are any other requests already queued;
     *   this is a READ not a WRITE and should not have to wait.
     *
     * @method _loadPresence
     * @private
     */
    _loadPresence: function _loadPresence() {
      var ids = this._loadPresenceIds;
      this._loadPresenceIds = [];
      this.syncManager.request(new WebsocketSyncEvent({
        data: {
          method: 'Presence.sync',
          data: { ids: ids }
        },
        returnChangesArray: true,
        operation: 'READ',
        target: null,
        depends: []
      }));
    }
  }
};


},{"../client-utils":82,"../layer-error":86,"../models/identity":102,"../sync-event":117}],92:[function(require,module,exports){
'use strict';

/**
 * Adds Channel Membership handling to the layer.Client.
 *
 * @class layer.mixins.ClientMembership
 */

var Syncable = require('../models/syncable');
var Membership = require('../models/membership');
var ErrorDictionary = require('../layer-error').dictionary;

module.exports = {
  events: [
  /**
   * A call to layer.Membership.load has completed successfully
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Membership} evt.target
   */
  'members:loaded',

  /**
   * An Identity has had a change in its properties.
   *
   * Changes occur when new data arrives from the server.
   *
   *      client.on('members:change', function(evt) {
   *          var displayNameChanges = evt.getChangesFor('displayName');
   *          if (displayNameChanges.length) {
   *              myView.renderStatus(evt.target);
   *          }
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Membership} evt.target
   * @param {Object[]} evt.changes
   * @param {Mixed} evt.changes.newValue
   * @param {Mixed} evt.changes.oldValue
   * @param {string} evt.changes.property - Name of the property that has changed
   */
  'members:change',

  /**
   * A new Member has been added to the Client.
   *
   * This event is triggered whenever a new layer.Membership
   * has been received by the Client.
   *
          client.on('members:add', function(evt) {
              evt.membership.forEach(function(member) {
                  myView.addMember(member);
              });
          });
  *
  * @event
  * @param {layer.LayerEvent} evt
  * @param {layer.Membership[]} evt.membership
  */
  'members:add',

  /**
   * A Member has been removed from the Client.
   *
   * This does not typically occur.
   *
          client.on('members:remove', function(evt) {
              evt.membership.forEach(function(member) {
                  myView.addMember(member);
              });
          });
  *
  * @event
  * @param {layer.LayerEvent} evt
  * @param {layer.Membership[]} evt.membership
  */
  'members:remove'],
  lifecycle: {
    constructor: function constructor(options) {
      this._models.members = {};
    },
    cleanup: function cleanup() {
      var _this = this;

      Object.keys(this._models.members).forEach(function (id) {
        var member = _this._models.members[id];
        if (member && !member.isDestroyed) {
          member.destroy();
        }
      });
      this._models.members = null;
    },
    reset: function reset() {
      this._models.members = {};
    }
  },
  methods: {
    /**
     * Retrieve the membership info by ID.
     *
     * Not for use in typical apps.
     *
     * @method getMember
     * @param  {string} id               - layer:///channels/uuid/members/user_id
     * @param  {boolean} [canLoad=false] - Pass true to allow loading a member from the server if not found
     * @return {layer.Membership}
     */
    getMember: function getMember(id, canLoad) {
      if (typeof id !== 'string') throw new Error(ErrorDictionary.idParamRequired);

      if (this._models.members[id]) {
        return this._models.members[id];
      } else if (canLoad) {
        return Syncable.load(id, this);
      }
      return null;
    },


    /**
     * Report that a new Membership has been added.
     *
     * @method _addMembership
     * @protected
     * @param  {layer.Membership} member
     *
     */
    _addMembership: function _addMembership(member) {
      if (!this._models.members[member.id]) {
        this._models.members[member.id] = member;
        this._triggerAsync('members:add', { members: [member] });
        this._scheduleCheckAndPurgeCache(member);
      }
    },


    /**
     * Report that a member has been removed from the client.
     *
     * @method _removeMembership
     * @protected
     * @param  {layer.Membership} member
     */
    _removeMembership: function _removeMembership(member) {
      var id = typeof member === 'string' ? member : member.id;
      member = this._models.members[id];
      if (member) {
        delete this._models.members[id];
        if (!this._inCleanup) {
          member.off(null, null, this);
          this._triggerAsync('members:remove', { members: [member] });
        }
      }
    }
  }
};


},{"../layer-error":86,"../models/membership":103,"../models/syncable":106}],93:[function(require,module,exports){
'use strict';

/**
 * Adds Message handling to the layer.Client.
 *
 * @class layer.mixins.ClientMessages
 */

var Syncable = require('../models/syncable');
var Message = require('../models/message');
var ErrorDictionary = require('../layer-error').dictionary;

module.exports = {
  events: [
  /**
   * A new message has been received for which a notification may be suitable.
   *
   * This event is triggered for messages that are:
   *
   * 1. Added via websocket rather than other IO
   * 2. Not yet been marked as read
   * 3. Not sent by this user
   *
          client.on('messages:notify', function(evt) {
              myNotify(evt.message);
          })
  *
  * @event
  * @param {layer.LayerEvent} evt
  * @param {layer.Message} evt.Message
  */
  'messages:notify',

  /**
   * Messages have been added to a conversation.
   *
   * May also fire when new Announcements are received.
   *
   * This event is triggered on
   *
   * * creating/sending a new message
   * * Receiving a new layer.Message or layer.Announcement via websocket
   * * Querying/downloading a set of Messages
   *
          client.on('messages:add', function(evt) {
              evt.messages.forEach(function(message) {
                  myView.addMessage(message);
              });
          });
  *
  * NOTE: Such rendering would typically be done using events on layer.Query.
  *
  * @event
  * @param {layer.LayerEvent} evt
  * @param {layer.Message[]} evt.messages
  */
  'messages:add',

  /**
   * A message has been removed from a conversation.
   *
   * A removed Message is not necessarily deleted,
   * just no longer being held in memory.
   *
   * Note that typically you will want the messages:delete event
   * rather than messages:remove.
   *
   *      client.on('messages:remove', function(evt) {
   *          evt.messages.forEach(function(message) {
   *              myView.removeMessage(message);
   *          });
   *      });
   *
   * NOTE: Such rendering would typically be done using events on layer.Query.
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Message} evt.message
   */
  'messages:remove',

  /**
   * A message has been sent.
   *
   *      client.on('messages:sent', function(evt) {
   *          alert(evt.target.getText() + ' has been sent');
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Message} evt.target
   */
  'messages:sent',

  /**
   * A message is about to be sent.
   *
   * Useful if you want to
   * add parts to the message before it goes out.
   *
   *      client.on('messages:sending', function(evt) {
   *          evt.target.addPart({
   *              mimeType: 'text/plain',
   *              body: 'this is just a test'
   *          });
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Message} evt.target
   */
  'messages:sending',

  /**
   * Server failed to receive a Message.
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.LayerError} evt.error
   */
  'messages:sent-error',

  /**
   * A message has had a change in its properties.
   *
   * This change may have been delivered from a remote user
   * or as a result of a local operation.
   *
   *      client.on('messages:change', function(evt) {
   *          var recpientStatusChanges = evt.getChangesFor('recipientStatus');
   *          if (recpientStatusChanges.length) {
   *              myView.renderStatus(evt.target);
   *          }
   *      });
   *
   * NOTE: Such rendering would typically be done using events on layer.Query.
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Message} evt.target
   * @param {Object[]} evt.changes
   * @param {Mixed} evt.changes.newValue
   * @param {Mixed} evt.changes.oldValue
   * @param {string} evt.changes.property - Name of the property that has changed
   */
  'messages:change',

  /**
   * A call to layer.Message.load has completed successfully
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Message} evt.target
   */
  'messages:loaded',

  /**
   * A Message has been deleted from the server.
   *
   * Caused by either a successful call to layer.Message.delete() on the Message
   * or by a remote user.
   *
   *      client.on('messages:delete', function(evt) {
   *          myView.removeMessage(evt.target);
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Message} evt.target
   */
  'messages:delete'],
  lifecycle: {
    constructor: function constructor(options) {
      this._models.messages = {};
    },
    cleanup: function cleanup() {
      var _this = this;

      Object.keys(this._models.messages).forEach(function (id) {
        var message = _this._models.messages[id];
        if (message && !message.isDestroyed) {
          message.destroy();
        }
      });
      this._models.messages = null;
    },
    reset: function reset() {
      this._models.messages = {};
    }
  },
  methods: {
    /**
     * Retrieve the message or announcement by ID.
     *
     * Useful for finding a message when you have only the ID.
     *
     * If the message is not found, it will return null.
     *
     * If you want it to load it from cache and then from server if not in cache, use the `canLoad` parameter.
     * If loading from the server, the method will return
     * a layer.Message instance that has no data; the messages:loaded/messages:loaded-error events
     * will let you know when the message has finished/failed loading from the server.
     *
     *      var m = client.getMessage('layer:///messages/123', true)
     *      .on('messages:loaded', function() {
     *          // Render the Message with all of its details loaded
     *          myrerender(m);
     *      });
     *      // Render a placeholder for m until the details of m have loaded
     *      myrender(m);
     *
     *
     * @method getMessage
     * @param  {string} id              - layer:///messages/uuid
     * @param  {boolean} [canLoad=false] - Pass true to allow loading a message from the server if not found
     * @return {layer.Message}
     */
    getMessage: function getMessage(id, canLoad) {
      if (typeof id !== 'string') throw new Error(ErrorDictionary.idParamRequired);

      // NOTE: This could be an announcement
      if (id.indexOf('layer:///')) {
        id = Message.prefixUUID + id;
      }

      if (this._models.messages[id]) {
        return this._models.messages[id];
      } else if (canLoad) {
        return Syncable.load(id, this);
      }
      return null;
    },


    /**
     * Get a MessagePart by ID
     *
     * ```
     * var part = client.getMessagePart('layer:///messages/6f08acfa-3268-4ae5-83d9-6ca00000000/parts/0');
     * ```
     *
     * @method getMessagePart
     * @param {String} id - ID of the Message Part; layer:///messages/uuid/parts/5
     */
    getMessagePart: function getMessagePart(id) {
      if (typeof id !== 'string') throw new Error(ErrorDictionary.idParamRequired);

      var messageId = id.replace(/\/parts.*$/, '');
      var message = this.getMessage(messageId);
      if (message) return message.getPartById(id);
      return null;
    },


    /**
     * Registers a message in _models.messages and triggers events.
     *
     * May also update Conversation.lastMessage.
     *
     * @method _addMessage
     * @protected
     * @param  {layer.Message} message
     */
    _addMessage: function _addMessage(message) {
      if (!this._models.messages[message.id]) {
        this._models.messages[message.id] = message;
        this._triggerAsync('messages:add', { messages: [message] });
        if (message._notify) {
          this._triggerAsync('messages:notify', { message: message });
          message._notify = false;
        }

        var conversation = message.getConversation(false);
        if (conversation && (!conversation.lastMessage || conversation.lastMessage.position < message.position)) {
          var lastMessageWas = conversation.lastMessage;
          conversation.lastMessage = message;
          if (lastMessageWas) this._scheduleCheckAndPurgeCache(lastMessageWas);
        } else {
          this._scheduleCheckAndPurgeCache(message);
        }
      }
    },


    /**
     * Removes message from _models.messages.
     *
     * Accepts IDs or Message instances
     *
     * TODO: Remove support for remove by ID
     *
     * @method _removeMessage
     * @private
     * @param  {layer.Message|string} message or Message ID
     */
    _removeMessage: function _removeMessage(message) {
      var id = typeof message === 'string' ? message : message.id;
      message = this._models.messages[id];
      if (message) {
        delete this._models.messages[id];
        if (!this._inCleanup) {
          this._triggerAsync('messages:remove', { messages: [message] });
          var conv = message.getConversation(false);
          if (conv && conv.lastMessage === message) conv.lastMessage = null;
        }
      }
    },


    /**
     * Handles delete from position event from Websocket.
     *
     * A WebSocket may deliver a `delete` Conversation event with a
     * from_position field indicating that all Messages at the specified position
     * and earlier should be deleted.
     *
     * @method _purgeMessagesByPosition
     * @private
     * @param {string} conversationId
     * @param {number} fromPosition
     */
    _purgeMessagesByPosition: function _purgeMessagesByPosition(conversationId, fromPosition) {
      var _this2 = this;

      Object.keys(this._models.messages).forEach(function (id) {
        var message = _this2._models.messages[id];
        if (message.conversationId === conversationId && message.position <= fromPosition) {
          message.destroy();
        }
      });
    }
  }
};


},{"../layer-error":86,"../models/message":105,"../models/syncable":106}],94:[function(require,module,exports){
'use strict';

/**
 *
 * Adds Query handling to the layer.Client.
 *
 * @class layer.mixins.ClientQueries
 */

var Query = require('../queries/query');
var IdentitiesQuery = require('../queries/identities-query');
var ConversationsQuery = require('../queries/conversations-query');
var ChannelsQuery = require('../queries/channels-query');
var MembersQuery = require('../queries/members-query');
var MessagesQuery = require('../queries/messages-query');
var AnnouncementsQuery = require('../queries/announcements-query');
var ErrorDictionary = require('../layer-error').dictionary;

module.exports = {
  events: [],
  lifecycle: {
    constructor: function constructor(options) {
      this._models.queries = {};
    },
    cleanup: function cleanup() {
      var _this = this;

      Object.keys(this._models.queries).forEach(function (id) {
        var query = _this._models.queries[id];
        if (query && !query.isDestroyed) {
          query.destroy();
        }
      });
      this._models.queries = null;
    },
    reset: function reset() {
      this._models.queries = {};
    }
  },
  methods: {
    /**
     * Retrieve the query by query id.
     *
     * Useful for finding a Query when you only have the ID
     *
     * @method getQuery
     * @param  {string} id              - layer:///queries/uuid
     * @return {layer.Query}
     */
    getQuery: function getQuery(id) {
      if (typeof id !== 'string') throw new Error(ErrorDictionary.idParamRequired);
      return this._models.queries[id] || null;
    },


    /**
     * There are two options to create a new layer.Query instance.
     *
     * The direct way:
     *
     *     var query = client.createQuery({
     *         model: layer.Query.Message,
     *         predicate: 'conversation.id = '' + conv.id + ''',
     *         paginationWindow: 50
     *     });
     *
     * A Builder approach that allows for a simpler syntax:
     *
     *     var qBuilder = QueryBuilder
     *      .messages()
     *      .forConversation('layer:///conversations/ffffffff-ffff-ffff-ffff-ffffffffffff')
     *      .paginationWindow(100);
     *     var query = client.createQuery(qBuilder);
     *
     * @method createQuery
     * @param  {layer.QueryBuilder|Object} options - Either a layer.QueryBuilder instance, or parameters for the layer.Query constructor
     * @return {layer.Query}
     */
    createQuery: function createQuery(options) {
      var query = void 0;

      if (typeof options.build === 'function') {
        options = options.build();
      }
      options.client = this;
      switch (options.model) {
        case Query.Identity:
          query = new IdentitiesQuery(options);
          break;
        case Query.Conversation:
          query = new ConversationsQuery(options);
          break;
        case Query.Channel:
          query = new ChannelsQuery(options);
          break;
        case Query.Membership:
          query = new MembersQuery(options);
          break;
        case Query.Message:
          query = new MessagesQuery(options);
          break;
        case Query.Announcement:
          query = new AnnouncementsQuery(options);
          break;

        default:
          query = new Query(options);
      }
      this._addQuery(query);
      return query;
    },


    /**
     * Register the layer.Query.
     *
     * @method _addQuery
     * @private
     * @param  {layer.Query} query
     */
    _addQuery: function _addQuery(query) {
      this._models.queries[query.id] = query;
    },


    /**
     * Deregister the layer.Query.
     *
     * @method _removeQuery
     * @private
     * @param  {layer.Query} query [description]
     */
    _removeQuery: function _removeQuery(query) {
      var _this2 = this;

      if (query) {
        delete this._models.queries[query.id];
        if (!this._inCleanup) {
          var data = query.data.map(function (obj) {
            return _this2.getObject(obj.id);
          }).filter(function (obj) {
            return obj;
          });
          this._checkAndPurgeCache(data);
        }
        this.off(null, null, query);
      }
    }
  }
};


},{"../layer-error":86,"../queries/announcements-query":108,"../queries/channels-query":109,"../queries/conversations-query":110,"../queries/identities-query":111,"../queries/members-query":112,"../queries/messages-query":113,"../queries/query":115}],95:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Announcement class represents a type of Message sent by a server.
 *
 * Announcements can not be sent using the WebSDK, only received.
 *
 * You should never need to instantiate an Announcement; they should only be
 * delivered via `messages:add` events when an Announcement is provided via
 * websocket to the client, and `change` events on an Announcements Query.
 *
 * @class  layer.Announcement
 * @extends layer.Message.ConversationMessage
 */

var ConversationMessage = require('./conversation-message');
var Syncable = require('./syncable');
var Root = require('../root');
var LayerError = require('../layer-error');

var Announcement = function (_ConversationMessage) {
  _inherits(Announcement, _ConversationMessage);

  function Announcement() {
    _classCallCheck(this, Announcement);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Announcement).apply(this, arguments));
  }

  _createClass(Announcement, [{
    key: 'send',


    /**
     * @method send
     * @hide
     */
    value: function send() {}

    /**
     * @method _send
     * @hide
     */

  }, {
    key: '_send',
    value: function _send() {}

    /**
     * @method getConversation
     * @hide
     */

  }, {
    key: 'getConversation',
    value: function getConversation() {}
  }, {
    key: '_loaded',
    value: function _loaded(data) {
      this.getClient()._addMessage(this);
    }

    /**
     * Delete the Announcement from the server.
     *
     * @method delete
     */

  }, {
    key: 'delete',
    value: function _delete() {
      if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);

      var id = this.id;
      var client = this.getClient();
      this._xhr({
        url: '',
        method: 'DELETE'
      }, function (result) {
        if (!result.success && (!result.data || result.data.id !== 'not_found')) Syncable.load(id, client);
      });

      this._deleted();
      this.destroy();
    }

    /**
     * Creates an Announcement from the server's representation of an Announcement.
     *
     * Similar to _populateFromServer, however, this method takes a
     * message description and returns a new message instance using _populateFromServer
     * to setup the values.
     *
     * @method _createFromServer
     * @protected
     * @static
     * @param  {Object} message - Server's representation of the announcement
     * @return {layer.Announcement}
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(message, client) {
      var fromWebsocket = message.fromWebsocket;
      return new Announcement({
        fromServer: message,
        clientId: client.appId,
        _notify: fromWebsocket && message.is_unread
      });
    }
  }]);

  return Announcement;
}(ConversationMessage);

/**
 * @property {String} conversationId
 * @hide
 */

/**
 * @property {Object} deliveryStatus
 * @hide
 */

/**
 * @property {Object} readStatus
 * @hide
 */

/**
 * @property {Object} recipientStatus
 * @hide
 */

/**
 * @method addPart
 * @hide
 */

/**
 * @method send
 * @hide
 */

/**
 * @method isSaved
 * @hide
 */

/**
 * @method isSaving
 * @hide
 */

Announcement.prefixUUID = 'layer:///announcements/';

Announcement.bubbleEventParent = 'getClient';

Announcement._supportedEvents = [].concat(ConversationMessage._supportedEvents);

Announcement.inObjectIgnore = ConversationMessage.inObjectIgnore;
Root.initClass.apply(Announcement, [Announcement, 'Announcement']);
Syncable.subclasses.push(Announcement);
module.exports = Announcement;


},{"../layer-error":86,"../root":116,"./conversation-message":100,"./syncable":106}],96:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * For purposes of API consistency across SDKs, this class is not exposed.
 * Instead, customers will see only the layer.Message class.
 *
 * @class layer.Message.ChannelMessage
 * @extends layer.Message
 */
var Root = require('../root');
var Message = require('./message');
var ClientRegistry = require('../client-registry');
var LayerError = require('../layer-error');
var Constants = require('../const');
var logger = require('../logger');

var ChannelMessage = function (_Message) {
  _inherits(ChannelMessage, _Message);

  function ChannelMessage(options) {
    _classCallCheck(this, ChannelMessage);

    if (options.channel) options.conversationId = options.channel.id;

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ChannelMessage).call(this, options));

    var client = _this.getClient();
    _this.isInitializing = false;
    if (options && options.fromServer) {
      client._addMessage(_this);
    }
    return _this;
  }

  /**
   * Get the layer.Channel associated with this layer.Message.ChannelMessage.
   *
   * @method getConversation
   * @param {Boolean} load       Pass in true if the layer.Channel should be loaded if not found locally
   * @return {layer.Channel}
   */


  _createClass(ChannelMessage, [{
    key: 'getConversation',
    value: function getConversation(load) {
      if (this.conversationId) {
        return ClientRegistry.get(this.clientId).getChannel(this.conversationId, load);
      }
      return null;
    }

    /**
     * Send a Read or Delivery Receipt to the server; not supported yet.
     *
     * @method sendReceipt
     * @param {string} [type=layer.Constants.RECEIPT_STATE.READ] - One of layer.Constants.RECEIPT_STATE.READ or layer.Constants.RECEIPT_STATE.DELIVERY
     * @return {layer.Message.ChannelMessage} this
     */

  }, {
    key: 'sendReceipt',
    value: function sendReceipt() {
      var type = arguments.length <= 0 || arguments[0] === undefined ? Constants.RECEIPT_STATE.READ : arguments[0];

      logger.warn('Receipts not supported for Channel Messages yet');
      return this;
    }

    /**
     * Delete the Message from the server.
     *
     * ```
     * message.delete();
     * ```
     *
     * @method delete
     */

  }, {
    key: 'delete',
    value: function _delete() {
      if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);

      var id = this.id;
      var client = this.getClient();
      this._xhr({
        url: '',
        method: 'DELETE'
      }, function (result) {
        if (!result.success && (!result.data || result.data.id !== 'not_found')) Message.load(id, client);
      });

      this._deleted();
      this.destroy();
    }

    /**
     * On loading this one item from the server, after _populateFromServer has been called, due final setup.
     *
     * @method _loaded
     * @private
     * @param {Object} data  Data from server
     */

  }, {
    key: '_loaded',
    value: function _loaded(data) {
      this.conversationId = data.channel.id;
      this.getClient()._addMessage(this);
    }

    /**
     * Creates a message from the server's representation of a message.
     *
     * Similar to _populateFromServer, however, this method takes a
     * message description and returns a new message instance using _populateFromServer
     * to setup the values.
     *
     * @method _createFromServer
     * @protected
     * @static
     * @param  {Object} message - Server's representation of the message
     * @param  {layer.Client} client
     * @return {layer.Message.ChannelMessage}
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(message, client) {
      var fromWebsocket = message.fromWebsocket;
      var conversationId = void 0;
      if (message.channel) {
        conversationId = message.channel.id;
      } else {
        conversationId = message.conversationId;
      }

      return new ChannelMessage({
        conversationId: conversationId,
        fromServer: message,
        clientId: client.appId,
        _fromDB: message._fromDB,
        _notify: fromWebsocket && message.is_unread && message.sender.user_id !== client.user.userId
      });
    }
  }]);

  return ChannelMessage;
}(Message);

/*
 * True if this Message has been read by this user.
 *
 * You can change isRead programatically
 *
 *      m.isRead = true;
 *
 * This will automatically notify the server that the message was read by your user.
 * @type {Boolean}
 */


ChannelMessage.prototype.isRead = false;

ChannelMessage.inObjectIgnore = Message.inObjectIgnore;
ChannelMessage._supportedEvents = [].concat(Message._supportedEvents);
Root.initClass.apply(ChannelMessage, [ChannelMessage, 'ChannelMessage']);
module.exports = ChannelMessage;


},{"../client-registry":81,"../const":84,"../layer-error":86,"../logger":88,"../root":116,"./message":105}],97:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A Channel object represents a dialog amongst a large set
 * of participants.
 *
 * ```
 * var channel = client.createChannel({
 *   name: "frodo-the-dodo",
 *   members: ["layer:///identities/samwise", "layer:///identities/orc-army"],
 *   metadata: {
 *     subtopic: "Sauruman is the man.  And a Saurian",
 *     tooMuchInfo: {
 *       nose: "stuffed"
 *     }
 *   }
 * });
 *
 * channel.createMessage("Please don't eat me").send();
 * ```
 * NOTE: Sending a Message creates the Channel; this avoids having lots of unused channels being created.
 *
 * Key methods, events and properties for getting started:
 *
 * Properties:
 *
 * * layer.Channel.id: this property is worth being familiar with; it identifies the
 *   Channel and can be used in `client.getChannel(id)` to retrieve it.
 * * layer.Channel.name: this property names the channel; this may be human readable, though for localization purposes,
 *   you may instead want to use a common name that is distinct from your displayed name.  There can only be a single
 *   channel with a given name per app.
 * * layer.Channel.membership: Contains status information about your user's role in this Channel.
 * * layer.Channel.isCurrentParticipant: Shorthand for determining if your user is a member of the Channel.
 *
 * Methods:
 *
 * * layer.Channel.join() to join the Channel
 * * layer.Channel.leave() to leave the Channel
 * * layer.Channel.on() and layer.Channel.off(): event listeners built on top of the `backbone-events-standalone` npm project
 * * layer.Channel.createMessage() to send a message on the Channel.
 *
 * Events:
 *
 * * `channels:change`: Useful for observing changes to Channel name
 *   and updating rendering of your Channel
 *
 * Finally, to access a list of Messages in a Channel, see layer.Query.
 *
 * @class  layer.Channel
 * @experimental This feature is incomplete, and available as Preview only.
 * @extends layer.Container
 * @author  Michael Kantor
 */
var Root = require('../root');
var Syncable = require('./syncable');
var Container = require('./container');
var ChannelMessage = require('./channel-message');
var LayerError = require('../layer-error');
var LayerEvent = require('../layer-event');
var Util = require('../client-utils');
var Constants = require('../const');

var Channel = function (_Container) {
  _inherits(Channel, _Container);

  function Channel() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Channel);

    // Setup default values
    if (!options.membership) options.membership = {};

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Channel).call(this, options));

    _this._members = _this.getClient()._fixIdentities(options.members || []).map(function (item) {
      return item.id;
    });
    _this._register();
    return _this;
  }

  /**
   * Destroy the local copy of this Channel, cleaning up all resources
   * it consumes.
   *
   * @method destroy
   */


  _createClass(Channel, [{
    key: 'destroy',
    value: function destroy() {
      this.lastMessage = null;
      this.getClient()._removeChannel(this);
      _get(Object.getPrototypeOf(Channel.prototype), 'destroy', this).call(this);
      this.membership = null;
    }

    /**
     * Create a new layer.Message.ChannelMessage instance within this conversation
     *
     *      var message = channel.createMessage('hello');
     *
     *      var message = channel.createMessage({
     *          parts: [new layer.MessagePart({
     *                      body: 'hello',
     *                      mimeType: 'text/plain'
     *                  })]
     *      });
     *
     * See layer.Message.ChannelMessage for more options for creating the message.
     *
     * @method createMessage
     * @param  {String|Object} options - If its a string, a MessagePart is created around that string.
     * @param {layer.MessagePart[]} options.parts - An array of MessageParts.  There is some tolerance for
     *                                               it not being an array, or for it being a string to be turned
     *                                               into a MessagePart.
     * @return {layer.Message.ChannelMessage}
     */

  }, {
    key: 'createMessage',
    value: function createMessage() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var messageConfig = typeof options === 'string' ? {
        parts: [{ body: options, mimeType: 'text/plain' }]
      } : options;
      messageConfig.clientId = this.clientId;
      messageConfig.conversationId = this.id;

      return new ChannelMessage(messageConfig);
    }
  }, {
    key: '_setupMessage',
    value: function _setupMessage(message) {
      message.position = Channel.nextPosition;
      Channel.nextPosition += 8192;
    }

    /**
     * Gets the data for a Create request.
     *
     * The layer.SyncManager needs a callback to create the Conversation as it
     * looks NOW, not back when `send()` was called.  This method is called
     * by the layer.SyncManager to populate the POST data of the call.
     *
     * @method _getSendData
     * @private
     * @return {Object} Websocket data for the request
     */

  }, {
    key: '_getSendData',
    value: function _getSendData(data) {
      var isMetadataEmpty = Util.isEmpty(this.metadata);
      var members = this._members || [];
      if (members.indexOf(this.getClient().user.id) === -1) members.push(this.getClient().user.id);
      return {
        method: 'Channel.create',
        data: {
          name: this.name,
          metadata: isMetadataEmpty ? null : this.metadata,
          id: this.id,
          members: members
        }
      };
    }
  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(channel) {
      this._inPopulateFromServer = true;

      // Disable events if creating a new Conversation
      // We still want property change events for anything that DOES change
      this._disableEvents = this.syncState === Constants.SYNC_STATE.NEW;
      this.name = channel.name;

      this.isCurrentParticipant = Boolean(channel.membership);
      this.membership = !channel.membership || !channel.membership.id ? null : this.getClient()._createObject(channel.membership);

      _get(Object.getPrototypeOf(Channel.prototype), '_populateFromServer', this).call(this, channel);
      this._register();

      this._disableEvents = false;
    }
  }, {
    key: '_createResultConflict',
    value: function _createResultConflict(data) {
      var channel = data.data;
      if (channel) {
        this._createSuccess(channel);
      } else {
        this.syncState = Constants.SYNC_STATE.NEW;
        this._syncCounter = 0;
        this.trigger('channels:sent-error', { error: data });
      }

      this._inPopulateFromServer = false;
    }
  }, {
    key: '__adjustName',
    value: function __adjustName(newValue) {
      if (this._inPopulateFromServer || this._inLayerParser || this.isNew() || this.isLoading) return;
      throw new Error(LayerError.dictionary.permissionDenied);
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any change in the name property will call this method and fire a
     * change event.
     *
     * @method __updateName
     * @private
     * @param  {string} newValue
     * @param  {string} oldValue
     */

  }, {
    key: '__updateName',
    value: function __updateName(newValue, oldValue) {
      this._triggerAsync('channels:change', {
        property: 'name',
        oldValue: oldValue,
        newValue: newValue
      });
    }

    /**
     * Add the following members to the Channel.
     *
     * Unlike Conversations, Channels do not maintain state information about their members.
     * As such, if the operation fails there is no actual state change
     * for the channel.  Currently the only errors exposed are from the layer.Client.SyncManager.
     *
     * @method addMembers
     * @param {String[]} members   Identity IDs of users to add to this Channel
     * @return {layer.Channel} this
     *
     *
     *
     *
     *
     * @ignore until server supports it
     */

  }, {
    key: 'addMembers',
    value: function addMembers(members) {
      var _this2 = this;

      members = this.getClient()._fixIdentities(members).map(function (item) {
        return item.id;
      });
      if (this.syncState === Constants.SYNC_STATE.NEW) {
        this._members = this._members.concat(members);
        return this;
      }

      // TODO: Should use the bulk operation when it becomes available.
      members.forEach(function (identityId) {
        _this2._xhr({
          url: '/members/' + identityId.replace(/^layer:\/\/\/identities\//, ''),
          method: 'PUT'
        });
      });
      return this;
    }

    /**
     * Remove the following members from the Channel.
     *
     * Not yet supported.
     *
     * @method removeMembers
     * @param {String[]} members   Identity IDs of users to remove from this Channel
     * @return {layer.Channel} this
     *
     *
     *
     *
     *
     * @ignore until server supports it
     */

  }, {
    key: 'removeMembers',
    value: function removeMembers(members) {
      var _this3 = this;

      members = this.getClient()._fixIdentities(members).map(function (item) {
        return item.id;
      });

      if (this.syncState === Constants.SYNC_STATE.NEW) {
        members.forEach(function (id) {
          var index = _this3._members.indexOf(id);
          if (index !== -1) _this3._members.splice(index, 1);
        });
        return this;
      }

      // TODO: Should use the bulk operation when it becomes available.
      members.forEach(function (identityId) {
        _this3._xhr({
          url: '/members/' + identityId.replace(/^layer:\/\/\/identities\//, ''),
          method: 'DELETE'
        });
      });
      return this;
    }

    /**
     * Add the current user to this channel.
     *
     * @method join
     * @return {layer.Channel} this
     *
     *
     *
     *
     *
     * @ignore until server supports it
     */

  }, {
    key: 'join',
    value: function join() {
      return this.addMembers([this.getClient().user.id]);
    }

    /**
     * remove the current user from this channel.
     *
     * @method leave
     * @return {layer.Channel} this
     *
     *
     *
     *
     * @ignore until server supports it
     */

  }, {
    key: 'leave',
    value: function leave() {
      return this.removeMembers([this.getClient().user.id]);
    }

    /**
     * Return a Membership object for the specified Identity ID.
     *
     * If `members:loaded` is triggered, then your membership object
     * has been populated with data.
     *
     * If `members:loaded-error` is triggered, then your membership object
     * could not be loaded, either you have a connection error, or the user is not a member.
     *
     * ```
     * var membership = channel.getMember('FrodoTheDodo');
     * membership.on('membership:loaded', function(evt) {
     *    alert('He IS a member, quick, kick him out!');
     * });
     * membership.on('membership:loaded-error', function(evt) {
     *    if (evt.error.id === 'not_found') {
     *      alert('Sauruman, he is with the Elves!');
     *    } else {
     *      alert('Sauruman, would you please pick up your Palantir already? I can't connect!');
     *    }
     * });
     * ```
     * @method getMember
     * @param {String} identityId
     * @returns {layer.Membership}
     */

  }, {
    key: 'getMember',
    value: function getMember(identityId) {
      identityId = this.getClient()._fixIdentities([identityId])[0].id;
      var membershipId = this.id + '/members/' + identityId.replace(/layer:\/\/\/identities\//, '');
      return this.getClient().getMember(membershipId, true);
    }

    /**
     * Delete the channel; not currently supported.
     *
     * @method delete
     */

  }, {
    key: 'delete',
    value: function _delete() {
      this._delete('');
    }

    /**
     * LayerPatch will call this after changing any properties.
     *
     * Trigger any cleanup or events needed after these changes.
     *
     * TODO: Move this to layer.Container
     *
     * @method _handlePatchEvent
     * @private
     * @param  {Mixed} newValue - New value of the property
     * @param  {Mixed} oldValue - Prior value of the property
     * @param  {string[]} paths - Array of paths specifically modified: ['participants'], ['metadata.keyA', 'metadata.keyB']
     */

  }, {
    key: '_handlePatchEvent',
    value: function _handlePatchEvent(newValue, oldValue, paths) {
      // Certain types of __update handlers are disabled while values are being set by
      // layer patch parser because the difference between setting a value (triggers an event)
      // and change a property of a value (triggers only this callback) result in inconsistent
      // behaviors.  Enable them long enough to allow __update calls to be made
      this._inLayerParser = false;
      try {
        var events = this._disableEvents;
        this._disableEvents = false;
        _get(Object.getPrototypeOf(Channel.prototype), '_handlePatchEvent', this).call(this, newValue, oldValue, paths);
        this._disableEvents = events;
      } catch (err) {
        // do nothing
      }
      this._inLayerParser = true;
    }

    /**
     * Register this Channel with the Client
     *
     * @method _register
     * @private
     */

  }, {
    key: '_register',
    value: function _register() {
      var client = this.getClient();
      client._addChannel(this);
    }
  }, {
    key: '_deleteResult',
    value: function _deleteResult(result, id) {
      var client = this.getClient();
      if (!result.success && (!result.data || result.data.id !== 'not_found')) Channel.load(id, client);
    }

    /**
     * Returns a plain object.
     *
     * Object will have all the same public properties as this
     * Conversation instance.  New object is returned any time
     * any of this object's properties change.
     *
     * @method toObject
     * @return {Object} POJO version of this.
     */

  }, {
    key: 'toObject',
    value: function toObject() {
      if (!this._toObject) {
        this._toObject = _get(Object.getPrototypeOf(Channel.prototype), 'toObject', this).call(this);
        this._toObject.membership = Util.clone(this.membership);
      }
      return this._toObject;
    }

    /**
     * Create a channel instance from a server representation of the channel.
     *
     * If the Channel already exists, will update the existing copy with
     * presumably newer values.
     *
     * @method _createFromServer
     * @protected
     * @static
     * @param  {Object} channel - Server representation of a Channel
     * @param  {layer.Client} client
     * @return {layer.Channel}
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(channel, client) {
      return new Channel({
        client: client,
        fromServer: channel,
        _fromDB: channel._fromDB
      });
    }

    /**
     * Find or create a new Channel.
     *
     *      var channel = layer.Channel.create({
     *          members: ['a', 'b'],
     *          private: true,
     *          metadata: {
     *              titleDetails: 'I am not a detail!'
     *          },
     *          client: client,
     *          'channels:loaded': function(evt) {
     *
     *          }
     *      });
     *
     * Recommend using `client.createChannel({...})`
     * instead of `Channel.create({...})`.
     *
     * @method create
     * @static
     * @protected
     * @param  {Object} options
     * @param  {layer.Client} options.client
     * @param  {string[]/layer.Identity[]} options.members - Array of Participant IDs or layer.Identity objects to create a channel with.
     * @param {boolean} [options.private=false] - Create a private channel
     * @param {Object} [options.metadata={}] - Initial metadata for Channel
     * @return {layer.Channel}
     */

  }, {
    key: 'create',
    value: function create(options) {
      if (!options.client) throw new Error(LayerError.dictionary.clientMissing);
      if (!options.name) options.name = 'channel-' + String(Math.random()).replace(/\./, '');
      var newOptions = {
        name: options.name,
        private: options.private,
        members: options.members ? options.client._fixIdentities(options.members).map(function (item) {
          return item.id;
        }) : [],
        metadata: options.metadata,
        client: options.client
      };

      var channel = options.client.findCachedChannel(function (aChannel) {
        return aChannel.name === newOptions.name;
      });

      if (channel) {
        channel._sendDistinctEvent = new LayerEvent({
          target: channel,
          result: !options.metadata || Util.doesObjectMatch(options.metadata, channel.metadata) ? Channel.FOUND : Channel.FOUND_WITHOUT_REQUESTED_METADATA
        }, 'channels:sent');
      }

      return channel || new Channel(newOptions);
    }
  }]);

  return Channel;
}(Container);

/**
 * The Channel's name; this must be unique.
 *
 * Note that while you can use a displayable human readable name, you may also choose to use this
 * as an ID that you can easily localize to different languages.
 *
 * Must not be a UUID.
 *
 * @property {String} name
 */


Channel.prototype.name = '';

/**
 * The `membership` object contains details of this user's membership within this channel.
 *
 * NOTE: Initially, only `isMember` will be available.
 *
 * ```
 * {
 *     "isMember": true,
 *     "role": "user",
 *     "lastUnreadMessageId: "layer:///messages/UUID"
 * }
 * ```
 * @property {Object}
 */
Channel.prototype.membership = null;

Channel.prototype._members = null;

Channel.eventPrefix = 'channels';

// Math.pow(2, 64); a number larger than Number.MAX_SAFE_INTEGER, and larger than Java's Max Unsigned Long. And an easy to work with
// factor of 2
Channel.nextPosition = 18446744073709552000;

/**
 * Prefix to use when generating an ID for instances of this class
 * @type {String}
 * @static
 * @private
 */
Channel.prefixUUID = 'layer:///channels/';

Channel._supportedEvents = [

/**
 * The conversation is now on the server.
 *
 * Called after successfully creating the conversation
 * on the server.  The Result property is one of:
 *
 * * Channel.CREATED: A new Channel has been created
 * * Channel.FOUND: A matching named Channel has been found
 *
 * @event
 * @param {layer.LayerEvent} event
 * @param {string} event.result
 */
'channels:sent',

/**
 * An attempt to send this channel to the server has failed.
 * @event
 * @param {layer.LayerEvent} event
 * @param {layer.LayerError} event.error
 */
'channels:sent-error',

/**
 * The conversation is now loaded from the server.
 *
 * Note that this is only used in response to the layer.Channel.load() method.
 * from the server.
 * @event
 * @param {layer.LayerEvent} event
 */
'channels:loaded',

/**
 * An attempt to load this conversation from the server has failed.
 *
 * Note that this is only used in response to the layer.Channel.load() method.
 * @event
 * @param {layer.LayerEvent} event
 * @param {layer.LayerError} event.error
 */
'channels:loaded-error',

/**
 * The conversation has been deleted from the server.
 *
 * Caused by either a successful call to delete() on this instance
 * or by a remote user.
 * @event
 * @param {layer.LayerEvent} event
 */
'channels:delete',

/**
 * This channel has changed.
 *
 * @event
 * @param {layer.LayerEvent} event
 * @param {Object[]} event.changes - Array of changes reported by this event
 * @param {Mixed} event.changes.newValue
 * @param {Mixed} event.changes.oldValue
 * @param {string} event.changes.property - Name of the property that changed
 * @param {layer.Conversation} event.target
 */
'channels:change'].concat(Syncable._supportedEvents);

Root.initClass.apply(Channel, [Channel, 'Channel']);
Syncable.subclasses.push(Channel);
module.exports = Channel;


},{"../client-utils":82,"../const":84,"../layer-error":86,"../layer-event":87,"../root":116,"./channel-message":96,"./container":98,"./syncable":106}],98:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A Container is a parent class representing a container that manages a set of Messages.
 *
 * @class  layer.Container
 * @abstract
 * @extends layer.Syncable
 * @author  Michael Kantor
 */
var Syncable = require('./syncable');
var LayerError = require('../layer-error');
var Util = require('../client-utils');
var Constants = require('../const');
var Root = require('../root');

var Container = function (_Syncable) {
  _inherits(Container, _Syncable);

  /**
   * Create a new conversation.
   *
   * The static `layer.Conversation.create()` method
   * will correctly lookup distinct Conversations and
   * return them; `new layer.Conversation()` will not.
   *
   * Developers should use `layer.Conversation.create()`.
   *
   * @method constructor
   * @protected
   * @param  {Object} options
   * @param {string[]/layer.Identity[]} options.participants - Array of Participant IDs or layer.Identity instances
   * @param {boolean} [options.distinct=true] - Is the conversation distinct
   * @param {Object} [options.metadata] - An object containing Conversation Metadata.
   * @return {layer.Conversation}
   */
  function Container() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Container);

    // Make sure the ID from handle fromServer parameter is used by the Root.constructor
    if (options.fromServer) options.id = options.fromServer.id;

    // Make sure we have an clientId property
    if (options.client) options.clientId = options.client.appId;
    if (!options.metadata) options.metadata = {};

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Container).call(this, options));

    if (!_this.clientId) throw new Error(LayerError.dictionary.clientMissing);
    _this.isInitializing = true;

    // If the options contains a full server definition of the object,
    // copy it in with _populateFromServer; this will add the Conversation
    // to the Client as well.
    if (options && options.fromServer) {
      _this._populateFromServer(options.fromServer);
    }

    if (!_this.metadata) _this.metadata = {};

    if (!_this.createdAt) {
      _this.createdAt = new Date();
    }
    _this.isInitializing = false;
    return _this;
  }

  _createClass(Container, [{
    key: 'send',
    value: function send(message) {
      var _this2 = this;

      if (this.isNew()) {
        this.createdAt = new Date();

        // Update the syncState
        this._setSyncing();

        this.getClient().sendSocketRequest({
          method: 'POST',
          body: {}, // see _getSendData
          sync: {
            depends: this.id,
            target: this.id
          }
        }, function (result) {
          return _this2._createResult(result);
        });
      }
      if (message) this._setupMessage(message);
      return this;
    }

    /**
     * Populates this instance using server-data.
     *
     * Side effects add this to the Client.
     *
     * @method _populateFromServer
     * @private
     * @param  {Object} container - Server representation of the container
     */

  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(container) {
      var client = this.getClient();

      this._setSynced();

      var id = this.id;
      this.id = container.id;

      // IDs change if the server returns a matching Container
      if (id !== this.id) {
        client._updateContainerId(this, id);
        this._triggerAsync(this.constructor.eventPrefix + ':change', {
          oldValue: id,
          newValue: this.id,
          property: 'id'
        });
      }

      this.url = container.url;
      this.createdAt = new Date(container.created_at);
      this.metadata = container.metadata;
    }

    /**
     * Process result of send method.
     *
     * Note that we use _triggerAsync so that
     * events reporting changes to the layer.Conversation.id can
     * be applied before reporting on it being sent.
     *
     * Example: Query will now have the resolved Distinct IDs rather than the proposed ID
     * when this event is triggered.
     *
     * @method _createResult
     * @private
     * @param  {Object} result
     */

  }, {
    key: '_createResult',
    value: function _createResult(_ref) {
      var success = _ref.success;
      var data = _ref.data;

      if (this.isDestroyed) return;
      if (success) {
        this._createSuccess(data);
      } else if (data.id === 'conflict') {
        this._createResultConflict(data);
      } else {
        this.trigger(this.constructor.eventPrefix + ':sent-error', { error: data });
        this.destroy();
      }
    }

    /**
     * Process the successful result of a create call
     *
     * @method _createSuccess
     * @private
     * @param  {Object} data Server description of Conversation/Channel
     */

  }, {
    key: '_createSuccess',
    value: function _createSuccess(data) {
      var id = this.id;
      this._populateFromServer(data);
      this._triggerAsync(this.constructor.eventPrefix + ':sent', {
        result: id === this.id ? Container.CREATED : Container.FOUND
      });
    }

    /**
     * Updates specified metadata keys.
     *
     * Updates the local object's metadata and syncs the change to the server.
     *
     *      conversation.setMetadataProperties({
     *          'title': 'I am a title',
     *          'colors.background': 'red',
     *          'colors.text': {
     *              'fill': 'blue',
     *              'shadow': 'black'
     *           },
     *           'colors.title.fill': 'red'
     *      });
     *
     * Use setMetadataProperties to specify the path to a property, and a new value for that property.
     * Multiple properties can be changed this way.  Whatever value was there before is
     * replaced with the new value; so in the above example, whatever other keys may have
     * existed under `colors.text` have been replaced by the new object `{fill: 'blue', shadow: 'black'}`.
     *
     * Note also that only string and subobjects are accepted as values.
     *
     * Keys with '.' will update a field of an object (and create an object if it wasn't there):
     *
     * Initial metadata: {}
     *
     *      conversation.setMetadataProperties({
     *          'colors.background': 'red',
     *      });
     *
     * Metadata is now: `{colors: {background: 'red'}}`
     *
     *      conversation.setMetadataProperties({
     *          'colors.foreground': 'black',
     *      });
     *
     * Metadata is now: `{colors: {background: 'red', foreground: 'black'}}`
     *
     * Executes as follows:
     *
     * 1. Updates the metadata property of the local object
     * 2. Triggers a conversations:change event
     * 3. Submits a request to be sent to the server to update the server's object
     * 4. If there is an error, no errors are fired except by layer.SyncManager, but another
     *    conversations:change event is fired as the change is rolled back.
     *
     * @method setMetadataProperties
     * @param  {Object} properties
     * @return {layer.Conversation} this
     *
     */

  }, {
    key: 'setMetadataProperties',
    value: function setMetadataProperties(props) {
      var _this3 = this;

      var layerPatchOperations = [];
      Object.keys(props).forEach(function (name) {
        var fullName = name;
        if (name) {
          if (name !== 'metadata' && name.indexOf('metadata.') !== 0) {
            fullName = 'metadata.' + name;
          }
          layerPatchOperations.push({
            operation: 'set',
            property: fullName,
            value: props[name]
          });
        }
      });

      this._inLayerParser = true;

      // Do this before setSyncing as if there are any errors, we should never even
      // start setting up a request.
      Util.layerParse({
        object: this,
        type: 'Conversation',
        operations: layerPatchOperations,
        client: this.getClient()
      });
      this._inLayerParser = false;

      this._xhr({
        url: '',
        method: 'PATCH',
        data: JSON.stringify(layerPatchOperations),
        headers: {
          'content-type': 'application/vnd.layer-patch+json'
        }
      }, function (result) {
        if (!result.success && !_this3.isDestroyed) _this3._load();
      });

      return this;
    }

    /**
     * Deletes specified metadata keys.
     *
     * Updates the local object's metadata and syncs the change to the server.
     *
     *      conversation.deleteMetadataProperties(
     *          ['title', 'colors.background', 'colors.title.fill']
     *      );
     *
     * Use deleteMetadataProperties to specify paths to properties to be deleted.
     * Multiple properties can be deleted.
     *
     * Executes as follows:
     *
     * 1. Updates the metadata property of the local object
     * 2. Triggers a conversations:change event
     * 3. Submits a request to be sent to the server to update the server's object
     * 4. If there is an error, no errors are fired except by layer.SyncManager, but another
     *    conversations:change event is fired as the change is rolled back.
     *
     * @method deleteMetadataProperties
     * @param  {string[]} properties
     * @return {layer.Conversation} this
     */

  }, {
    key: 'deleteMetadataProperties',
    value: function deleteMetadataProperties(props) {
      var _this4 = this;

      var layerPatchOperations = [];
      props.forEach(function (property) {
        if (property !== 'metadata' && property.indexOf('metadata.') !== 0) {
          property = 'metadata.' + property;
        }
        layerPatchOperations.push({
          operation: 'delete',
          property: property
        });
      }, this);

      this._inLayerParser = true;

      // Do this before setSyncing as if there are any errors, we should never even
      // start setting up a request.
      Util.layerParse({
        object: this,
        type: 'Conversation',
        operations: layerPatchOperations,
        client: this.getClient()
      });
      this._inLayerParser = false;

      this._xhr({
        url: '',
        method: 'PATCH',
        data: JSON.stringify(layerPatchOperations),
        headers: {
          'content-type': 'application/vnd.layer-patch+json'
        }
      }, function (result) {
        if (!result.success) _this4._load();
      });

      return this;
    }

    /**
     * Delete the Conversation from the server (internal version).
     *
     * This version of Delete takes a Query String that is packaged up by
     * layer.Conversation.delete and layer.Conversation.leave.
     *
     * @method _delete
     * @private
     * @param {string} queryStr - Query string for the DELETE request
     */

  }, {
    key: '_delete',
    value: function _delete(queryStr) {
      var _this5 = this;

      var id = this.id;
      this._xhr({
        method: 'DELETE',
        url: '?' + queryStr
      }, function (result) {
        return _this5._deleteResult(result, id);
      });

      this._deleted();
      this.destroy();
    }
  }, {
    key: '_handleWebsocketDelete',
    value: function _handleWebsocketDelete(data) {
      if (data.mode === Constants.DELETION_MODE.MY_DEVICES && data.from_position) {
        this.getClient()._purgeMessagesByPosition(this.id, data.from_position);
      } else {
        _get(Object.getPrototypeOf(Container.prototype), '_handleWebsocketDelete', this).call(this);
      }
    }
  }, {
    key: '_getUrl',
    value: function _getUrl(url) {
      return this.url + (url || '');
    }
  }, {
    key: '_loaded',
    value: function _loaded(data) {
      this._register(this);
    }

    /**
     * Standard `on()` provided by layer.Root.
     *
     * Adds some special handling of 'conversations:loaded' so that calls such as
     *
     *      var c = client.getConversation('layer:///conversations/123', true)
     *      .on('conversations:loaded', function() {
     *          myrerender(c);
     *      });
     *      myrender(c); // render a placeholder for c until the details of c have loaded
     *
     * can fire their callback regardless of whether the client loads or has
     * already loaded the Conversation.
     *
     * @method on
     * @param  {string} eventName
     * @param  {Function} callback
     * @param  {Object} context
     * @return {layer.Conversation} this
     */

  }, {
    key: 'on',
    value: function on(name, callback, context) {
      var evtName = this.constructor.eventPrefix + ':loaded';
      var hasLoadedEvt = name === evtName || name && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && name[evtName];

      if (hasLoadedEvt && !this.isLoading) {
        (function () {
          var callNow = name === evtName ? callback : name[evtName];
          Util.defer(function () {
            return callNow.apply(context);
          });
        })();
      }
      _get(Object.getPrototypeOf(Container.prototype), 'on', this).call(this, name, callback, context);

      return this;
    }
  }, {
    key: '_triggerAsync',
    value: function _triggerAsync(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Container.prototype), '_triggerAsync', this).call(this, evtName, args);
    }
  }, {
    key: 'trigger',
    value: function trigger(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Container.prototype), 'trigger', this).call(this, evtName, args);
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any change in the metadata property will call this method and fire a
     * change event.  Changes to the metadata object that don't replace the object
     * with a new object will require directly calling this method.
     *
     * @method __updateMetadata
     * @private
     * @param  {Object} newValue
     * @param  {Object} oldValue
     */

  }, {
    key: '__updateMetadata',
    value: function __updateMetadata(newValue, oldValue, paths) {
      if (this._inLayerParser) return;
      if (JSON.stringify(newValue) !== JSON.stringify(oldValue)) {
        this._triggerAsync(this.constructor.eventPrefix + ':change', {
          property: 'metadata',
          newValue: newValue,
          oldValue: oldValue,
          paths: paths
        });
      }
    }
  }, {
    key: '_handlePatchEvent',
    value: function _handlePatchEvent(newValue, oldValue, paths) {
      if (paths[0].indexOf('metadata') === 0) {
        this.__updateMetadata(newValue, oldValue, paths);
      }
    }

    /**
     * Returns a plain object.
     *
     * Object will have all the same public properties as this
     * Conversation instance.  New object is returned any time
     * any of this object's properties change.
     *
     * @method toObject
     * @return {Object} POJO version of this.
     */

  }, {
    key: 'toObject',
    value: function toObject() {
      if (!this._toObject) {
        this._toObject = _get(Object.getPrototypeOf(Container.prototype), 'toObject', this).call(this);
        this._toObject.metadata = Util.clone(this.metadata);
      }
      return this._toObject;
    }

    /**
     * Identifies whether a Conversation receiving the specified patch data should be loaded from the server.
     *
     * Any change to a Conversation indicates that the Conversation is active and of potential interest; go ahead and load that
     * Conversation in case the app has need of it.  In the future we may ignore changes to unread count.  Only relevant
     * when we get Websocket events for a Conversation that has not been loaded/cached on Client.
     *
     * @method _loadResourceForPatch
     * @static
     * @private
     */

  }], [{
    key: '_loadResourceForPatch',
    value: function _loadResourceForPatch(patchData) {
      return true;
    }
  }]);

  return Container;
}(Syncable);

/**
 * Time that the conversation was created on the server.
 *
 * @type {Date}
 */


Container.prototype.createdAt = null;

/**
 * Metadata for the conversation.
 *
 * Metadata values can be plain objects and strings, but
 * no arrays, numbers, booleans or dates.
 * @type {Object}
 */
Container.prototype.metadata = null;

/**
 * The authenticated user is a current participant in this Conversation.
 *
 * Set to false if the authenticated user has been removed from this conversation.
 *
 * A removed user can see messages up to the time they were removed,
 * but can no longer interact with the conversation.
 *
 * A removed user can no longer see the participant list.
 *
 * Read and Delivery receipts will fail on any Message in such a Conversation.
 *
 * @type {Boolean}
 */
Container.prototype.isCurrentParticipant = true;

/**
 * Cache's a Distinct Event.
 *
 * On creating a Channel or Conversation that already exists,
 * when the send() method is called, we should trigger
 * specific events detailing the results.  Results
 * may be determined locally or on the server, but same Event may be needed.
 *
 * @type {layer.LayerEvent}
 * @private
 */
Container.prototype._sendDistinctEvent = null;

/**
 * Caches last result of toObject()
 * @type {Object}
 * @private
 */
Container.prototype._toObject = null;

/**
 * Property to look for when bubbling up events.
 * @type {String}
 * @static
 * @private
 */
Container.bubbleEventParent = 'getClient';

/**
 * The Conversation/Channel that was requested has been created.
 *
 * Used in `conversations:sent` events.
 * @type {String}
 * @static
 */
Container.CREATED = 'Created';

/**
 * The Conversation/Channel that was requested has been found.
 *
 * This means that it did not need to be created.
 *
 * Used in `conversations:sent` events.
 * @type {String}
 * @static
 */
Container.FOUND = 'Found';

/**
 * The Conversation/Channel that was requested has been found, but there was a mismatch in metadata.
 *
 * If the createConversation request contained metadata and it did not match the Distinct Conversation
 * that matched the requested participants, then this value is passed to notify your app that the Conversation
 * was returned but does not exactly match your request.
 *
 * Used in `conversations:sent` events.
 * @type {String}
 * @static
 */
Container.FOUND_WITHOUT_REQUESTED_METADATA = 'FoundMismatch';

Root.initClass.apply(Container, [Container, 'Container']);
Syncable.subclasses.push(Container);
module.exports = Container;


},{"../client-utils":82,"../const":84,"../layer-error":86,"../root":116,"./syncable":106}],99:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Content class represents Rich Content.
 *
 * Note that instances of this class will automatically be
 * generated for developers based on whether their message parts
 * require it.
 *
 * That means for the most part, you should never need to
 * instantiate one of these directly.
 *
 *      var content = new layer.Content({
 *          id: 'layer:///content/8c839735-5f95-439a-a867-30903c0133f2'
 *      });
 *
 * @class  layer.Content
 * @private
 * @extends layer.Root
 * @author Michael Kantor
 */

var Root = require('../root');
var xhr = require('../xhr');

var Content = function (_Root) {
  _inherits(Content, _Root);

  /**
   * Constructor
   *
   * @method constructor
   * @param  {Object} options
   * @param  {string} options.id - Identifier for the content
   * @param  {string} [options.downloadUrl=null] - Url to download the content from
   * @param  {Date} [options.expiration] - Expiration date for the url
   * @param  {string} [options.refreshUrl] - Url to access to get a new downloadUrl after it has expired
   *
   * @return {layer.Content}
   */
  function Content(options) {
    _classCallCheck(this, Content);

    if (typeof options === 'string') {
      options = { id: options };
    }
    return _possibleConstructorReturn(this, Object.getPrototypeOf(Content).call(this, options));
  }

  /**
   * Loads the data from google's cloud storage.
   *
   * Data is provided via callback.
   *
   * Note that typically one should use layer.MessagePart.fetchContent() rather than layer.Content.loadContent()
   *
   * @method loadContent
   * @param {string} mimeType - Mime type for the Blob
   * @param {Function} callback
   * @param {Blob} callback.data - A Blob instance representing the data downloaded.  If Blob object is not available, then may use other format.
   */


  _createClass(Content, [{
    key: 'loadContent',
    value: function loadContent(mimeType, callback) {
      xhr({
        url: this.downloadUrl,
        responseType: 'arraybuffer'
      }, function (result) {
        if (result.success) {
          if (typeof Blob !== 'undefined') {
            var blob = new Blob([result.data], { type: mimeType });
            callback(null, blob);
          } else {
            // If the blob class isn't defined (nodejs) then just return the result as is
            callback(null, result.data);
          }
        } else {
          callback(result.data, null);
        }
      });
    }

    /**
     * Refreshes the URL, which updates the URL and resets the expiration time for the URL
     *
     * @method refreshContent
     * @param {layer.Client} client
     * @param {Function} [callback]
     */

  }, {
    key: 'refreshContent',
    value: function refreshContent(client, callback) {
      var _this2 = this;

      client.xhr({
        url: this.refreshUrl,
        method: 'GET',
        sync: false
      }, function (result) {
        var data = result.data;

        _this2.expiration = new Date(data.expiration);
        _this2.downloadUrl = data.download_url;
        if (callback) callback(_this2.downloadUrl);
      });
    }

    /**
     * Is the download url expired or about to expire?
     * We can't be sure of the state of the device's internal clock,
     * so if its within 10 minutes of expiring, just treat it as expired.
     *
     * @method isExpired
     * @returns {Boolean}
     */

  }, {
    key: 'isExpired',
    value: function isExpired() {
      var expirationLeeway = 10 * 60 * 1000;
      return this.expiration.getTime() - expirationLeeway < Date.now();
    }

    /**
     * Creates a MessagePart from a server representation of the part
     *
     * @method _createFromServer
     * @private
     * @static
     * @param  {Object} part - Server representation of a part
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(part) {
      return new Content({
        id: part.id,
        downloadUrl: part.download_url,
        expiration: new Date(part.expiration),
        refreshUrl: part.refresh_url
      });
    }
  }]);

  return Content;
}(Root);

/**
 * Server generated identifier
 * @type {string}
 */


Content.prototype.id = '';

Content.prototype.blob = null;

/**
 * Server generated url for downloading the content
 * @type {string}
 */
Content.prototype.downloadUrl = '';

/**
 * Url for refreshing the downloadUrl after it has expired
 * @type {string}
 */
Content.prototype.refreshUrl = '';

/**
 * Size of the content.
 *
 * This property only has a value when in the process
 * of Creating the rich content and sending the Message.
 *
 * @type {number}
 */
Content.prototype.size = 0;

/**
 * Expiration date for the downloadUrl
 * @type {Date}
 */
Content.prototype.expiration = null;

Root.initClass.apply(Content, [Content, 'Content']);
module.exports = Content;


},{"../root":116,"../xhr":126}],100:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A layer.Message instance for use within layer.Conversation.
 *
 * @class layer.Message.ConversationMessage
 * @extends layer.Message
 */
var Root = require('../root');
var Message = require('./message');
var ClientRegistry = require('../client-registry');
var LayerError = require('../layer-error');
var Constants = require('../const');
var Util = require('../client-utils');

var ConversationMessage = function (_Message) {
  _inherits(ConversationMessage, _Message);

  function ConversationMessage(options) {
    _classCallCheck(this, ConversationMessage);

    if (options.conversation) options.conversationId = options.conversation.id;

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ConversationMessage).call(this, options));

    _this._disableEvents = true;
    if (!options.fromServer) _this.recipientStatus = {};else _this.__updateRecipientStatus(_this.recipientStatus);
    _this._disableEvents = false;

    var client = _this.getClient();
    _this.isInitializing = false;
    if (options && options.fromServer) {
      client._addMessage(_this);
      var status = _this.recipientStatus[client.user.id];
      if (status && status !== Constants.RECEIPT_STATE.READ && status !== Constants.RECEIPT_STATE.DELIVERED) {
        Util.defer(function () {
          return _this._sendReceipt('delivery');
        });
      }
    }
    return _this;
  }

  /**
   * Get the layer.Conversation associated with this layer.Message.ConversationMessage.
   *
   * @method getConversation
   * @param {Boolean} load       Pass in true if the layer.Conversation should be loaded if not found locally
   * @return {layer.Conversation}
   */


  _createClass(ConversationMessage, [{
    key: 'getConversation',
    value: function getConversation(load) {
      if (this.conversationId) {
        return ClientRegistry.get(this.clientId).getConversation(this.conversationId, load);
      }
      return null;
    }

    /**
     * On loading this one item from the server, after _populateFromServer has been called, due final setup.
     *
     * @method _loaded
     * @private
     * @param {Object} data  Data from server
     */

  }, {
    key: '_loaded',
    value: function _loaded(data) {
      this.conversationId = data.conversation.id;
      this.getClient()._addMessage(this);
    }

    /**
     * Accessor called whenever the app accesses `message.recipientStatus`.
     *
     * Insures that participants who haven't yet been sent the Message are marked as layer.Constants.RECEIPT_STATE.PENDING
     *
     * @method __getRecipientStatus
     * @param {string} pKey - The actual property key where the value is stored
     * @private
     * @return {Object}
     */

  }, {
    key: '__getRecipientStatus',
    value: function __getRecipientStatus(pKey) {
      var _this2 = this;

      var value = this[pKey] || {};
      var client = this.getClient();
      if (client) {
        (function () {
          var id = client.user.id;
          var conversation = _this2.getConversation(false);
          if (conversation) {
            conversation.participants.forEach(function (participant) {
              if (!value[participant.id]) {
                value[participant.id] = participant.id === id ? Constants.RECEIPT_STATE.READ : Constants.RECEIPT_STATE.PENDING;
              }
            });
          }
        })();
      }
      return value;
    }

    /**
     * Handle changes to the recipientStatus property.
     *
     * Any time the recipientStatus property is set,
     * Recalculate all of the receipt related properties:
     *
     * 1. isRead
     * 2. readStatus
     * 3. deliveryStatus
     *
     * @method __updateRecipientStatus
     * @private
     * @param  {Object} status - Object describing the delivered/read/sent value for each participant
     *
     */

  }, {
    key: '__updateRecipientStatus',
    value: function __updateRecipientStatus(status, oldStatus) {
      var conversation = this.getConversation(false);
      var client = this.getClient();

      if (!conversation || Util.doesObjectMatch(status, oldStatus)) return;

      var id = client.user.id;
      var isSender = this.sender.sessionOwner;
      var userHasRead = status[id] === Constants.RECEIPT_STATE.READ;

      try {
        // -1 so we don't count this user
        var userCount = conversation.participants.length - 1;

        // If sent by this user or read by this user, update isRead/unread
        if (!this.__isRead && (isSender || userHasRead)) {
          this.__isRead = true; // no __updateIsRead event fired
        }

        // Update the readStatus/deliveryStatus properties

        var _getReceiptStatus2 = this._getReceiptStatus(status, id);

        var readCount = _getReceiptStatus2.readCount;
        var deliveredCount = _getReceiptStatus2.deliveredCount;

        this._setReceiptStatus(readCount, deliveredCount, userCount);
      } catch (error) {}
      // Do nothing


      // Only trigger an event
      // 1. we're not initializing a new Message
      // 2. the user's state has been updated to read; we don't care about updates from other users if we aren't the sender.
      //    We also don't care about state changes to delivered; these do not inform rendering as the fact we are processing it
      //    proves its delivered.
      // 3. The user is the sender; in that case we do care about rendering receipts from other users
      if (!this.isInitializing && oldStatus) {
        var usersStateUpdatedToRead = userHasRead && oldStatus[id] !== Constants.RECEIPT_STATE.READ;
        if (usersStateUpdatedToRead || isSender) {
          this._triggerAsync('messages:change', {
            oldValue: oldStatus,
            newValue: status,
            property: 'recipientStatus'
          });
        }
      }
    }

    /**
     * Get the number of participants who have read and been delivered
     * this Message
     *
     * @method _getReceiptStatus
     * @private
     * @param  {Object} status - Object describing the delivered/read/sent value for each participant
     * @param  {string} id - Identity ID for this user; not counted when reporting on how many people have read/received.
     * @return {Object} result
     * @return {number} result.readCount
     * @return {number} result.deliveredCount
     */

  }, {
    key: '_getReceiptStatus',
    value: function _getReceiptStatus(status, id) {
      var readCount = 0,
          deliveredCount = 0;
      Object.keys(status).filter(function (participant) {
        return participant !== id;
      }).forEach(function (participant) {
        if (status[participant] === Constants.RECEIPT_STATE.READ) {
          readCount++;
          deliveredCount++;
        } else if (status[participant] === Constants.RECEIPT_STATE.DELIVERED) {
          deliveredCount++;
        }
      });

      return {
        readCount: readCount,
        deliveredCount: deliveredCount
      };
    }

    /**
     * Sets the layer.Message.ConversationMessage.readStatus and layer.Message.ConversationMessage.deliveryStatus properties.
     *
     * @method _setReceiptStatus
     * @private
     * @param  {number} readCount
     * @param  {number} deliveredCount
     * @param  {number} userCount
     */

  }, {
    key: '_setReceiptStatus',
    value: function _setReceiptStatus(readCount, deliveredCount, userCount) {
      if (readCount === userCount) {
        this.readStatus = Constants.RECIPIENT_STATE.ALL;
      } else if (readCount > 0) {
        this.readStatus = Constants.RECIPIENT_STATE.SOME;
      } else {
        this.readStatus = Constants.RECIPIENT_STATE.NONE;
      }
      if (deliveredCount === userCount) {
        this.deliveryStatus = Constants.RECIPIENT_STATE.ALL;
      } else if (deliveredCount > 0) {
        this.deliveryStatus = Constants.RECIPIENT_STATE.SOME;
      } else {
        this.deliveryStatus = Constants.RECIPIENT_STATE.NONE;
      }
    }

    /**
     * Handle changes to the isRead property.
     *
     * If someone called m.isRead = true, AND
     * if it was previously false, AND
     * if the call didn't come from layer.Message.ConversationMessage.__updateRecipientStatus,
     * Then notify the server that the message has been read.
     *
     *
     * @method __updateIsRead
     * @private
     * @param  {boolean} value - True if isRead is true.
     */

  }, {
    key: '__updateIsRead',
    value: function __updateIsRead(value) {
      if (value) {
        if (!this._inPopulateFromServer) {
          this._sendReceipt(Constants.RECEIPT_STATE.READ);
        }
        this._triggerMessageRead();
        var conversation = this.getConversation(false);
        if (conversation) conversation.unreadCount--;
      }
    }

    /**
     * Trigger events indicating changes to the isRead/isUnread properties.
     *
     * @method _triggerMessageRead
     * @private
     */

  }, {
    key: '_triggerMessageRead',
    value: function _triggerMessageRead() {
      var value = this.isRead;
      this._triggerAsync('messages:change', {
        property: 'isRead',
        oldValue: !value,
        newValue: value
      });
      this._triggerAsync('messages:change', {
        property: 'isUnread',
        oldValue: value,
        newValue: !value
      });
    }

    /**
     * Send a Read or Delivery Receipt to the server.
     *
     * For Read Receipt, you can also just write:
     *
     * ```
     * message.isRead = true;
     * ```
     *
     * You can retract a Delivery or Read Receipt; once marked as Delivered or Read, it can't go back.
     *
     * ```
     * messsage.sendReceipt(layer.Constants.RECEIPT_STATE.READ);
     * ```
     *
     * @method sendReceipt
     * @param {string} [type=layer.Constants.RECEIPT_STATE.READ] - One of layer.Constants.RECEIPT_STATE.READ or layer.Constants.RECEIPT_STATE.DELIVERY
     * @return {layer.Message.ConversationMessage} this
     */

  }, {
    key: 'sendReceipt',
    value: function sendReceipt() {
      var type = arguments.length <= 0 || arguments[0] === undefined ? Constants.RECEIPT_STATE.READ : arguments[0];

      if (type === Constants.RECEIPT_STATE.READ) {
        if (this.isRead) {
          return this;
        } else {
          // Without triggering the event, clearObject isn't called,
          // which means those using the toObject() data will have an isRead that doesn't match
          // this instance.  Which typically leads to lots of extra attempts
          // to mark the message as read.
          this.__isRead = true;
          this._triggerMessageRead();
          var conversation = this.getConversation(false);
          if (conversation) conversation.unreadCount--;
        }
      }
      this._sendReceipt(type);
      return this;
    }

    /**
     * Send a Read or Delivery Receipt to the server.
     *
     * This bypasses any validation and goes direct to sending to the server.
     *
     * NOTE: Server errors are not handled; the local receipt state is suitable even
     * if out of sync with the server.
     *
     * @method _sendReceipt
     * @private
     * @param {string} [type=read] - One of layer.Constants.RECEIPT_STATE.READ or layer.Constants.RECEIPT_STATE.DELIVERY
     */

  }, {
    key: '_sendReceipt',
    value: function _sendReceipt(type) {
      var _this3 = this;

      // This little test exists so that we don't send receipts on Conversations we are no longer
      // participants in (participants = [] if we are not a participant)
      var conversation = this.getConversation(false);
      if (conversation && conversation.participants.length === 0) return;

      this._setSyncing();
      this._xhr({
        url: '/receipts',
        method: 'POST',
        data: {
          type: type
        },
        sync: {
          // This should not be treated as a POST/CREATE request on the Message
          operation: 'RECEIPT'
        }
      }, function () {
        return _this3._setSynced();
      });
    }

    /**
     * Delete the Message from the server.
     *
     * This call will support various deletion modes.  Calling without a deletion mode is deprecated.
     *
     * Deletion Modes:
     *
     * * layer.Constants.DELETION_MODE.ALL: This deletes the local copy immediately, and attempts to also
     *   delete the server's copy.
     * * layer.Constants.DELETION_MODE.MY_DEVICES: Deletes this Message from all of my devices; no effect on other users.
     *
     * @method delete
     * @param {String} deletionMode
     */
    // Abstract Method

  }, {
    key: 'delete',
    value: function _delete(mode) {
      if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);
      var queryStr = void 0;
      switch (mode) {
        case Constants.DELETION_MODE.ALL:
        case true:
          queryStr = 'mode=all_participants';
          break;
        case Constants.DELETION_MODE.MY_DEVICES:
          queryStr = 'mode=my_devices';
          break;
        default:
          throw new Error(LayerError.dictionary.deletionModeUnsupported);
      }

      var id = this.id;
      var client = this.getClient();
      this._xhr({
        url: '?' + queryStr,
        method: 'DELETE'
      }, function (result) {
        if (!result.success && (!result.data || result.data.id !== 'not_found')) Message.load(id, client);
      });

      this._deleted();
      this.destroy();
    }
  }, {
    key: 'toObject',
    value: function toObject() {
      if (!this._toObject) {
        this._toObject = _get(Object.getPrototypeOf(ConversationMessage.prototype), 'toObject', this).call(this);
        this._toObject.recipientStatus = Util.clone(this.recipientStatus);
      }
      return this._toObject;
    }

    /*
     * Creates a message from the server's representation of a message.
     *
     * Similar to _populateFromServer, however, this method takes a
     * message description and returns a new message instance using _populateFromServer
     * to setup the values.
     *
     * @method _createFromServer
     * @protected
     * @static
     * @param  {Object} message - Server's representation of the message
     * @param  {layer.Client} client
     * @return {layer.Message.ConversationMessage}
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(message, client) {
      var fromWebsocket = message.fromWebsocket;
      var conversationId = void 0;
      if (message.conversation) {
        conversationId = message.conversation.id;
      } else {
        conversationId = message.conversationId;
      }

      return new ConversationMessage({
        conversationId: conversationId,
        fromServer: message,
        clientId: client.appId,
        _fromDB: message._fromDB,
        _notify: fromWebsocket && message.is_unread && message.sender.user_id !== client.user.userId
      });
    }
  }]);

  return ConversationMessage;
}(Message);

/**
 * True if this Message has been read by this user.
 *
 * You can change isRead programatically
 *
 *      m.isRead = true;
 *
 * This will automatically notify the server that the message was read by your user.
 * @type {Boolean}
 */


ConversationMessage.prototype.isRead = false;

/**
 * Read/delivery State of all participants.
 *
 * This is an object containing keys for each participant,
 * and a value of:
 *
 * * layer.RECEIPT_STATE.SENT
 * * layer.RECEIPT_STATE.DELIVERED
 * * layer.RECEIPT_STATE.READ
 * * layer.RECEIPT_STATE.PENDING
 *
 * @type {Object}
 */
ConversationMessage.prototype.recipientStatus = null;

/**
 * Have the other participants read this Message yet.
 *
 * This value is one of:
 *
 *  * layer.Constants.RECIPIENT_STATE.ALL
 *  * layer.Constants.RECIPIENT_STATE.SOME
 *  * layer.Constants.RECIPIENT_STATE.NONE
 *
 *  This value is updated any time recipientStatus changes.
 *
 * See layer.Message.ConversationMessage.recipientStatus for a more detailed report.
 *
 * @type {String}
 */
ConversationMessage.prototype.readStatus = Constants.RECIPIENT_STATE.NONE;

/**
 * Have the other participants received this Message yet.
 *
  * This value is one of:
 *
 *  * layer.Constants.RECIPIENT_STATE.ALL
 *  * layer.Constants.RECIPIENT_STATE.SOME
 *  * layer.Constants.RECIPIENT_STATE.NONE
 *
 *  This value is updated any time recipientStatus changes.
 *
 * See layer.Message.ConversationMessage.recipientStatus for a more detailed report.
 *
 *
 * @type {String}
 */
ConversationMessage.prototype.deliveryStatus = Constants.RECIPIENT_STATE.NONE;

ConversationMessage.inObjectIgnore = Message.inObjectIgnore;
ConversationMessage._supportedEvents = [].concat(Message._supportedEvents);
Root.initClass.apply(ConversationMessage, [ConversationMessage, 'ConversationMessage']);
module.exports = ConversationMessage;


},{"../client-registry":81,"../client-utils":82,"../const":84,"../layer-error":86,"../root":116,"./message":105}],101:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A Conversation object represents a dialog amongst a small set
 * of participants.
 *
 * Create a Conversation using the client:
 *
 *      var conversation = client.createConversation({
 *          participants: ['a','b'],
 *          distinct: true
 *      });
 *
 * NOTE:   Do not create a conversation with new layer.Conversation(...),
 *         This will fail to handle the distinct property short of going to the server for evaluation.
 *
 * NOTE:   Creating a Conversation is a local action.  A Conversation will not be
 *         sent to the server until either:
 *
 * 1. A message is sent on that Conversation
 * 2. `Conversation.send()` is called (not recommended as mobile clients
 *    expect at least one layer.Message.ConversationMessage in a Conversation)
 *
 * Key methods, events and properties for getting started:
 *
 * Properties:
 *
 * * layer.Conversation.id: this property is worth being familiar with; it identifies the
 *   Conversation and can be used in `client.getConversation(id)` to retrieve it.
 * * layer.Conversation.lastMessage: This property makes it easy to show info about the most recent Message
 *    when rendering a list of Conversations.
 * * layer.Conversation.metadata: Custom data for your Conversation; commonly used to store a 'title' property
 *    to name your Conversation.
 *
 * Methods:
 *
 * * layer.Conversation.addParticipants and layer.Conversation.removeParticipants: Change the participants of the Conversation
 * * layer.Conversation.setMetadataProperties: Set metadata.title to 'My Conversation with Layer Support' (uh oh)
 * * layer.Conversation.on() and layer.Conversation.off(): event listeners built on top of the `backbone-events-standalone` npm project
 * * layer.Conversation.leave() to leave the Conversation
 * * layer.Conversation.delete() to delete the Conversation for all users (or for just this user)
 *
 * Events:
 *
 * * `conversations:change`: Useful for observing changes to participants and metadata
 *   and updating rendering of your open Conversation
 *
 * Finally, to access a list of Messages in a Conversation, see layer.Query.
 *
 * @class  layer.Conversation
 * @extends layer.Container
 * @author  Michael Kantor
 */

var Root = require('../root');
var Syncable = require('./syncable');
var Container = require('./container');
var ConversationMessage = require('./conversation-message');
var LayerError = require('../layer-error');
var Util = require('../client-utils');
var Constants = require('../const');
var LayerEvent = require('../layer-event');

var Conversation = function (_Container) {
  _inherits(Conversation, _Container);

  /**
   * Create a new conversation.
   *
   * The static `layer.Conversation.create()` method
   * will correctly lookup distinct Conversations and
   * return them; `new layer.Conversation()` will not.
   *
   * Developers should use `layer.Conversation.create()`.
   *
   * @method constructor
   * @protected
   * @param  {Object} options
   * @param {string[]/layer.Identity[]} options.participants - Array of Participant IDs or layer.Identity instances
   * @param {boolean} [options.distinct=true] - Is the conversation distinct
   * @param {Object} [options.metadata] - An object containing Conversation Metadata.
   * @return {layer.Conversation}
   */
  function Conversation() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Conversation);

    // Setup default values
    if (!options.participants) options.participants = [];

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Conversation).call(this, options));

    _this.isInitializing = true;
    var client = _this.getClient();

    // If the options doesn't contain server object, setup participants.
    if (!options || !options.fromServer) {
      _this.participants = client._fixIdentities(_this.participants);
      if (_this.participants.indexOf(client.user) === -1) {
        _this.participants.push(client.user);
      }
    }
    _this._register();
    _this.isInitializing = false;
    return _this;
  }

  /**
   * Destroy the local copy of this Conversation, cleaning up all resources
   * it consumes.
   *
   * @method destroy
   */


  _createClass(Conversation, [{
    key: 'destroy',
    value: function destroy() {
      this.lastMessage = null;

      // Client fires 'conversations:remove' and then removes the Conversation.
      if (this.clientId) this.getClient()._removeConversation(this);

      _get(Object.getPrototypeOf(Conversation.prototype), 'destroy', this).call(this);

      this.participants = null;
      this.metadata = null;
    }

    /**
     * Create a new layer.Message.ConversationMessage instance within this conversation
     *
     *      var message = conversation.createMessage('hello');
     *
     *      var message = conversation.createMessage({
     *          parts: [new layer.MessagePart({
     *                      body: 'hello',
     *                      mimeType: 'text/plain'
     *                  })]
     *      });
     *
     * See layer.Message.ConversationMessage for more options for creating the message.
     *
     * @method createMessage
     * @param  {String|Object} options - If its a string, a MessagePart is created around that string.
     * @param {layer.MessagePart[]} options.parts - An array of MessageParts.  There is some tolerance for
     *                                               it not being an array, or for it being a string to be turned
     *                                               into a MessagePart.
     * @return {layer.Message.ConversationMessage}
     */

  }, {
    key: 'createMessage',
    value: function createMessage() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var messageConfig = typeof options === 'string' ? {
        parts: [{ body: options, mimeType: 'text/plain' }]
      } : options;
      messageConfig.clientId = this.clientId;
      messageConfig.conversationId = this.id;

      return new ConversationMessage(messageConfig);
    }
  }, {
    key: '_setupMessage',
    value: function _setupMessage(message) {
      // Setting a position is required if its going to get sorted correctly by query.
      // The correct position will be written by _populateFromServer when the object
      // is returned from the server.  We increment the position by the time since the prior lastMessage was sent
      // so that if multiple tabs are sending messages and writing them to indexedDB, they will have positions in correct chronological order.
      // WARNING: The query will NOT be resorted using the server's position value.
      var position = void 0;
      if (this.lastMessage) {
        position = this.lastMessage.position + Date.now() - this.lastMessage.sentAt.getTime();
        if (position === this.lastMessage.position) position++;
      } else {
        position = 0;
      }
      message.position = position;
      this.lastMessage = message;
    }

    /**
     * Create this Conversation on the server.
     *
     * On completion, this instance will receive
     * an id, url and createdAt.  It may also receive metadata
     * if there was a FOUND_WITHOUT_REQUESTED_METADATA result.
     *
     * Note that the optional Message parameter should NOT be used except
     * by the layer.Message.ConversationMessage class itself.
     *
     * Note that recommended practice is to send the Conversation by sending a Message in the Conversation,
     * and NOT by calling Conversation.send.
     *
     *      client.createConversation({
     *          participants: ['a', 'b'],
     *          distinct: false
     *      })
     *      .send()
     *      .on('conversations:sent', function(evt) {
     *          alert('Done');
     *      });
     *
     * @method send
     * @param {layer.Message.ConversationMessage} [message] Tells the Conversation what its last_message will be
     * @return {layer.Conversation} this
     */

  }, {
    key: 'send',
    value: function send(message) {
      var client = this.getClient();
      if (!client) throw new Error(LayerError.dictionary.clientMissing);

      // If this is part of a create({distinct:true}).send() call where
      // the distinct conversation was found, just trigger the cached event and exit
      var wasLocalDistinct = Boolean(this._sendDistinctEvent);
      if (this._sendDistinctEvent) this._handleLocalDistinctConversation();

      // If the Conversation is already on the server, don't send.
      if (wasLocalDistinct || this.syncState !== Constants.SYNC_STATE.NEW) {
        if (message) this._setupMessage(message);
        return this;
      }

      // Make sure this user is a participant (server does this for us, but
      // this insures the local copy is correct until we get a response from
      // the server
      if (this.participants.indexOf(client.user) === -1) {
        this.participants.push(client.user);
      }

      return _get(Object.getPrototypeOf(Conversation.prototype), 'send', this).call(this, message);
    }

    /**
     * Handles the case where a Distinct Create Conversation found a local match.
     *
     * When an app calls client.createConversation([...])
     * and requests a Distinct Conversation (default setting),
     * and the Conversation already exists, what do we do to help
     * them access it?
     *
     *      client.createConversation(["fred"]).on("conversations:sent", function(evt) {
     *        render();
     *      });
     *
     * Under normal conditions, calling `c.send()` on a matching distinct Conversation
     * would either throw an error or just be a no-op.  We use this method to trigger
     * the expected "conversations:sent" event even though its already been sent and
     * we did nothing.  Use the evt.result property if you want to know whether the
     * result was a new conversation or matching one.
     *
     * @method _handleLocalDistinctConversation
     * @private
     */

  }, {
    key: '_handleLocalDistinctConversation',
    value: function _handleLocalDistinctConversation() {
      var evt = this._sendDistinctEvent;
      this._sendDistinctEvent = null;

      // delay so there is time to setup an event listener on this conversation
      this._triggerAsync('conversations:sent', evt);
      return this;
    }

    /**
     * Gets the data for a Create request.
     *
     * The layer.SyncManager needs a callback to create the Conversation as it
     * looks NOW, not back when `send()` was called.  This method is called
     * by the layer.SyncManager to populate the POST data of the call.
     *
     * @method _getSendData
     * @private
     * @return {Object} Websocket data for the request
     */

  }, {
    key: '_getSendData',
    value: function _getSendData(data) {
      var isMetadataEmpty = Util.isEmpty(this.metadata);
      return {
        method: 'Conversation.create',
        data: {
          participants: this.participants.map(function (identity) {
            return identity.id;
          }),
          distinct: this.distinct,
          metadata: isMetadataEmpty ? null : this.metadata,
          id: this.id
        }
      };
    }
  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(conversation) {
      var client = this.getClient();

      // Disable events if creating a new Conversation
      // We still want property change events for anything that DOES change
      this._disableEvents = this.syncState === Constants.SYNC_STATE.NEW;

      this.participants = client._fixIdentities(conversation.participants);
      this.distinct = conversation.distinct;
      this.unreadCount = conversation.unread_message_count;
      this.isCurrentParticipant = this.participants.indexOf(client.user) !== -1;
      _get(Object.getPrototypeOf(Conversation.prototype), '_populateFromServer', this).call(this, conversation);

      if (typeof conversation.last_message === 'string') {
        this.lastMessage = client.getMessage(conversation.last_message);
      } else if (conversation.last_message) {
        this.lastMessage = client._createObject(conversation.last_message);
      }
      this._register();

      this._disableEvents = false;
    }
  }, {
    key: '_createResultConflict',
    value: function _createResultConflict(data) {
      this._populateFromServer(data.data);
      this._triggerAsync(this.constructor.eventPrefix + ':sent', {
        result: Conversation.FOUND_WITHOUT_REQUESTED_METADATA
      });
    }

    /**
     * Add an array of participant ids to the conversation.
     *
     *      conversation.addParticipants(['a', 'b']);
     *
     * New participants will immediately show up in the Conversation,
     * but may not have synced with the server yet.
     *
     * TODO WEB-967: Roll participants back on getting a server error
     *
     * @method addParticipants
     * @param  {string[]/layer.Identity[]} participants - Array of Participant IDs or Identity objects
     * @returns {layer.Conversation} this
     */

  }, {
    key: 'addParticipants',
    value: function addParticipants(participants) {
      var _this2 = this;

      // Only add those that aren't already in the list.
      var client = this.getClient();
      var identities = client._fixIdentities(participants);
      var adding = identities.filter(function (identity) {
        return _this2.participants.indexOf(identity) === -1;
      });
      this._patchParticipants({ add: adding, remove: [] });
      return this;
    }

    /**
     * Removes an array of participant ids from the conversation.
     *
     *      conversation.removeParticipants(['a', 'b']);
     *
     * Removed participants will immediately be removed from this Conversation,
     * but may not have synced with the server yet.
     *
     * Throws error if you attempt to remove ALL participants.
     *
     * TODO  WEB-967: Roll participants back on getting a server error
     *
     * @method removeParticipants
     * @param  {string[]/layer.Identity[]} participants - Array of Participant IDs or Identity objects
     * @returns {layer.Conversation} this
     */

  }, {
    key: 'removeParticipants',
    value: function removeParticipants(participants) {
      var currentParticipants = {};
      this.participants.forEach(function (participant) {
        return currentParticipants[participant.id] = true;
      });
      var client = this.getClient();
      var identities = client._fixIdentities(participants);

      var removing = identities.filter(function (participant) {
        return currentParticipants[participant.id];
      });
      if (removing.length === 0) return this;
      if (removing.length === this.participants.length) {
        throw new Error(LayerError.dictionary.moreParticipantsRequired);
      }
      this._patchParticipants({ add: [], remove: removing });
      return this;
    }

    /**
     * Replaces all participants with a new array of of participant ids.
     *
     *      conversation.replaceParticipants(['a', 'b']);
     *
     * Changed participants will immediately show up in the Conversation,
     * but may not have synced with the server yet.
     *
     * TODO WEB-967: Roll participants back on getting a server error
     *
     * @method replaceParticipants
     * @param  {string[]/layer.Identity[]} participants - Array of Participant IDs or Identity objects
     * @returns {layer.Conversation} this
     */

  }, {
    key: 'replaceParticipants',
    value: function replaceParticipants(participants) {
      if (!participants || !participants.length) {
        throw new Error(LayerError.dictionary.moreParticipantsRequired);
      }

      var client = this.getClient();
      var identities = client._fixIdentities(participants);

      var change = this._getParticipantChange(identities, this.participants);
      this._patchParticipants(change);
      return this;
    }

    /**
     * Update the server with the new participant list.
     *
     * Executes as follows:
     *
     * 1. Updates the participants property of the local object
     * 2. Triggers a conversations:change event
     * 3. Submits a request to be sent to the server to update the server's object
     * 4. If there is an error, no errors are fired except by layer.SyncManager, but another
     *    conversations:change event is fired as the change is rolled back.
     *
     * @method _patchParticipants
     * @private
     * @param  {Object[]} operations - Array of JSON patch operation
     * @param  {Object} eventData - Data describing the change for use in an event
     */

  }, {
    key: '_patchParticipants',
    value: function _patchParticipants(change) {
      var _this3 = this;

      this._applyParticipantChange(change);
      this.isCurrentParticipant = this.participants.indexOf(this.getClient().user) !== -1;

      var ops = [];
      change.remove.forEach(function (participant) {
        ops.push({
          operation: 'remove',
          property: 'participants',
          id: participant.id
        });
      });

      change.add.forEach(function (participant) {
        ops.push({
          operation: 'add',
          property: 'participants',
          id: participant.id
        });
      });

      this._xhr({
        url: '',
        method: 'PATCH',
        data: JSON.stringify(ops),
        headers: {
          'content-type': 'application/vnd.layer-patch+json'
        }
      }, function (result) {
        if (!result.success) _this3._load();
      });
    }

    /**
     * Internally we use `{add: [], remove: []}` instead of LayerOperations.
     *
     * So control is handed off to this method to actually apply the changes
     * to the participants array.
     *
     * @method _applyParticipantChange
     * @private
     * @param  {Object} change
     * @param  {layer.Identity[]} change.add - Array of userids to add
     * @param  {layer.Identity[]} change.remove - Array of userids to remove
     */

  }, {
    key: '_applyParticipantChange',
    value: function _applyParticipantChange(change) {
      var participants = [].concat(this.participants);
      change.add.forEach(function (participant) {
        if (participants.indexOf(participant) === -1) participants.push(participant);
      });
      change.remove.forEach(function (participant) {
        var index = participants.indexOf(participant);
        if (index !== -1) participants.splice(index, 1);
      });
      this.participants = participants;
    }

    /**
     * Delete the Conversation from the server and removes this user as a participant.
     *
     * @method leave
     */

  }, {
    key: 'leave',
    value: function leave() {
      if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);
      this._delete('mode=' + Constants.DELETION_MODE.MY_DEVICES + '&leave=true');
    }

    /**
     * Delete the Conversation from the server, but deletion mode may cause user to remain a participant.
     *
     * This call will support various deletion modes.
     *
     * Deletion Modes:
     *
     * * layer.Constants.DELETION_MODE.ALL: This deletes the local copy immediately, and attempts to also
     *   delete the server's copy.
     * * layer.Constants.DELETION_MODE.MY_DEVICES: Deletes the local copy immediately, and attempts to delete it from all
     *   of my devices.  Other users retain access.
     * * true: For backwards compatibility thi is the same as ALL.
     *
     * MY_DEVICES does not remove this user as a participant.  That means a new Message on this Conversation will recreate the
     * Conversation for this user.  See layer.Conversation.leave() instead.
     *
     * Executes as follows:
     *
     * 1. Submits a request to be sent to the server to delete the server's object
     * 2. Delete's the local object
     * 3. If there is an error, no errors are fired except by layer.SyncManager, but the Conversation will be reloaded from the server,
     *    triggering a conversations:add event.
     *
     * @method delete
     * @param {String} deletionMode
     */

  }, {
    key: 'delete',
    value: function _delete(mode) {
      if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);

      var queryStr = void 0;
      switch (mode) {
        case Constants.DELETION_MODE.ALL:
        case true:
          queryStr = 'mode=' + Constants.DELETION_MODE.ALL;
          break;
        case Constants.DELETION_MODE.MY_DEVICES:
          queryStr = 'mode=' + Constants.DELETION_MODE.MY_DEVICES + '&leave=false';
          break;
        default:
          throw new Error(LayerError.dictionary.deletionModeUnsupported);
      }

      this._delete(queryStr);
    }

    /**
     * LayerPatch will call this after changing any properties.
     *
     * Trigger any cleanup or events needed after these changes.
     *
     * @method _handlePatchEvent
     * @private
     * @param  {Mixed} newValue - New value of the property
     * @param  {Mixed} oldValue - Prior value of the property
     * @param  {string[]} paths - Array of paths specifically modified: ['participants'], ['metadata.keyA', 'metadata.keyB']
     */

  }, {
    key: '_handlePatchEvent',
    value: function _handlePatchEvent(newValue, oldValue, paths) {
      var _this4 = this;

      // Certain types of __update handlers are disabled while values are being set by
      // layer patch parser because the difference between setting a value (triggers an event)
      // and change a property of a value (triggers only this callback) result in inconsistent
      // behaviors.  Enable them long enough to allow __update calls to be made
      this._inLayerParser = false;
      try {
        var events = this._disableEvents;
        this._disableEvents = false;
        if (paths[0] === 'participants') {
          (function () {
            var client = _this4.getClient();
            // oldValue/newValue come as a Basic Identity POJO; lets deliver events with actual instances
            oldValue = oldValue.map(function (identity) {
              return client.getIdentity(identity.id);
            });
            newValue = newValue.map(function (identity) {
              return client.getIdentity(identity.id);
            });
            _this4.__updateParticipants(newValue, oldValue);
          })();
        } else {
          _get(Object.getPrototypeOf(Conversation.prototype), '_handlePatchEvent', this).call(this, newValue, oldValue, paths);
        }
        this._disableEvents = events;
      } catch (err) {
        // do nothing
      }
      this._inLayerParser = true;
    }

    /**
     * Given the oldValue and newValue for participants,
     * generate a list of whom was added and whom was removed.
     *
     * @method _getParticipantChange
     * @private
     * @param  {layer.Identity[]} newValue
     * @param  {layer.Identity[]} oldValue
     * @return {Object} Returns changes in the form of `{add: [...], remove: [...]}`
     */

  }, {
    key: '_getParticipantChange',
    value: function _getParticipantChange(newValue, oldValue) {
      var change = {};
      change.add = newValue.filter(function (participant) {
        return oldValue.indexOf(participant) === -1;
      });
      change.remove = oldValue.filter(function (participant) {
        return newValue.indexOf(participant) === -1;
      });
      return change;
    }
  }, {
    key: '_deleteResult',
    value: function _deleteResult(result, id) {
      var client = this.getClient();
      if (!result.success && (!result.data || result.data.id !== 'not_found')) Conversation.load(id, client);
    }
  }, {
    key: '_register',
    value: function _register() {
      var client = this.getClient();
      if (client) client._addConversation(this);
    }

    /*
     * Insure that conversation.unreadCount-- can never reduce the value to negative values.
     */

  }, {
    key: '__adjustUnreadCount',
    value: function __adjustUnreadCount(newValue) {
      if (newValue < 0) return 0;
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any change in the unreadCount property will call this method and fire a
     * change event.
     *
     * Any triggering of this from a websocket patch unread_message_count should wait a second before firing any events
     * so that if there are a series of these updates, we don't see a lot of jitter.
     *
     * NOTE: _oldUnreadCount is used to pass data to _updateUnreadCountEvent because this method can be called many times
     * a second, and we only want to trigger this with a summary of changes rather than each individual change.
     *
     * @method __updateUnreadCount
     * @private
     * @param  {number} newValue
     * @param  {number} oldValue
     */

  }, {
    key: '__updateUnreadCount',
    value: function __updateUnreadCount(newValue, oldValue) {
      var _this5 = this;

      if (this._inLayerParser) {
        if (this._oldUnreadCount === undefined) this._oldUnreadCount = oldValue;
        if (this._updateUnreadCountTimeout) clearTimeout(this._updateUnreadCountTimeout);
        this._updateUnreadCountTimeout = setTimeout(function () {
          return _this5._updateUnreadCountEvent();
        }, 1000);
      } else {
        this._updateUnreadCountEvent();
      }
    }

    /**
     * Fire events related to changes to unreadCount
     *
     * @method _updateUnreadCountEvent
     * @private
     */

  }, {
    key: '_updateUnreadCountEvent',
    value: function _updateUnreadCountEvent() {
      if (this.isDestroyed) return;
      var oldValue = this._oldUnreadCount;
      var newValue = this.__unreadCount;
      this._oldUnreadCount = undefined;

      if (newValue === oldValue) return;
      this._triggerAsync('conversations:change', {
        newValue: newValue,
        oldValue: oldValue,
        property: 'unreadCount'
      });
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any change in the lastMessage pointer will call this method and fire a
     * change event.  Changes to properties within the lastMessage object will
     * not trigger this call.
     *
     * @method __updateLastMessage
     * @private
     * @param  {layer.Message.ConversationMessage} newValue
     * @param  {layer.Message.ConversationMessage} oldValue
     */

  }, {
    key: '__updateLastMessage',
    value: function __updateLastMessage(newValue, oldValue) {
      if (newValue && oldValue && newValue.id === oldValue.id) return;
      this._triggerAsync('conversations:change', {
        property: 'lastMessage',
        newValue: newValue,
        oldValue: oldValue
      });
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any change in the participants property will call this method and fire a
     * change event.  Changes to the participants array that don't replace the array
     * with a new array will require directly calling this method.
     *
     * @method __updateParticipants
     * @private
     * @param  {string[]} newValue
     * @param  {string[]} oldValue
     */

  }, {
    key: '__updateParticipants',
    value: function __updateParticipants(newValue, oldValue) {
      if (this._inLayerParser) return;
      var change = this._getParticipantChange(newValue, oldValue);
      if (change.add.length || change.remove.length) {
        change.property = 'participants';
        change.oldValue = oldValue;
        change.newValue = newValue;
        this._triggerAsync('conversations:change', change);
      }
    }

    /**
     * Create a conversation instance from a server representation of the conversation.
     *
     * If the Conversation already exists, will update the existing copy with
     * presumably newer values.
     *
     * @method _createFromServer
     * @protected
     * @static
     * @param  {Object} conversation - Server representation of a Conversation
     * @param  {layer.Client} client
     * @return {layer.Conversation}
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(conversation, client) {
      return new Conversation({
        client: client,
        fromServer: conversation,
        _fromDB: conversation._fromDB
      });
    }

    /**
     * Find or create a new conversation.
     *
     *      var conversation = layer.Conversation.create({
     *          participants: ['a', 'b'],
     *          distinct: true,
     *          metadata: {
     *              title: 'I am not a title!'
     *          },
     *          client: client,
     *          'conversations:loaded': function(evt) {
     *
     *          }
     *      });
     *
     * Only tries to find a Conversation if its a Distinct Conversation.
     * Distinct defaults to true.
     *
     * Recommend using `client.createConversation({...})`
     * instead of `Conversation.create({...})`.
     *
     * @method create
     * @static
     * @protected
     * @param  {Object} options
     * @param  {layer.Client} options.client
     * @param  {string[]/layer.Identity[]} options.participants - Array of Participant IDs or layer.Identity objects to create a conversation with.
     * @param {boolean} [options.distinct=true] - Create a distinct conversation
     * @param {Object} [options.metadata={}] - Initial metadata for Conversation
     * @return {layer.Conversation}
     */

  }, {
    key: 'create',
    value: function create(options) {
      if (!options.client) throw new Error(LayerError.dictionary.clientMissing);
      var newOptions = {
        distinct: options.distinct,
        participants: options.client._fixIdentities(options.participants),
        metadata: options.metadata,
        client: options.client
      };
      if (newOptions.distinct) {
        var conv = this._createDistinct(newOptions);
        if (conv) return conv;
      }
      return new Conversation(newOptions);
    }

    /**
     * Create or Find a Distinct Conversation.
     *
     * If the static Conversation.create method gets a request for a Distinct Conversation,
     * see if we have one cached.
     *
     * Will fire the 'conversations:loaded' event if one is provided in this call,
     * and a Conversation is found.
     *
     * @method _createDistinct
     * @static
     * @private
     * @param  {Object} options - See layer.Conversation.create options; participants must be layer.Identity[]
     * @return {layer.Conversation}
     */

  }, {
    key: '_createDistinct',
    value: function _createDistinct(options) {
      if (options.participants.indexOf(options.client.user) === -1) {
        options.participants.push(options.client.user);
      }

      var participantsHash = {};
      options.participants.forEach(function (participant) {
        participantsHash[participant.id] = participant;
      });

      var conv = options.client.findCachedConversation(function (aConv) {
        if (aConv.distinct && aConv.participants.length === options.participants.length) {
          for (var index = 0; index < aConv.participants.length; index++) {
            if (!participantsHash[aConv.participants[index].id]) return false;
          }
          return true;
        }
      });

      if (conv) {
        conv._sendDistinctEvent = new LayerEvent({
          target: conv,
          result: !options.metadata || Util.doesObjectMatch(options.metadata, conv.metadata) ? Conversation.FOUND : Conversation.FOUND_WITHOUT_REQUESTED_METADATA
        }, 'conversations:sent');
        return conv;
      }
    }
  }]);

  return Conversation;
}(Container);

/**
 * Array of participant ids.
 *
 * Do not directly manipulate;
 * use addParticipants, removeParticipants and replaceParticipants
 * to manipulate the array.
 *
 * @type {layer.Identity[]}
 */


Conversation.prototype.participants = null;

/**
 * Number of unread messages in the conversation.
 *
 * @type {number}
 */
Conversation.prototype.unreadCount = 0;

/**
 * This is a Distinct Conversation.
 *
 * You can have 1 distinct conversation among a set of participants.
 * There are no limits to how many non-distinct Conversations you have have
 * among a set of participants.
 *
 * @type {boolean}
 */
Conversation.prototype.distinct = true;

/**
 * The last layer.Message.ConversationMessage to be sent/received for this Conversation.
 *
 * Value may be a Message that has been locally created but not yet received by server.
 * @type {layer.Message.ConversationMessage}
 */
Conversation.prototype.lastMessage = null;

Conversation.eventPrefix = 'conversations';

/**
 * The Conversation that was requested has been found, but there was a mismatch in metadata.
 *
 * If the createConversation request contained metadata and it did not match the Distinct Conversation
 * that matched the requested participants, then this value is passed to notify your app that the Conversation
 * was returned but does not exactly match your request.
 *
 * Used in `conversations:sent` events.
 * @type {String}
 * @static
 */
Conversation.FOUND_WITHOUT_REQUESTED_METADATA = 'FoundMismatch';

/**
 * Prefix to use when generating an ID for instances of this class
 * @type {String}
 * @static
 * @private
 */
Conversation.prefixUUID = 'layer:///conversations/';

Conversation._supportedEvents = [
/**
 * The conversation is now on the server.
 *
 * Called after successfully creating the conversation
 * on the server.  The Result property is one of:
 *
 * * Conversation.CREATED: A new Conversation has been created
 * * Conversation.FOUND: A matching Distinct Conversation has been found
 * * Conversation.FOUND_WITHOUT_REQUESTED_METADATA: A matching Distinct Conversation has been found
 *                       but note that the metadata is NOT what you requested.
 *
 * All of these results will also mean that the updated property values have been
 * copied into your Conversation object.  That means your metadata property may no
 * longer be its initial value; it may be the value found on the server.
 *
 * @event
 * @param {layer.LayerEvent} event
 * @param {string} event.result
 */
'conversations:sent',

/**
 * An attempt to send this conversation to the server has failed.
 * @event
 * @param {layer.LayerEvent} event
 * @param {layer.LayerError} event.error
 */
'conversations:sent-error',

/**
 * The conversation is now loaded from the server.
 *
 * Note that this is only used in response to the layer.Conversation.load() method.
 * from the server.
 * @event
 * @param {layer.LayerEvent} event
 */
'conversations:loaded',

/**
 * An attempt to load this conversation from the server has failed.
 *
 * Note that this is only used in response to the layer.Conversation.load() method.
 * @event
 * @param {layer.LayerEvent} event
 * @param {layer.LayerError} event.error
 */
'conversations:loaded-error',

/**
 * The conversation has been deleted from the server.
 *
 * Caused by either a successful call to delete() on this instance
 * or by a remote user.
 * @event
 * @param {layer.LayerEvent} event
 */
'conversations:delete',

/**
 * This conversation has changed.
 *
 * @event
 * @param {layer.LayerEvent} event
 * @param {Object[]} event.changes - Array of changes reported by this event
 * @param {Mixed} event.changes.newValue
 * @param {Mixed} event.changes.oldValue
 * @param {string} event.changes.property - Name of the property that changed
 * @param {layer.Conversation} event.target
 */
'conversations:change'].concat(Syncable._supportedEvents);

Root.initClass.apply(Conversation, [Conversation, 'Conversation']);
Syncable.subclasses.push(Conversation);
module.exports = Conversation;


},{"../client-utils":82,"../const":84,"../layer-error":86,"../layer-event":87,"../root":116,"./container":98,"./conversation-message":100,"./syncable":106}],102:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Identity class represents an Identity of a user of your application.
 *
 * Identities are created by the System, never directly by apps.
 *
 * @class layer.Identity
 * @extends layer.Syncable
 */

/*
 * How Identities fit into the system:
 *
 * 1. As part of initialization, load the authenticated user's full Identity record so that the Client knows more than just the `userId` of its user.
 *    client.user = <Identity>
 * 2. Any time we get a Basic Identity via `message.sender` or Conversations, see if we have an Identity for that sender,
 *    and if not create one using the Basic Identity.  There should never be a duplicate Identity.
 * 3. Websocket CHANGE events will update Identity objects, as well as add new Full Identities, and downgrade Full Identities to Basic Identities.
 * 4. The Query API supports querying and paging through Identities
 * 5. The Query API loads Full Identities; these results will update the client._models.identities;
 *    upgrading Basic Identities if they match, and adding new Identities if they don't.
 * 6. DbManager will persist only UserIdentities, and only those that are Full Identities.  Basic Identities will be written
 *    to the Messages and Conversations tables anyways as part of those larger objects.
 * 7. API For explicit follows/unfollows
 */

var Syncable = require('./syncable');
var Root = require('../root');

var _require = require('../const');

var SYNC_STATE = _require.SYNC_STATE;

var LayerError = require('../layer-error');

var Identity = function (_Syncable) {
  _inherits(Identity, _Syncable);

  function Identity() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Identity);

    // Make sure the ID from handle fromServer parameter is used by the Root.constructor
    if (options.fromServer) {
      options.id = options.fromServer.id || '-';
    } else if (!options.id && options.userId) {
      options.id = Identity.prefixUUID + encodeURIComponent(options.userId);
    } else if (options.id && !options.userId) {
      options.userId = options.id.substring(Identity.prefixUUID.length);
    }

    // Make sure we have an clientId property
    if (options.client) options.clientId = options.client.appId;
    if (!options.clientId) throw new Error(LayerError.dictionary.clientMissing);

    // The - is here to prevent Root from generating a UUID for an ID.  ID must map to UserID
    // and can't be randomly generated.  This only occurs from Platform API sending with `sender.name` and no identity.
    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Identity).call(this, options));

    if (_this.id === '-') _this.id = '';

    _this.isInitializing = true;

    if (!_this._presence) {
      _this._presence = {
        status: null,
        lastSeenAt: null
      };
    }

    // If the options contains a full server definition of the object,
    // copy it in with _populateFromServer; this will add the Identity
    // to the Client as well.
    if (options && options.fromServer) {
      _this._populateFromServer(options.fromServer);
    }

    if (!_this.url && _this.id) {
      _this.url = _this.getClient().url + '/' + _this.id.substring(9);
    } else if (!_this.url) {
      _this.url = '';
    }
    _this.getClient()._addIdentity(_this);

    _this.getClient().on('online', function (evt) {
      if (!evt.isOnline) _this._updateValue(['_presence', 'status'], Identity.STATUS.OFFLINE);
    }, _this);

    _this.isInitializing = false;
    return _this;
  }

  _createClass(Identity, [{
    key: 'destroy',
    value: function destroy() {
      var client = this.getClient();
      if (client) client._removeIdentity(this);
      _get(Object.getPrototypeOf(Identity.prototype), 'destroy', this).call(this);
    }
  }, {
    key: '_triggerAsync',
    value: function _triggerAsync(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Identity.prototype), '_triggerAsync', this).call(this, evtName, args);
    }
  }, {
    key: 'trigger',
    value: function trigger(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Identity.prototype), 'trigger', this).call(this, evtName, args);
    }

    /**
     * Populates this instance using server-data.
     *
     * Side effects add this to the Client.
     *
     * @method _populateFromServer
     * @private
     * @param  {Object} identity - Server representation of the identity
     */

  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(identity) {
      var _this2 = this;

      var client = this.getClient();

      // Disable events if creating a new Identity
      // We still want property change events for anything that DOES change
      this._disableEvents = this.syncState === SYNC_STATE.NEW;

      this._setSynced();

      this.userId = identity.user_id || '';

      this._updateValue(['avatarUrl'], identity.avatar_url);
      this._updateValue(['displayName'], identity.display_name);

      var isFullIdentity = 'metadata' in identity;

      // Handle Full Identity vs Basic Identity
      if (isFullIdentity) {
        this.url = identity.url;
        this.type = identity.type;

        this._updateValue(['emailAddress'], identity.email_address);
        this._updateValue(['lastName'], identity.last_name);
        this._updateValue(['firstName'], identity.first_name);
        this._updateValue(['metadata'], identity.metadata);
        this._updateValue(['publicKey'], identity.public_key);
        this._updateValue(['phoneNumber'], identity.phone_number);
        this.isFullIdentity = true;
      }

      if (!this.url && this.id) {
        this.url = this.getClient().url + this.id.substring(8);
      }

      this._disableEvents = false;

      // See if we have the Full Identity Object in database
      if (!this.isFullIdentity && client.isAuthenticated) {
        client.dbManager.getObjects('identities', [this.id], function (result) {
          if (result.length) _this2._populateFromServer(result[0]);
        });
      }
    }

    /**
     * Update the property; trigger a change event, IF the value has changed.
     *
     * @method _updateValue
     * @private
     * @param {string[]} keys - Property name parts
     * @param {Mixed} value - Property value
     */

  }, {
    key: '_updateValue',
    value: function _updateValue(keys, value) {
      if (value === null || value === undefined) value = '';
      var pointer = this;
      for (var i = 0; i < keys.length - 1; i++) {
        pointer = pointer[keys[i]];
      }
      var lastKey = keys[keys.length - 1];

      if (pointer[lastKey] !== value) {
        if (!this.isInitializing) {
          if (keys[0] === '_presence') keys = [keys[1]];
          this._triggerAsync('identities:change', {
            property: keys.join('.'),
            oldValue: pointer[lastKey],
            newValue: value
          });
        }
        pointer[lastKey] = value;
      }
    }

    /**
     * Accepts json-patch operations for modifying recipientStatus.
     *
     * Note that except for a camelcase error in last_seen_at,
     * all properties are set prior to calling this method.
     *
     * @method _handlePatchEvent
     * @private
     * @param  {Object[]} data - Array of operations
     */

  }, {
    key: '_handlePatchEvent',
    value: function _handlePatchEvent(newValueIn, oldValueIn, paths) {
      var _this3 = this;

      paths.forEach(function (path) {
        var newValue = newValueIn,
            oldValue = oldValueIn;
        if (path === 'presence.last_seen_at') {
          _this3._presence.lastSeenAt = new Date(newValue.last_seen_at);
          newValue = _this3._presence.lastSeenAt;
          oldValue = oldValue.lastSeenAt;
          delete _this3._presence.last_seen_at; // Flaw in layer-patch assumes that subproperties don't get camel cased (correct assumption for `recipient_status` and `metadata`)
        } else if (path === 'presence.status') {
          newValue = _this3._presence.status;
          oldValue = oldValue.status;
        }
        var property = path.replace(/_(.)/g, function (match, value) {
          return value.toUpperCase();
        }).replace(/^presence\./, '');

        _this3._triggerAsync('identities:change', {
          property: property,
          oldValue: oldValue,
          newValue: newValue
        });
      });
    }

    /**
     * Follow this User.
     *
     * Following a user grants access to their Full Identity,
     * as well as websocket events that update the Identity.
     * @method follow
     */

  }, {
    key: 'follow',
    value: function follow() {
      var _this4 = this;

      if (this.isFullIdentity) return;
      this._xhr({
        method: 'PUT',
        url: this.url.replace(/identities/, 'following/users'),
        syncable: {}
      }, function (result) {
        if (result.success) _this4._load();
      });
      this.syncState = SYNC_STATE.LOADING;
    }

    /**
     * Unfollow this User.
     *
     * Unfollowing the user will reduce your access to only having their Basic Identity,
     * and this Basic Identity will only show up when a relevant Message or Conversation has been loaded.
     *
     * Websocket change notifications for this user will not arrive.
     *
     * @method unfollow
     */

  }, {
    key: 'unfollow',
    value: function unfollow() {
      this._xhr({
        url: this.url.replace(/identities/, 'following/users'),
        method: 'DELETE',
        syncable: {}
      });
    }

    /**
     * Set the status of the current user.
     *
     * @method setStatus
     * @param {String} status    One of layer.Identity.STATUS.AVAILABLE, layer.Identity.STATUS.AWAY,
     *        layer.Identity.STATUS.BUSY, layer.Identity.STATUS.OFLINE
     */

  }, {
    key: 'setStatus',
    value: function setStatus(status) {
      var _this5 = this;

      status = (status || '').toLowerCase();
      if (!Identity.STATUS[status.toUpperCase()]) throw new Error(LayerError.dictionary.valueNotSupported);
      if (this !== this.getClient().user) throw new Error(LayerError.dictionary.permissionDenied);
      if (status === Identity.STATUS.INVISIBLE) status = Identity.STATUS.OFFLINE; // these are equivalent; only one supported by server

      var oldValue = this._presence.status;
      this.getClient().sendSocketRequest({
        method: 'PATCH',
        body: {
          method: 'Presence.update',
          data: [{ operation: 'set', property: 'status', value: status }]
        },
        sync: {
          depends: [this.id],
          target: this.id
        }
      }, function (result) {
        if (!result.success) _this5._updateValue(['_presence', 'status'], oldValue);
      });

      // these are equivalent; only one is useful for understanding your state given that your still connected/online.
      if (status === Identity.STATUS.OFFLINE) status = Identity.STATUS.INVISIBLE;

      this._updateValue(['_presence', 'status'], status);
    }

    /**
     * Update the UserID.
     *
     * This will not only update the User ID, but also the ID,
     * URL, and reregister it with the Client.
     *
     * @method _setUserId
     * @private
     * @param {string} userId
     */

  }, {
    key: '_setUserId',
    value: function _setUserId(userId) {
      var client = this.getClient();
      client._removeIdentity(this);
      this.__userId = userId;
      var encoded = encodeURIComponent(userId);
      this.id = Identity.prefixUUID + encoded;
      this.url = this.getClient().url + '/identities/' + encoded;
      client._addIdentity(this);
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any attempt to execute `this.userId = 'xxx'` will cause an error to be thrown.
     * These are not intended to be writable properties
     *
     * @private
     * @method __adjustUserId
     * @param {string} value - New appId value
     */

  }, {
    key: '__adjustUserId',
    value: function __adjustUserId(userId) {
      if (this.__userId) {
        throw new Error(LayerError.dictionary.cantChangeUserId);
      }
    }

    /**
     * Handle a Websocket DELETE event received from the server.
     *
     * A DELETE event means we have unfollowed this user; and should downgrade to a Basic Identity.
     *
     * @method _handleWebsocketDelete
     * @protected
     * @param {Object} data - Deletion parameters; typically null in this case.
    */
    // Turn a Full Identity into a Basic Identity and delete the Full Identity from the database

  }, {
    key: '_handleWebsocketDelete',
    value: function _handleWebsocketDelete(data) {
      var _this6 = this;

      this.getClient().dbManager.deleteObjects('identities', [this]);
      ['firstName', 'lastName', 'emailAddress', 'phoneNumber', 'metadata', 'publicKey', 'isFullIdentity', 'type'].forEach(function (key) {
        return delete _this6[key];
      });
      this._triggerAsync('identities:unfollow');
    }

    /**
     * Create a new Identity based on a Server description of the user.
     *
     * @method _createFromServer
     * @static
     * @param {Object} identity - Server Identity Object
     * @param {layer.Client} client
     * @returns {layer.Identity}
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(identity, client) {
      return new Identity({
        client: client,
        fromServer: identity,
        _fromDB: identity._fromDB
      });
    }
  }]);

  return Identity;
}(Syncable);

/**
 * Display name for the User or System Identity.
 * @type {string}
 */


Identity.prototype.displayName = '';

/**
 * The Identity matching `layer.Client.user` will have this be true.
 *
 * All other Identities will have this as false.
 * @type {boolean}
 */
Identity.prototype.sessionOwner = false;

/**
 * ID of the Client this Identity is associated with.
 * @type {string}
 */
Identity.prototype.clientId = '';

/**
 * Is this a Full Identity or Basic Identity?
 *
 * Note that Service Identities are always considered to be Basic.
 * @type {boolean}
 */
Identity.prototype.isFullIdentity = false;

/**
 * Unique ID for this User.
 * @type {string}
 */
Identity.prototype.userId = '';

/**
 * Optional URL for the user's icon.
 * @type {string}
 */
Identity.prototype.avatarUrl = '';

/**
 * Optional first name for this user.
 *
 * Full Identities Only.
 *
 * @type {string}
 */
Identity.prototype.firstName = '';

/**
 * Optional last name for this user.
 *
 * Full Identities Only.
 *
 * @type {string}
 */
Identity.prototype.lastName = '';

/**
 * Optional email address for this user.
 *
 * Full Identities Only.
 *
 * @type {string}
 */
Identity.prototype.emailAddress = '';

/**
 * Optional phone number for this user.
 *
 * Full Identities Only.
 *
 * @type {string}
 */
Identity.prototype.phoneNumber = '';

/**
 * Optional metadata for this user.
 *
 * Full Identities Only.
 *
 * @type {Object}
 */
Identity.prototype.metadata = null;

/**
 * Optional public key for encrypting message text for this user.
 *
 * Full Identities Only.
 *
 * @type {string}
 */
Identity.prototype.publicKey = '';

/**
 * @static
 * @type {string} The Identity represents a user.  Value used in the layer.Identity.type field.
 */
Identity.UserType = 'user';

/**
 * @static
 * @type {string} The Identity represents a bot.  Value used in the layer.Identity.type field.
 */
Identity.BotType = 'bot';

/**
 * What type of Identity does this represent?
 *
 * * A bot? Use layer.Identity.BotType
 * * A User? Use layer.Identity.UserType
 * @type {string}
 */
Identity.prototype.type = Identity.UserType;

/**
 * Presence object contains presence information for this user.
 *
 * Properties of the sub-object are:
 *
 * * `status`: has the following possible values:
 * ** `available`: User has set their status to `available`.  This is the default initial state
 * ** `away`: App or User has changed their status to `away`
 * ** `busy`: App or User has changed their status to `busy`
 * ** `offline`: User is not connected or has set their status to `offline`
 * ** `invisible`: When a user has set their status to `offline` they instead see a status of `invisible` so that they know
 *    that they have deliberately set their status to `offline` but are still connected.
 * * `lastSeenAt`: Approximate time that the user was last known to be connected (and not `invisible`)
 *
 * @property {Object} _presence
 * @property {String} _presence.status
 * @property {Date} _presence.lastSeenAt
 * @private
 */
Identity.prototype._presence = null;

/**
 * The user's current status or availability.
 *
 * Value is one of:
 *
 * * `layer.Identity.STATUS.AVAILABLE`: User has set their status to `available`.  This is the default initial state
 * * `layer.Identity.STATUS.AWAY`: App or User has changed their status to `away`
 * * `layer.Identity.STATUS.BUSY`: App or User has changed their status to `busy`
 * * `layer.Identity.STATUS.OFFLINE`: User is not connected or has set their status to `offline`
 * * `layer.Identity.STATUS.INVISIBLE`: When a user has set their status to `offline` they instead see a status of `invisible` so that they know
 *    that they have deliberately set their status to `offline` but are still connected.
 *
 * This property can only be set on the session owner's identity, not on other identities via:
 *
 * ```
 * client.user.setStatus(layer.Identity.STATUS.AVAILABLE);
 * ```
 *
 * @property {String} status
 * @readonly
 */
Object.defineProperty(Identity.prototype, 'status', {
  enumerable: true,
  get: function get() {
    return this._presence && this._presence.status || Identity.STATUS.OFFLINE;
  }
});

/**
 * Time that the user was last known to be online.
 *
 * Accurate to within about 15 minutes.  User's who are online, but set their status
 * to `layer.Identity.STATUS.INVISIBLE` will not have their `lastSeenAt` value updated.
 *
 * @property {Date} lastSeenAt
 * @readonly
 */
Object.defineProperty(Identity.prototype, 'lastSeenAt', {
  enumerable: true,
  get: function get() {
    return this._presence && this._presence.lastSeenAt;
  }
});

/**
 * Is this Identity a bot?
 *
 * If the layer.Identity.type field is equal to layer.Identity.BotType then this will return true.
 * @property {boolean} isBot
 */
Object.defineProperty(Identity.prototype, 'isBot', {
  enumerable: true,
  get: function get() {
    return this.type === Identity.BotType;
  }
});

/**
 * Possible values for layer.Identity.status field to be used in `setStatus()`
 *
 * @property {Object} STATUS
 * @property {String} STATUS.AVAILABLE   User has set their status to `available`.  This is the default initial state
 * @property {String} STATUS.AWAY        App or User has changed their status to `away`
 * @property {String} STATUS.BUSY     App or User has changed their status to `busy`
 * @property {String} STATUS.OFFLINE  User is not connected or has set their status to `offline`
 * @property {String} STATUS.INVISIBLE  When a user has set their status to `offline` they instead see a status of `invisible` so that they know
 *    that they have deliberately set their status to `offline` but are still connected.
 * @static
 */
Identity.STATUS = {
  AVAILABLE: 'available',
  AWAY: 'away',
  OFFLINE: 'offline',
  BUSY: 'busy',
  INVISIBLE: 'invisible'
};

Identity.inObjectIgnore = Root.inObjectIgnore;

Identity.bubbleEventParent = 'getClient';

Identity._supportedEvents = ['identities:change', 'identities:loaded', 'identities:loaded-error', 'identities:unfollow'].concat(Syncable._supportedEvents);

Identity.eventPrefix = 'identities';
Identity.prefixUUID = 'layer:///identities/';
Identity.enableOpsIfNew = true;

Root.initClass.apply(Identity, [Identity, 'Identity']);
Syncable.subclasses.push(Identity);

module.exports = Identity;


},{"../const":84,"../layer-error":86,"../root":116,"./syncable":106}],103:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Membership class represents an Membership of a user within a channel.
 *
 * Identities are created by the System, never directly by apps.
 *
 * @class layer.Membership
 * @experimental This feature is incomplete, and available as Preview only.
 * @extends layer.Syncable
 */

var Syncable = require('./syncable');
var Root = require('../root');
var Constants = require('../const');
var LayerError = require('../layer-error');

var Membership = function (_Syncable) {
  _inherits(Membership, _Syncable);

  function Membership() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Membership);

    // Make sure the ID from handle fromServer parameter is used by the Root.constructor
    if (options.fromServer) {
      options.id = options.fromServer.id;
    } else if (options.id && !options.userId) {
      options.userId = options.id.replace(/^.*\//, '');
    }

    // Make sure we have an clientId property
    if (options.client) options.clientId = options.client.appId;
    if (!options.clientId) throw new Error(LayerError.dictionary.clientMissing);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Membership).call(this, options));

    _this.isInitializing = true;

    // If the options contains a full server definition of the object,
    // copy it in with _populateFromServer; this will add the Membership
    // to the Client as well.
    if (options && options.fromServer) {
      _this._populateFromServer(options.fromServer);
    }

    if (!_this.url && _this.id) {
      _this.url = _this.getClient().url + '/' + _this.id.substring(9);
    } else if (!_this.url) {
      _this.url = '';
    }
    _this.getClient()._addMembership(_this);

    _this.isInitializing = false;
    return _this;
  }

  _createClass(Membership, [{
    key: 'destroy',
    value: function destroy() {
      var client = this.getClient();
      if (client) client._removeMembership(this);
      _get(Object.getPrototypeOf(Membership.prototype), 'destroy', this).call(this);
    }
  }, {
    key: '_triggerAsync',
    value: function _triggerAsync(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Membership.prototype), '_triggerAsync', this).call(this, evtName, args);
    }
  }, {
    key: 'trigger',
    value: function trigger(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Membership.prototype), 'trigger', this).call(this, evtName, args);
    }

    /**
     * Populates this instance using server-data.
     *
     * Side effects add this to the Client.
     *
     * @method _populateFromServer
     * @private
     * @param  {Object} membership - Server representation of the membership
     */

  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(membership) {
      var _this2 = this;

      var client = this.getClient();

      // Disable events if creating a new Membership
      // We still want property change events for anything that DOES change
      this._disableEvents = this.syncState === Constants.SYNC_STATE.NEW;

      this._setSynced();

      this.userId = membership.identity ? membership.identity.user_id || '' : client.user.userId;
      this.channelId = membership.channel.id;

      // this.role = client._createObject(membership.role);

      this.identity = membership.identity ? client._createObject(membership.identity) : client.user;
      this.identity.on('identities:change', function (evt) {
        _this2.trigger('members:change', {
          property: 'identity'
        });
      }, this);

      if (!this.url && this.id) {
        this.url = this.getClient().url + this.id.substring(8);
      }

      this._disableEvents = false;
    }

    /**
     * Update the property; trigger a change event, IF the value has changed.
     *
     * @method _updateValue
     * @private
     * @param {string} key - Property name
     * @param {Mixed} value - Property value
     */

  }, {
    key: '_updateValue',
    value: function _updateValue(key, value) {
      if (value === null || value === undefined) value = '';
      if (this[key] !== value) {
        if (!this.isInitializing) {
          this._triggerAsync('members:change', {
            property: key,
            oldValue: this[key],
            newValue: value
          });
        }
        this[key] = value;
      }
    }
  }, {
    key: '__getUserId',
    value: function __getUserId() {
      return this.identity ? this.identity.userId : '';
    }
  }, {
    key: '__updateIdentity',
    value: function __updateIdentity(newIdentity, oldIdentity) {
      if (oldIdentity) oldIdentity.off(null, null, this);
    }

    /**
     * Create a new Membership based on a Server description of the user.
     *
     * @method _createFromServer
     * @static
     * @param {Object} membership - Server Membership Object
     * @param {layer.Client} client
     * @returns {layer.Membership}
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(membership, client) {
      return new Membership({
        client: client,
        fromServer: membership,
        _fromDB: membership._fromDB
      });
    }
  }]);

  return Membership;
}(Syncable);

/**
 * User ID that the Membership describes.
 *
 * @type {string}
 */


Membership.prototype.userId = '';

/**
 * Channel ID that the membership describes.
 *
 * @type {string}
 */
Membership.prototype.channelId = '';

/**
 * The user's role within the channel
 *
 * @ignore
 * @type {layer.Role}
 */
Membership.prototype.role = null;

/**
 * Identity associated with the membership
 *
 * @type {layer.Identity}
 */
Membership.prototype.identity = '';

Membership.inObjectIgnore = Root.inObjectIgnore;

Membership.bubbleEventParent = 'getClient';

Membership._supportedEvents = ['members:change', 'members:loaded', 'members:loaded-error'].concat(Syncable._supportedEvents);

Membership.eventPrefix = 'members';
Membership.prefixUUID = '/members/';

Root.initClass.apply(Membership, [Membership, 'Membership']);
Syncable.subclasses.push(Membership);

module.exports = Membership;


},{"../const":84,"../layer-error":86,"../root":116,"./syncable":106}],104:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The MessagePart class represents an element of a message.
 *
 *      // Create a Message Part with any mimeType
 *      var part = new layer.MessagePart({
 *          body: "hello",
 *          mimeType: "text/plain"
 *      });
 *
 *      // Create a text/plain only Message Part
 *      var part = new layer.MessagePart("Hello I am text/plain");
 *
 * You can also create a Message Part from a File Input dom node:
 *
 *      var fileInputNode = document.getElementById("myFileInput");
 *      var part = new layer.MessagePart(fileInputNode.files[0]);
 *
 * You can also create Message Parts from a file drag and drop operation:
 *
 *      onFileDrop: function(evt) {
 *           var files = evt.dataTransfer.files;
 *           var m = conversation.createMessage({
 *               parts: files.map(function(file) {
 *                  return new layer.MessagePart({body: file, mimeType: file.type});
 *               }
 *           });
 *      });
 *
 * ### Blobs vs Strings
 *
 * You should always expect to see the `body` property be a Blob **unless** the mimeType is listed in layer.MessagePart.TextualMimeTypes,
 * in which case the value will be a String.  You can add mimeTypes to TextualMimeTypes:
 *
 * ```
 * layer.MessagePart.TextualMimeTypes = ['text/plain', 'text/mountain', /^application\/json(\+.+)$/]
 * ```
 *
 * Any mimeType matching the above strings and regular expressions will be transformed to text before being delivered to your app; otherwise it
 * must be a Blob.  Note that the above snippet sets a static property that is set once, and affects all MessagePart objects for the lifespan of
 * the app.
 *
 * ### Accesing Rich Content
 *
 * There are two ways of accessing rich content
 *
 * 1. Access the data directly: `part.fetchContent(function(data) {myRenderData(data);})`. This approach downloads the data,
 *    writes it to the the `body` property, writes a Data URI to the part's `url` property, and then calls your callback.
 *    By downloading the data and storing it in `body`, the data does not expire.
 * 2. Access the URL rather than the data.  When you first receive the Message Part it will have a valid `url` property; however, this URL expires.  *    URLs are needed for streaming, and for content that doesn't yet need to be rendered (e.g. hyperlinks to data that will render when clicked).
 *    The url property will return a string if the url is valid, or '' if its expired.  Call `part.fetchStream(callback)` to get an updated URL.
 *    The following pattern is recommended:
 *
 * ```
 * if (!part.url) {
 *   part.fetchStream(function(url) {myRenderUrl(url)});
 * } else {
 *   myRenderUrl(part.url);
 * }
 * ```
 *
 * NOTE: `layer.MessagePart.url` should have a value when the message is first received, and will only fail `if (!part.url)` once the url has expired.
 *
 * @class  layer.MessagePart
 * @extends layer.Root
 * @author Michael Kantor
 */

var Root = require('../root');
var Content = require('./content');
var xhr = require('../xhr');
var ClientRegistry = require('../client-registry');
var LayerError = require('../layer-error');
var Util = require('../client-utils');
var logger = require('../logger');

var MessagePart = function (_Root) {
  _inherits(MessagePart, _Root);

  /**
   * Constructor
   *
   * @method constructor
   * @param  {Object} options - Can be an object with body and mimeType, or it can be a string, or a Blob/File
   * @param  {string} options.body - Any string larger than 2kb will be sent as Rich Content, meaning it will be uploaded to cloud storage and must be separately downloaded from the Message when its received.
   * @param  {string} [options.mimeType=text/plain] - Mime type; can be anything; if your client doesn't have a renderer for it, it will be ignored.
   * @param  {number} [options.size=0] - Size of your part. Will be calculated for you if not provided.
   *
   * @return {layer.MessagePart}
   */
  function MessagePart(options) {
    _classCallCheck(this, MessagePart);

    var newOptions = options;
    if (typeof options === 'string') {
      newOptions = { body: options };
      if ((arguments.length <= 1 ? 0 : arguments.length - 1) > 0) {
        newOptions.mimeType = arguments.length <= 1 ? undefined : arguments[1];
      } else {
        newOptions.mimeType = 'text/plain';
      }
    } else if (Util.isBlob(options) || Util.isBlob(options.body)) {
      var body = options instanceof Blob ? options : options.body;
      var mimeType = Util.isBlob(options.body) ? options.mimeType : body.type;
      newOptions = {
        mimeType: mimeType,
        body: body,
        size: body.size,
        hasContent: true
      };
    }

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MessagePart).call(this, newOptions));

    if (!_this.size && _this.body) _this.size = _this.body.length;

    // Don't expose encoding; blobify it if its encoded.
    if (options.encoding === 'base64') {
      _this.body = Util.base64ToBlob(_this.body);
    }

    // Could be a blob because it was read out of indexedDB,
    // or because it was created locally with a file
    // Or because of base64 encoded data.
    var isBlobBody = Util.isBlob(_this.body);
    var textual = _this.isTextualMimeType();

    // Custom handling for non-textual content
    if (!textual) {
      // If the body exists and is a blob, extract the data uri for convenience; only really relevant for image and video HTML tags.
      if (!isBlobBody && _this.body) _this.body = new Blob([_this.body], { type: _this.mimeType });
      if (_this.body) _this.url = URL.createObjectURL(_this.body);
    }

    // If our textual content is a blob, turning it into text is asychronous, and can't be done in the synchronous constructor
    // This will only happen when the client is attaching a file.  Conversion for locally created messages is done while calling `Message.send()`
    return _this;
  }

  _createClass(MessagePart, [{
    key: 'destroy',
    value: function destroy() {
      if (this.__url) {
        URL.revokeObjectURL(this.__url);
        this.__url = null;
      }
      this.body = null;
      _get(Object.getPrototypeOf(MessagePart.prototype), 'destroy', this).call(this);
    }

    /**
     * Get the layer.Client associated with this layer.MessagePart.
     *
     * Uses the layer.MessagePart.clientId property.
     *
     * @method _getClient
     * @private
     * @return {layer.Client}
     */

  }, {
    key: '_getClient',
    value: function _getClient() {
      return ClientRegistry.get(this.clientId);
    }

    /**
     * Get the layer.Message associated with this layer.MessagePart.
     *
     * @method _getMessage
     * @private
     * @return {layer.Message}
     */

  }, {
    key: '_getMessage',
    value: function _getMessage() {
      return this._getClient().getMessage(this.id.replace(/\/parts.*$/, ''));
    }

    /**
     * Download Rich Content from cloud server.
     *
     * For MessageParts with rich content, this method will load the data from google's cloud storage.
     * The body property of this MessagePart is set to the result.
     *
     *      messagepart.fetchContent()
     *      .on("content-loaded", function() {
     *          render(messagepart.body);
     *      });
     *
     * Note that a successful call to `fetchContent` will also cause Query change events to fire.
     * In this example, `render` will be called by the query change event that will occur once the content has downloaded:
     *
     * ```
     *  query.on('change', function(evt) {
     *    render(query.data);
     *  });
     *  messagepart.fetchContent();
     * ```
     *
     *
     * @method fetchContent
     * @param {Function} [callback]
     * @param {Mixed} callback.data - Either a string (mimeType=text/plain) or a Blob (all other mimeTypes)
     * @return {layer.Content} this
     */

  }, {
    key: 'fetchContent',
    value: function fetchContent(callback) {
      var _this2 = this;

      if (this._content && !this.isFiring) {
        this.isFiring = true;
        var type = this.mimeType === 'image/jpeg+preview' ? 'image/jpeg' : this.mimeType;
        this._content.loadContent(type, function (err, result) {
          if (!_this2.isDestroyed) _this2._fetchContentCallback(err, result, callback);
        });
      }
      return this;
    }

    /**
     * Callback with result or error from calling fetchContent.
     *
     * @private
     * @method _fetchContentCallback
     * @param {layer.LayerError} err
     * @param {Object} result
     * @param {Function} callback
     */

  }, {
    key: '_fetchContentCallback',
    value: function _fetchContentCallback(err, result, callback) {
      var _this3 = this;

      if (err) {
        this.trigger('content-loaded-error', err);
      } else {
        this.isFiring = false;
        if (this.isTextualMimeType()) {
          Util.fetchTextFromFile(result, function (text) {
            return _this3._fetchContentComplete(text, callback);
          });
        } else {
          this.url = URL.createObjectURL(result);
          this._fetchContentComplete(result, callback);
        }
      }
    }

    /**
     * Callback with Part Body from _fetchContentCallback.
     *
     * @private
     * @method _fetchContentComplete
     * @param {Blob|String} body
     * @param {Function} callback
     */

  }, {
    key: '_fetchContentComplete',
    value: function _fetchContentComplete(body, callback) {
      var message = this._getMessage();
      if (!message) return;
      this.body = body;

      this.trigger('content-loaded');
      message._triggerAsync('messages:change', {
        oldValue: message.parts,
        newValue: message.parts,
        property: 'parts'
      });
      if (callback) callback(this.body);
    }

    /**
     * Access the URL to the remote resource.
     *
     * Useful for streaming the content so that you don't have to download the entire file before rendering it.
     * Also useful for content that will be openned in a new window, and does not need to be fetched now.
     *
     * For MessageParts with Rich Content, will lookup a URL to your Rich Content.
     * Useful for streaming and content so that you don't have to download the entire file before rendering it.
     *
     * ```
     * messagepart.fetchStream(function(url) {
     *     render(url);
     * });
     * ```
     *
     * Note that a successful call to `fetchStream` will also cause Query change events to fire.
     * In this example, `render` will be called by the query change event that will occur once the `url` has been refreshed:
     *
     * ```
     *  query.on('change', function(evt) {
     *      render(query.data);
     *  });
     *  messagepart.fetchStream();
     * ```
     *
     * @method fetchStream
     * @param {Function} [callback]
     * @param {Mixed} callback.url
     * @return {layer.Content} this
     */

  }, {
    key: 'fetchStream',
    value: function fetchStream(callback) {
      var _this4 = this;

      if (!this._content) throw new Error(LayerError.dictionary.contentRequired);
      if (this._content.isExpired()) {
        this._content.refreshContent(this._getClient(), function (url) {
          return _this4._fetchStreamComplete(url, callback);
        });
      } else {
        this._fetchStreamComplete(this._content.downloadUrl, callback);
      }
      return this;
    }

    // Does not set this.url; instead relies on fact that this._content.downloadUrl has been updated

  }, {
    key: '_fetchStreamComplete',
    value: function _fetchStreamComplete(url, callback) {
      var message = this._getMessage();

      this.trigger('url-loaded');
      message._triggerAsync('messages:change', {
        oldValue: message.parts,
        newValue: message.parts,
        property: 'parts'
      });
      if (callback) callback(url);
    }

    /**
     * Preps a MessagePart for sending.  Normally that is trivial.
     * But if there is rich content, then the content must be uploaded
     * and then we can trigger a "parts:send" event indicating that
     * the part is ready to send.
     *
     * @method _send
     * @protected
     * @param  {layer.Client} client
     * @fires parts:send
     */

  }, {
    key: '_send',
    value: function _send(client) {
      // There is already a Content object, presumably the developer
      // already took care of this step for us.
      if (this._content) {
        this._sendWithContent();
      }

      // If the size is large, Create and upload the Content
      else if (this.size > 2048) {
          this._generateContentAndSend(client);
        }

        // If the body is a blob, but is not YET Rich Content, do some custom analysis/processing:
        else if (Util.isBlob(this.body)) {
            this._sendBlob(client);
          }

          // Else the message part can be sent as is.
          else {
              this._sendBody();
            }
    }
  }, {
    key: '_sendBody',
    value: function _sendBody() {
      if (typeof this.body !== 'string') {
        var err = 'MessagePart.body must be a string in order to send it';
        logger.error(err, { mimeType: this.mimeType, body: this.body });
        throw new Error(err);
      }

      var obj = {
        mime_type: this.mimeType,
        body: this.body
      };
      this.trigger('parts:send', obj);
    }
  }, {
    key: '_sendWithContent',
    value: function _sendWithContent() {
      this.trigger('parts:send', {
        mime_type: this.mimeType,
        content: {
          size: this.size,
          id: this._content.id
        }
      });
    }

    /**
     * This method is only called if Blob.size < 2048.
     *
     * However, conversion to base64 can impact the size, so we must retest the size
     * after conversion, and then decide to send the original blob or the base64 encoded data.
     *
     * @method _sendBlob
     * @private
     * @param {layer.Client} client
     */

  }, {
    key: '_sendBlob',
    value: function _sendBlob(client) {
      var _this5 = this;

      /* istanbul ignore else */
      Util.blobToBase64(this.body, function (base64data) {
        if (base64data.length < 2048) {
          var body = base64data.substring(base64data.indexOf(',') + 1);
          var obj = {
            body: body,
            mime_type: _this5.mimeType
          };
          obj.encoding = 'base64';
          _this5.trigger('parts:send', obj);
        } else {
          _this5._generateContentAndSend(client);
        }
      });
    }

    /**
     * Create an rich Content object on the server
     * and then call _processContentResponse
     *
     * @method _generateContentAndSend
     * @private
     * @param  {layer.Client} client
     */

  }, {
    key: '_generateContentAndSend',
    value: function _generateContentAndSend(client) {
      var _this6 = this;

      this.hasContent = true;
      var body = void 0;
      if (!Util.isBlob(this.body)) {
        body = Util.base64ToBlob(Util.utoa(this.body), this.mimeType);
      } else {
        body = this.body;
      }
      client.xhr({
        url: '/content',
        method: 'POST',
        headers: {
          'Upload-Content-Type': this.mimeType,
          'Upload-Content-Length': body.size,
          'Upload-Origin': typeof location !== 'undefined' ? location.origin : ''
        },
        sync: {}
      }, function (result) {
        return _this6._processContentResponse(result.data, body, client);
      });
    }

    /**
     * Creates a layer.Content object from the server's
     * Content object, and then uploads the data to google cloud storage.
     *
     * @method _processContentResponse
     * @private
     * @param  {Object} response
     * @param  {Blob} body
     * @param  {layer.Client} client
     */

  }, {
    key: '_processContentResponse',
    value: function _processContentResponse(response, body, client) {
      var _this7 = this;

      this._content = new Content(response.id);
      this.hasContent = true;

      xhr({
        url: response.upload_url,
        method: 'PUT',
        data: body,
        headers: {
          'Upload-Content-Length': this.size,
          'Upload-Content-Type': this.mimeType
        }
      }, function (result) {
        return _this7._processContentUploadResponse(result, response, client);
      });
    }
  }, {
    key: '_processContentUploadResponse',
    value: function _processContentUploadResponse(uploadResult, contentResponse, client) {
      if (!uploadResult.success) {
        if (!client.onlineManager.isOnline) {
          client.onlineManager.once('connected', this._processContentResponse.bind(this, contentResponse, client), this);
        } else {
          logger.error('We don\'t yet handle this!');
        }
      } else {
        this.trigger('parts:send', {
          mime_type: this.mimeType,
          content: {
            size: this.size,
            id: this._content.id
          }
        });
      }
    }

    /**
     * Returns the text for any text/plain part.
     *
     * Returns '' if its not a text/plain part.
     *
     * @method getText
     * @return {string}
     */

  }, {
    key: 'getText',
    value: function getText() {
      if (this.isTextualMimeType()) {
        return this.body;
      } else {
        return '';
      }
    }

    /**
     * Updates the MessagePart with new data from the server.
     *
     * Currently, MessagePart properties do not update... however,
     * the layer.Content object that Rich Content MessageParts contain
     * do get updated with refreshed expiring urls.
     *
     * @method _populateFromServer
     * @param  {Object} part - Server representation of a part
     * @private
     */

  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(part) {
      if (part.content && this._content) {
        this._content.downloadUrl = part.content.download_url;
        this._content.expiration = new Date(part.content.expiration);
      }
    }

    /**
     * Is the mimeType for this MessagePart defined as textual content?
     *
     * If the answer is true, expect a `body` of string, else expect `body` of Blob.
     *
     * To change whether a given MIME Type is treated as textual, see layer.MessagePart.TextualMimeTypes.
     *
     * @method isTextualMimeType
     * @returns {Boolean}
     */

  }, {
    key: 'isTextualMimeType',
    value: function isTextualMimeType() {
      var i = 0;
      for (i = 0; i < MessagePart.TextualMimeTypes.length; i++) {
        var test = MessagePart.TextualMimeTypes[i];
        if (typeof test === 'string') {
          if (test === this.mimeType) return true;
        } else if (test instanceof RegExp) {
          if (this.mimeType.match(test)) return true;
        }
      }
      return false;
    }

    /**
     * Creates a MessagePart from a server representation of the part
     *
     * @method _createFromServer
     * @private
     * @static
     * @param  {Object} part - Server representation of a part
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(part) {
      var content = part.content ? Content._createFromServer(part.content) : null;

      // Turn base64 data into a Blob
      if (part.encoding === 'base64') part.body = Util.base64ToBlob(part.body, part.mimeType);

      // Create the MessagePart
      return new MessagePart({
        id: part.id,
        mimeType: part.mime_type,
        body: part.body || '',
        _content: content,
        hasContent: Boolean(content),
        size: part.size || 0
      });
    }
  }]);

  return MessagePart;
}(Root);

/**
 * layer.Client that the conversation belongs to.
 *
 * Actual value of this string matches the appId.
 * @type {string}
 */


MessagePart.prototype.clientId = '';

/**
 * Server generated identifier for the part
 * @type {string}
 */
MessagePart.prototype.id = '';

/**
 * Body of your message part.
 *
 * This is the core data of your part.
 *
 * If this is `null` then most likely layer.Message.hasContent is true, and you
 * can either use the layer.MessagePart.url property or the layer.MessagePart.fetchContent method.
 *
 * @type {string}
 */
MessagePart.prototype.body = null;

/**
 * Rich content object.
 *
 * This will be automatically created for you if your layer.MessagePart.body
 * is large.
 * @type {layer.Content}
 * @private
 */
MessagePart.prototype._content = null;

/**
 * The Part has rich content
 * @type {Boolean}
 */
MessagePart.prototype.hasContent = false;

/**
 * URL to rich content object.
 *
 * Parts with rich content will be initialized with this property set.  But its value will expire.
 *
 * Will contain an expiring url at initialization time and be refreshed with calls to `layer.MessagePart.fetchStream()`.
 * Will contain a non-expiring url to a local resource if `layer.MessagePart.fetchContent()` is called.
 *
 * @type {layer.Content}
 */
Object.defineProperty(MessagePart.prototype, 'url', {
  enumerable: true,
  get: function get() {
    // Its possible to have a url and no content if it has been instantiated but not yet sent.
    // If there is a __url then its a local url generated from the body property and does not expire.
    if (this.__url) return this.__url;
    if (this._content) return this._content.isExpired() ? '' : this._content.downloadUrl;
    return '';
  },
  set: function set(inValue) {
    this.__url = inValue;
  }
});

/**
 * Mime Type for the data represented by the MessagePart.
 *
 * Typically this is the type for the data in layer.MessagePart.body;
 * if there is Rich Content, then its the type of Content that needs to be
 * downloaded.
 *
 * @type {String}
 */
MessagePart.prototype.mimeType = 'text/plain';

/**
 * Size of the layer.MessagePart.body.
 *
 * Will be set for you if not provided.
 * Only needed for use with rich content.
 *
 * @type {number}
 */
MessagePart.prototype.size = 0;

/**
 * Array of mime types that should be treated as text.
 *
 * Treating a MessagePart as text means that even if the `body` gets a File or Blob,
 * it will be transformed to a string before being delivered to your app.
 *
 * This value can be customized using strings and regular expressions:
 *
 * ```
 * layer.MessagePart.TextualMimeTypes = ['text/plain', 'text/mountain', /^application\/json(\+.+)$/]
 * ```
 *
 * @static
 * @type {Mixed[]}
 */
MessagePart.TextualMimeTypes = [/^text\/.+$/, /^application\/json(\+.+)?$/];

MessagePart._supportedEvents = ['parts:send', 'content-loaded', 'url-loaded', 'content-loaded-error'].concat(Root._supportedEvents);
Root.initClass.apply(MessagePart, [MessagePart, 'MessagePart']);

module.exports = MessagePart;


},{"../client-registry":81,"../client-utils":82,"../layer-error":86,"../logger":88,"../root":116,"../xhr":126,"./content":99}],105:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Message Class represents Messages sent amongst participants
 * of of a Conversation.
 *
 * The simplest way to create and send a message is:
 *
 *      var m = conversation.createMessage('Hello there').send();
 *      var m = channel.createMessage('Hello there').send();
 *
 * For conversations that involve notifications (primarily for Android and IOS), the more common pattern is:
 *
 *      var m = conversation.createMessage('Hello there').send({text: "Message from Fred: Hello there"});
 *
 * Channels do not at this time support notifications.
 *
 * Typically, rendering would be done as follows:
 *
 *      // Create a layer.Query that loads Messages for the
 *      // specified Conversation.
 *      var query = client.createQuery({
 *        model: Query.Message,
 *        predicate: 'conversation = "' + conversation.id + '"'
 *      });
 *
 *      // Any time the Query's data changes the 'change'
 *      // event will fire.
 *      query.on('change', function(layerEvt) {
 *        renderNewMessages(query.data);
 *      });
 *
 *      // This will call will cause the above event handler to receive
 *      // a change event, and will update query.data.
 *      conversation.createMessage('Hello there').send();
 *
 * The above code will trigger the following events:
 *
 *  * Message Instance fires
 *    * messages:sending: An event that lets you modify the message prior to sending
 *    * messages:sent: The message was received by the server
 *  * Query Instance fires
 *    * change: The query has received a new Message
 *    * change:add: Same as the change event but does not receive other types of change events
 *
 * When creating a Message there are a number of ways to structure it.
 * All of these are valid and create the same exact Message:
 *
 *      // Full API style:
 *      var m = conversation.createMessage({
 *          parts: [new layer.MessagePart({
 *              body: 'Hello there',
 *              mimeType: 'text/plain'
 *          })]
 *      });
 *
 *      // Option 1: Pass in an Object instead of an array of layer.MessageParts
 *      var m = conversation.createMessage({
 *          parts: {
 *              body: 'Hello there',
 *              mimeType: 'text/plain'
 *          }
 *      });
 *
 *      // Option 2: Pass in an array of Objects instead of an array of layer.MessageParts
 *      var m = conversation.createMessage({
 *          parts: [{
 *              body: 'Hello there',
 *              mimeType: 'text/plain'
 *          }]
 *      });
 *
 *      // Option 3: Pass in a string (automatically assumes mimeType is text/plain)
 *      // instead of an array of objects.
 *      var m = conversation.createMessage({
 *          parts: 'Hello'
 *      });
 *
 *      // Option 4: Pass in an array of strings (automatically assumes mimeType is text/plain)
 *      var m = conversation.createMessage({
 *          parts: ['Hello']
 *      });
 *
 *      // Option 5: Pass in just a string and nothing else
 *      var m = conversation.createMessage('Hello');
 *
 *      // Option 6: Use addPart.
 *      var m = converseation.createMessage();
 *      m.addPart({body: "hello", mimeType: "text/plain"});
 *
 * Key methods, events and properties for getting started:
 *
 * Properties:
 *
 * * layer.Message.id: this property is worth being familiar with; it identifies the
 *   Message and can be used in `client.getMessage(id)` to retrieve it
 *   at any time.
 * * layer.Message.internalId: This property makes for a handy unique ID for use in dom nodes.
 *   It is gaurenteed not to change during this session.
 * * layer.Message.isRead: Indicates if the Message has been read yet; set `m.isRead = true`
 *   to tell the client and server that the message has been read.
 * * layer.Message.parts: An array of layer.MessagePart classes representing the contents of the Message.
 * * layer.Message.sentAt: Date the message was sent
 * * layer.Message.sender `userId`: Conversation participant who sent the Message. You may
 *   need to do a lookup on this id in your own servers to find a
 *   displayable name for it.
 *
 * Methods:
 *
 * * layer.Message.send(): Sends the message to the server and the other participants.
 * * layer.Message.on() and layer.Message.off(); event listeners built on top of the `backbone-events-standalone` npm project
 *
 * Events:
 *
 * * `messages:sent`: The message has been received by the server. Can also subscribe to
 *   this event from the layer.Client which is usually simpler.
 *
 * @class  layer.Message
 * @extends layer.Syncable
 */

var Root = require('../root');
var Syncable = require('./syncable');
var MessagePart = require('./message-part');
var LayerError = require('../layer-error');
var Constants = require('../const');
var Util = require('../client-utils');
var Identity = require('./identity');

var Message = function (_Syncable) {
  _inherits(Message, _Syncable);

  /**
   * See layer.Conversation.createMessage()
   *
   * @method constructor
   * @return {layer.Message}
   */
  function Message() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Message);

    // Unless this is a server representation, this is a developer's shorthand;
    // fill in the missing properties around isRead/isUnread before initializing.
    if (!options.fromServer) {
      if ('isUnread' in options) {
        options.isRead = !options.isUnread && !options.is_unread;
        delete options.isUnread;
      } else {
        options.isRead = true;
      }
    } else {
      options.id = options.fromServer.id;
    }

    if (options.client) options.clientId = options.client.appId;
    if (!options.clientId) throw new Error(LayerError.dictionary.clientMissing);

    // Insure __adjustParts is set AFTER clientId is set.
    var parts = options.parts;
    options.parts = null;

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Message).call(this, options));

    _this.parts = parts;

    var client = _this.getClient();
    _this.isInitializing = true;
    if (options && options.fromServer) {
      _this._populateFromServer(options.fromServer);
    } else {
      if (client) _this.sender = client.user;
      _this.sentAt = new Date();
    }

    if (!_this.parts) _this.parts = [];
    return _this;
  }

  /**
   * Turn input into valid layer.MessageParts.
   *
   * This method is automatically called any time the parts
   * property is set (including during intialization).  This
   * is where we convert strings into MessageParts, and instances
   * into arrays.
   *
   * @method __adjustParts
   * @private
   * @param  {Mixed} parts -- Could be a string, array, object or MessagePart instance
   * @return {layer.MessagePart[]}
   */


  _createClass(Message, [{
    key: '__adjustParts',
    value: function __adjustParts(parts) {
      var _this2 = this;

      if (typeof parts === 'string') {
        return [new MessagePart({
          body: parts,
          mimeType: 'text/plain',
          clientId: this.clientId
        })];
      } else if (Array.isArray(parts)) {
        return parts.map(function (part) {
          var result = void 0;
          if (part instanceof MessagePart) {
            result = part;
          } else {
            result = new MessagePart(part);
          }
          result.clientId = _this2.clientId;
          return result;
        });
      } else if (parts && (typeof parts === 'undefined' ? 'undefined' : _typeof(parts)) === 'object') {
        parts.clientId = this.clientId;
        return [new MessagePart(parts)];
      }
    }

    /**
     * Add a layer.MessagePart to this Message.
     *
     * Should only be called on an unsent Message.
     *
     * ```
     * message.addPart({mimeType: 'text/plain', body: 'Frodo really is a Dodo'});
     *
     * // OR
     * message.addPart(new layer.MessagePart({mimeType: 'text/plain', body: 'Frodo really is a Dodo'}));
     * ```
     *
     * @method addPart
     * @param  {layer.MessagePart/Object} part - A layer.MessagePart instance or a `{mimeType: 'text/plain', body: 'Hello'}` formatted Object.
     * @returns {layer.Message} this
     */

  }, {
    key: 'addPart',
    value: function addPart(part) {
      if (part) {
        part.clientId = this.clientId;
        if (part instanceof MessagePart) {
          this.parts.push(part);
        } else if ((typeof part === 'undefined' ? 'undefined' : _typeof(part)) === 'object') {
          this.parts.push(new MessagePart(part));
        }
      }
      return this;
    }

    /**
     * Your unsent Message will show up in Query results and be rendered in Message Lists.
     *
     * This method is only needed for Messages that should show up in a Message List Widget that
     * is driven by Query data, but where the layer.Message.send method has not yet been called.
     *
     * Once you have called `presend` your message should show up in your Message List.  However,
     * typically you want to be able to edit and rerender that Message. After making changes to the Message,
     * you can trigger change events:
     *
     * ```
     * var message = conversation.createMessage({parts: [{mimeType: 'custom/card', body: null}]});
     * message.presend();
     *
     * message.parts[0].body = 'Frodo is a Dodo';
     * message.trigger('messages:change');
     * ```
     *
     * Note that if using Layer UI for Web, the `messages:change` event will trigger an `onRerender` call,
     * not an `onRender` call, so the capacity to handle editing of messages will require the ability to render
     * all possible edits within `onRerender`.
     *
     * It is assumed that at some point either `send()` or `destroy()` will be called on this message
     * to complete or cancel this process.
     *
     * @method presend
     */

  }, {
    key: 'presend',
    value: function presend() {
      var _this3 = this;

      var client = this.getClient();
      if (!client) {
        throw new Error(LayerError.dictionary.clientMissing);
      }

      var conversation = this.getConversation(false);

      if (!conversation) {
        throw new Error(LayerError.dictionary.conversationMissing);
      }

      if (this.syncState !== Constants.SYNC_STATE.NEW) {
        throw new Error(LayerError.dictionary.alreadySent);
      }
      conversation._setupMessage(this);

      // Make sure all data is in the right format for being rendered
      this._readAllBlobs(function () {
        client._addMessage(_this3);
      });
    }

    /**
     * Send the message to all participants of the Conversation.
     *
     * Message must have parts and a valid conversation to send successfully.
     *
     * The send method takes a `notification` object. In normal use, it provides the same notification to ALL
     * recipients, but you can customize notifications on a per recipient basis, as well as embed actions into the notification.
     * For the Full API, see https://developer.layer.com/docs/platform/messages#notification-customization.
     *
     * For the Full API, see [Server Docs](https://developer.layer.com/docs/platform/messages#notification-customization).
     *
     * ```
     * message.send({
     *    title: "New Hobbit Message",
     *    text: "Frodo-the-Dodo: Hello Sam, what say we waltz into Mordor like we own the place?",
     *    sound: "whinyhobbit.aiff"
     * });
     * ```
     *
     * @method send
     * @param {Object} [notification] - Parameters for controling how the phones manage notifications of the new Message.
     *                          See IOS and Android docs for details.
     * @param {string} [notification.title] - Title to show on lock screen and notification bar
     * @param {string} [notification.text] - Text of your notification
     * @param {string} [notification.sound] - Name of an audio file or other sound-related hint
     * @return {layer.Message} this
     */

  }, {
    key: 'send',
    value: function send(notification) {
      var _this4 = this;

      var client = this.getClient();
      if (!client) {
        throw new Error(LayerError.dictionary.clientMissing);
      }

      var conversation = this.getConversation(true);

      if (!conversation) {
        throw new Error(LayerError.dictionary.conversationMissing);
      }

      if (this.syncState !== Constants.SYNC_STATE.NEW) {
        throw new Error(LayerError.dictionary.alreadySent);
      }

      if (conversation.isLoading) {
        conversation.once(conversation.constructor.eventPrefix + ':loaded', function () {
          return _this4.send(notification);
        });
        return this;
      }

      if (!this.parts || !this.parts.length) {
        throw new Error(LayerError.dictionary.partsMissing);
      }

      this._setSyncing();

      // Make sure that the Conversation has been created on the server
      // and update the lastMessage property
      conversation.send(this);

      // If we are sending any File/Blob objects, and their Mime Types match our test,
      // wait until the body is updated to be a string rather than File before calling _addMessage
      // which will add it to the Query Results and pass this on to a renderer that expects "text/plain" to be a string
      // rather than a blob.
      this._readAllBlobs(function () {
        // Calling this will add this to any listening Queries... so position needs to have been set first;
        // handled in conversation.send(this)
        client._addMessage(_this4);

        // allow for modification of message before sending
        _this4.trigger('messages:sending');

        var data = {
          parts: new Array(_this4.parts.length),
          id: _this4.id
        };
        if (notification && _this4.conversationId) data.notification = notification;

        _this4._preparePartsForSending(data);
      });
      return this;
    }

    /**
     * Any MessagePart that contains a textual blob should contain a string before we send.
     *
     * If a MessagePart with a Blob or File as its body were to be added to the Client,
     * The Query would receive this, deliver it to apps and the app would crash.
     * Most rendering code expecting text/plain would expect a string not a File.
     *
     * When this user is sending a file, and that file is textual, make sure
     * its actual text delivered to the UI.
     *
     * @method _readAllBlobs
     * @private
     */

  }, {
    key: '_readAllBlobs',
    value: function _readAllBlobs(callback) {
      var count = 0;
      var parts = this.parts.filter(function (part) {
        return Util.isBlob(part.body) && part.isTextualMimeType();
      });
      parts.forEach(function (part) {
        Util.fetchTextFromFile(part.body, function (text) {
          part.body = text;
          count++;
          if (count === parts.length) callback();
        });
      });
      if (!parts.length) callback();
    }

    /**
     * Insures that each part is ready to send before actually sending the Message.
     *
     * @method _preparePartsForSending
     * @private
     * @param  {Object} structure to be sent to the server
     */

  }, {
    key: '_preparePartsForSending',
    value: function _preparePartsForSending(data) {
      var _this5 = this;

      var client = this.getClient();
      var count = 0;
      this.parts.forEach(function (part, index) {
        part.once('parts:send', function (evt) {
          data.parts[index] = {
            mime_type: evt.mime_type
          };
          if (evt.content) data.parts[index].content = evt.content;
          if (evt.body) data.parts[index].body = evt.body;
          if (evt.encoding) data.parts[index].encoding = evt.encoding;

          count++;
          if (count === _this5.parts.length) {
            _this5._send(data);
          }
        }, _this5);
        part._send(client);
      });
    }

    /**
     * Handle the actual sending.
     *
     * layer.Message.send has some potentially asynchronous
     * preprocessing to do before sending (Rich Content); actual sending
     * is done here.
     *
     * @method _send
     * @private
     */

  }, {
    key: '_send',
    value: function _send(data) {
      var _this6 = this;

      var client = this.getClient();
      var conversation = this.getConversation(false);

      this.sentAt = new Date();
      client.sendSocketRequest({
        method: 'POST',
        body: {
          method: 'Message.create',
          object_id: conversation.id,
          data: data
        },
        sync: {
          depends: [this.conversationId, this.id],
          target: this.id
        }
      }, function (success, socketData) {
        return _this6._sendResult(success, socketData);
      });
    }
  }, {
    key: '_getSendData',
    value: function _getSendData(data) {
      data.object_id = this.conversationId;
      return data;
    }

    /**
      * layer.Message.send() Success Callback.
      *
      * If successfully sending the message; triggers a 'sent' event,
      * and updates the message.id/url
      *
      * @method _sendResult
      * @private
      * @param {Object} messageData - Server description of the message
      */

  }, {
    key: '_sendResult',
    value: function _sendResult(_ref) {
      var success = _ref.success;
      var data = _ref.data;

      if (this.isDestroyed) return;

      if (success) {
        this._populateFromServer(data);
        this._triggerAsync('messages:sent');
        this._triggerAsync('messages:change', {
          property: 'syncState',
          oldValue: Constants.SYNC_STATE.SAVING,
          newValue: Constants.SYNC_STATE.SYNCED
        });
      } else {
        this.trigger('messages:sent-error', { error: data });
        this.destroy();
      }
      this._setSynced();
    }

    /* NOT FOR JSDUCK
     * Standard `on()` provided by layer.Root.
     *
     * Adds some special handling of 'messages:loaded' so that calls such as
     *
     *      var m = client.getMessage('layer:///messages/123', true)
     *      .on('messages:loaded', function() {
     *          myrerender(m);
     *      });
     *      myrender(m); // render a placeholder for m until the details of m have loaded
     *
     * can fire their callback regardless of whether the client loads or has
     * already loaded the Message.
     *
     * @method on
     * @param  {string} eventName
     * @param  {Function} eventHandler
     * @param  {Object} context
     * @return {layer.Message} this
     */

  }, {
    key: 'on',
    value: function on(name, callback, context) {
      var hasLoadedEvt = name === 'messages:loaded' || name && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && name['messages:loaded'];

      if (hasLoadedEvt && !this.isLoading) {
        (function () {
          var callNow = name === 'messages:loaded' ? callback : name['messages:loaded'];
          Util.defer(function () {
            return callNow.apply(context);
          });
        })();
      }
      _get(Object.getPrototypeOf(Message.prototype), 'on', this).call(this, name, callback, context);
      return this;
    }

    /**
     * Remove this Message from the system.
     *
     * This will deregister the Message, remove all events
     * and allow garbage collection.
     *
     * @method destroy
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      var client = this.getClient();
      if (client) client._removeMessage(this);
      this.parts.forEach(function (part) {
        return part.destroy();
      });
      this.__parts = null;

      _get(Object.getPrototypeOf(Message.prototype), 'destroy', this).call(this);
    }

    /**
     * Populates this instance with the description from the server.
     *
     * Can be used for creating or for updating the instance.
     *
     * @method _populateFromServer
     * @protected
     * @param  {Object} m - Server description of the message
     */

  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(message) {
      var _this7 = this;

      this._inPopulateFromServer = true;
      var client = this.getClient();

      this.id = message.id;
      this.url = message.url;
      var oldPosition = this.position;
      this.position = message.position;

      // Assign IDs to preexisting Parts so that we can call getPartById()
      if (this.parts) {
        this.parts.forEach(function (part, index) {
          if (!part.id) part.id = _this7.id + '/parts/' + index;
        });
      }

      this.parts = message.parts.map(function (part) {
        var existingPart = _this7.getPartById(part.id);
        if (existingPart) {
          existingPart._populateFromServer(part);
          return existingPart;
        } else {
          return MessagePart._createFromServer(part);
        }
      });

      this.recipientStatus = message.recipient_status || {};

      this.isRead = 'is_unread' in message ? !message.is_unread : true;

      this.sentAt = new Date(message.sent_at);
      this.receivedAt = message.received_at ? new Date(message.received_at) : undefined;

      var sender = void 0;
      if (message.sender.id) {
        sender = client.getIdentity(message.sender.id);
      }

      // Because there may be no ID, we have to bypass client._createObject and its switch statement.
      if (!sender) {
        sender = Identity._createFromServer(message.sender, client);
      }
      this.sender = sender;

      this._setSynced();

      if (oldPosition && oldPosition !== this.position) {
        this._triggerAsync('messages:change', {
          oldValue: oldPosition,
          newValue: this.position,
          property: 'position'
        });
      }
      this._inPopulateFromServer = false;
    }

    /**
     * Returns the Message's layer.MessagePart with the specified the part ID.
     *
     * ```
     * var part = client.getMessagePart('layer:///messages/6f08acfa-3268-4ae5-83d9-6ca00000000/parts/0');
     * ```
     *
     * @method getPartById
     * @param {string} partId
     * @return {layer.MessagePart}
     */

  }, {
    key: 'getPartById',
    value: function getPartById(partId) {
      var part = this.parts ? this.parts.filter(function (aPart) {
        return aPart.id === partId;
      })[0] : null;
      return part || null;
    }

    /**
     * Accepts json-patch operations for modifying recipientStatus.
     *
     * @method _handlePatchEvent
     * @private
     * @param  {Object[]} data - Array of operations
     */

  }, {
    key: '_handlePatchEvent',
    value: function _handlePatchEvent(newValue, oldValue, paths) {
      this._inLayerParser = false;
      if (paths[0].indexOf('recipient_status') === 0) {
        this.__updateRecipientStatus(this.recipientStatus, oldValue);
      }
      this._inLayerParser = true;
    }

    /**
     * Returns absolute URL for this resource.
     * Used by sync manager because the url may not be known
     * at the time the sync request is enqueued.
     *
     * @method _getUrl
     * @param {String} url - relative url and query string parameters
     * @return {String} full url
     * @private
     */

  }, {
    key: '_getUrl',
    value: function _getUrl(url) {
      return this.url + (url || '');
    }
  }, {
    key: '_setupSyncObject',
    value: function _setupSyncObject(sync) {
      if (sync !== false) {
        sync = _get(Object.getPrototypeOf(Message.prototype), '_setupSyncObject', this).call(this, sync);
        if (!sync.depends) {
          sync.depends = [this.conversationId];
        } else if (sync.depends.indexOf(this.id) === -1) {
          sync.depends.push(this.conversationId);
        }
      }
      return sync;
    }

    /**
     * Get all text parts of the Message.
     *
     * Utility method for extracting all of the text/plain parts
     * and concatenating all of their bodys together into a single string.
     *
     * @method getText
     * @param {string} [joinStr='.  '] If multiple message parts of type text/plain, how do you want them joined together?
     * @return {string}
     */

  }, {
    key: 'getText',
    value: function getText() {
      var joinStr = arguments.length <= 0 || arguments[0] === undefined ? '. ' : arguments[0];

      var textArray = this.parts.filter(function (part) {
        return part.mimeType === 'text/plain';
      }).map(function (part) {
        return part.body;
      });
      textArray = textArray.filter(function (data) {
        return data;
      });
      return textArray.join(joinStr);
    }

    /**
     * Returns a plain object.
     *
     * Object will have all the same public properties as this
     * Message instance.  New object is returned any time
     * any of this object's properties change.
     *
     * @method toObject
     * @return {Object} POJO version of this object.
     */

  }, {
    key: 'toObject',
    value: function toObject() {
      if (!this._toObject) {
        this._toObject = _get(Object.getPrototypeOf(Message.prototype), 'toObject', this).call(this);
      }
      return this._toObject;
    }
  }, {
    key: '_triggerAsync',
    value: function _triggerAsync(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Message.prototype), '_triggerAsync', this).call(this, evtName, args);
    }
  }, {
    key: 'trigger',
    value: function trigger(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Message.prototype), 'trigger', this).call(this, evtName, args);
    }

    /**
     * Identifies whether a Message receiving the specified patch data should be loaded from the server.
     *
     * Applies only to Messages that aren't already loaded; used to indicate if a change event is
     * significant enough to load the Message and trigger change events on that Message.
     *
     * At this time there are no properties that are patched on Messages via websockets
     * that would justify loading the Message from the server so as to notify the app.
     *
     * Only recipient status changes and maybe is_unread changes are sent;
     * neither of which are relevant to an app that isn't rendering that message.
     *
     * @method _loadResourceForPatch
     * @static
     * @private
     */

  }], [{
    key: '_loadResourceForPatch',
    value: function _loadResourceForPatch(patchData) {
      return false;
    }
  }]);

  return Message;
}(Syncable);

/**
 * Client that the Message belongs to.
 *
 * Actual value of this string matches the appId.
 * @type {string}
 * @readonly
 */


Message.prototype.clientId = '';

/**
 * Conversation ID or Channel ID that this Message belongs to.
 *
 * @type {string}
 * @readonly
 */
Message.prototype.conversationId = '';

/**
 * Array of layer.MessagePart objects.
 *
 * Use layer.Message.addPart to modify this array.
 *
 * @type {layer.MessagePart[]}
 * @readonly
 */
Message.prototype.parts = null;

/**
 * Time that the message was sent.
 *
 *  Note that a locally created layer.Message will have a `sentAt` value even
 * though its not yet sent; this is so that any rendering code doesn't need
 * to account for `null` values.  Sending the Message may cause a slight change
 * in the `sentAt` value.
 *
 * @type {Date}
 * @readonly
 */
Message.prototype.sentAt = null;

/**
 * Time that the first delivery receipt was sent by your
 * user acknowledging receipt of the message.
 * @type {Date}
 * @readonly
 */
Message.prototype.receivedAt = null;

/**
 * Identity object representing the sender of the Message.
 *
 * Most commonly used properties of Identity are:
 * * displayName: A name for your UI
 * * userId: Name for the user as represented on your system
 * * name: Represents the name of a service if the sender was an automated system.
 *
 *      <span class='sent-by'>
 *        {message.sender.displayName || message.sender.name}
 *      </span>
 *
 * @type {layer.Identity}
 * @readonly
 */
Message.prototype.sender = null;

/**
 * Position of this message within the conversation.
 *
 * NOTES:
 *
 * 1. Deleting a message does not affect position of other Messages.
 * 2. A position is not gaurenteed to be unique (multiple messages sent at the same time could
 * all claim the same position)
 * 3. Each successive message within a conversation should expect a higher position.
 *
 * @type {Number}
 * @readonly
 */
Message.prototype.position = 0;

/**
 * Hint used by layer.Client on whether to trigger a messages:notify event.
 *
 * @type {boolean}
 * @private
 */
Message.prototype._notify = false;

/**
 * This property is here for convenience only; it will always be the opposite of isRead.
 * @type {Boolean}
 * @readonly
 */
Object.defineProperty(Message.prototype, 'isUnread', {
  enumerable: true,
  get: function get() {
    return !this.isRead;
  }
});

Message.prototype._toObject = null;

Message.prototype._inPopulateFromServer = false;

Message.eventPrefix = 'messages';

Message.eventPrefix = 'messages';

Message.prefixUUID = 'layer:///messages/';

Message.inObjectIgnore = Syncable.inObjectIgnore;

Message.bubbleEventParent = 'getClient';

Message.imageTypes = ['image/gif', 'image/png', 'image/jpeg', 'image/jpg'];

Message._supportedEvents = [

/**
 * Message has been loaded from the server.
 *
 * Note that this is only used in response to the layer.Message.load() method.
 *
 * ```
 * var m = client.getMessage('layer:///messages/123', true)
 *    .on('messages:loaded', function() {
 *        myrerender(m);
 *    });
 * myrender(m); // render a placeholder for m until the details of m have loaded
 * ```
 *
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:loaded',

/**
 * The load method failed to load the message from the server.
 *
 * Note that this is only used in response to the layer.Message.load() method.
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:loaded-error',

/**
 * Message deleted from the server.
 *
 * Caused by a call to layer.Message.delete() or a websocket event.
 * @param {layer.LayerEvent} evt
 * @event
 */
'messages:delete',

/**
 * Message is about to be sent.
 *
 * Last chance to modify or validate the message prior to sending.
 *
 *     message.on('messages:sending', function(evt) {
 *        message.addPart({mimeType: 'application/location', body: JSON.stringify(getGPSLocation())});
 *     });
 *
 * Typically, you would listen to this event more broadly using `client.on('messages:sending')`
 * which would trigger before sending ANY Messages.
 *
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:sending',

/**
 * Message has been received by the server.
 *
 * It does NOT indicate delivery to other users.
 *
 * It does NOT indicate messages sent by other users.
 *
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:sent',

/**
 * Server failed to receive the Message.
 *
 * Message will be deleted immediately after firing this event.
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.LayerError} evt.error
 */
'messages:sent-error',

/**
 * The recipientStatus property has changed.
 *
 * This happens in response to an update
 * from the server... but is also caused by marking the current user as having read
 * or received the message.
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:change'].concat(Syncable._supportedEvents);

Root.initClass.apply(Message, [Message, 'Message']);
Syncable.subclasses.push(Message);
module.exports = Message;


},{"../client-utils":82,"../const":84,"../layer-error":86,"../root":116,"./identity":102,"./message-part":104,"./syncable":106}],106:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Syncable abstract clas represents resources that are syncable with the server.
 * This is currently used for Messages and Conversations.
 * It represents the state of the object's sync, as one of:
 *
 *  * layer.Constants.SYNC_STATE.NEW: Newly created; local only.
 *  * layer.Constants.SYNC_STATE.SAVING: Newly created; being sent to the server
 *  * layer.Constants.SYNC_STATE.SYNCING: Exists on both client and server, but changes are being sent to server.
 *  * layer.Constants.SYNC_STATE.SYNCED: Exists on both client and server and is synced.
 *  * layer.Constants.SYNC_STATE.LOADING: Exists on server; loading it into client.
 *
 * @class layer.Syncable
 * @extends layer.Root
 * @abstract
 */

var Root = require('../root');

var _require = require('../const');

var SYNC_STATE = _require.SYNC_STATE;

var LayerError = require('../layer-error');
var ClientRegistry = require('../client-registry');
var Constants = require('../const');

var Syncable = function (_Root) {
  _inherits(Syncable, _Root);

  function Syncable() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Syncable);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Syncable).call(this, options));

    _this.localCreatedAt = new Date();
    return _this;
  }

  /**
   * Get the client associated with this Object.
   *
   * @method getClient
   * @return {layer.Client}
   */


  _createClass(Syncable, [{
    key: 'getClient',
    value: function getClient() {
      return ClientRegistry.get(this.clientId);
    }

    /**
     * Fire an XHR request using the URL for this resource.
     *
     * For more info on xhr method parameters see {@link layer.ClientAuthenticator#xhr}
     *
     * @method _xhr
     * @protected
     * @return {layer.Syncable} this
     */

  }, {
    key: '_xhr',
    value: function _xhr(options, callback) {
      var _this2 = this;

      // initialize
      if (!options.url) options.url = '';
      if (!options.method) options.method = 'GET';
      var client = this.getClient();

      // Validatation
      if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);
      if (!client) throw new Error(LayerError.dictionary.clientMissing);
      if (!this.constructor.enableOpsIfNew && options.method !== 'POST' && options.method !== 'GET' && this.syncState === Constants.SYNC_STATE.NEW) return this;

      if (!options.url.match(/^http(s):\/\//)) {
        if (options.url && !options.url.match(/^(\/|\?)/)) options.url = '/' + options.url;
        if (!options.sync) options.url = this.url + options.url;
      }

      // Setup sync structure
      options.sync = this._setupSyncObject(options.sync);

      if (options.method !== 'GET') {
        this._setSyncing();
      }

      client.xhr(options, function (result) {
        if (result.success && options.method !== 'GET' && !_this2.isDestroyed) {
          _this2._setSynced();
        }
        if (callback) callback(result);
      });
      return this;
    }

    /**
     * Setup an object to pass in the `sync` parameter for any sync requests.
     *
     * @method _setupSyncObject
     * @private
     * @param {Object} sync - Known parameters of the sync object to be returned; or null.
     * @return {Object} fleshed out sync object
     */

  }, {
    key: '_setupSyncObject',
    value: function _setupSyncObject(sync) {
      if (sync !== false) {
        if (!sync) sync = {};
        if (!sync.target) sync.target = this.id;
      }
      return sync;
    }

    /**
     * A websocket event has been received specifying that this resource
     * has been deleted.
     *
     * @method handleWebsocketDelete
     * @protected
     * @param {Object} data
     */

  }, {
    key: '_handleWebsocketDelete',
    value: function _handleWebsocketDelete(data) {
      this._deleted();
      this.destroy();
    }

    /**
     * The Object has been deleted.
     *
     * Destroy must be called separately, and handles most cleanup.
     *
     * @method _deleted
     * @protected
     */

  }, {
    key: '_deleted',
    value: function _deleted() {
      this.trigger(this.constructor.eventPrefix + ':delete');
    }

    /**
     * Load the resource identified via a Layer ID.
     *
     * Will load the requested resource from persistence or server as needed,
     * and trigger `type-name:loaded` when its loaded.  Instance returned by this
     * method will have only ID and URL properties, all others are unset until
     * the `conversations:loaded`, `messages:loaded`, etc... event has fired.
     *
     * ```
     * var message = layer.Message.load(messageId, client);
     * message.once('messages:loaded', function(evt) {
     *    alert("Message loaded");
     * });
     * ```
     *
     * @method load
     * @static
     * @param {string} id - `layer:///messages/UUID`
     * @param {layer.Client} client
     * @return {layer.Syncable} - Returns an empty object that will be populated once data is loaded.
     */

  }, {
    key: '_load',


    /**
     * Load this resource from the server.
     *
     * Called from the static layer.Syncable.load() method
     *
     * @method _load
     * @private
     */
    value: function _load() {
      var _this3 = this;

      this.syncState = SYNC_STATE.LOADING;
      this._xhr({
        method: 'GET',
        sync: false
      }, function (result) {
        return _this3._loadResult(result);
      });
    }
  }, {
    key: '_loadResult',
    value: function _loadResult(result) {
      var _this4 = this;

      if (this.isDestroyed) return;
      var prefix = this.constructor.eventPrefix;
      if (!result.success) {
        this.syncState = SYNC_STATE.NEW;
        this._triggerAsync(prefix + ':loaded-error', { error: result.data });
        setTimeout(function () {
          if (!_this4.isDestroyed) _this4.destroy();
        }, 100); // Insure destroyed AFTER loaded-error event has triggered
      } else {
        this._populateFromServer(result.data);
        this._loaded(result.data);
        this.trigger(prefix + ':loaded');
      }
    }

    /**
     * Processing the result of a _load() call.
     *
     * Typically used to register the object and cleanup any properties not handled by _populateFromServer.
     *
     * @method _loaded
     * @private
     * @param  {Object} data - Response data from server
     */

  }, {
    key: '_loaded',
    value: function _loaded(data) {}

    /**
     * Object is new, and is queued for syncing, but does not yet exist on the server.
     *
     * That means it is currently out of sync with the server.
     *
     * @method _setSyncing
     * @private
     */

  }, {
    key: '_setSyncing',
    value: function _setSyncing() {
      this._clearObject();
      switch (this.syncState) {
        case SYNC_STATE.SYNCED:
          this.syncState = SYNC_STATE.SYNCING;
          break;
        case SYNC_STATE.NEW:
          this.syncState = SYNC_STATE.SAVING;
          break;
      }
      this._syncCounter++;
    }

    /**
     * Object is synced with the server and up to date.
     *
     * @method _setSynced
     * @private
     */

  }, {
    key: '_setSynced',
    value: function _setSynced() {
      this._clearObject();
      if (this._syncCounter > 0) this._syncCounter--;

      this.syncState = this._syncCounter === 0 ? SYNC_STATE.SYNCED : SYNC_STATE.SYNCING;
      this.isSending = false;
    }

    /**
     * Any time the instance changes, we should clear the cached toObject value
     *
     * @method _clearObject
     * @private
     */

  }, {
    key: '_clearObject',
    value: function _clearObject() {
      this._toObject = null;
    }

    /**
     * Returns a plain object.
     *
     * Object will have all the same public properties as this
     * Syncable instance.  New object is returned any time
     * any of this object's properties change.
     *
     * @method toObject
     * @return {Object} POJO version of this object.
     */

  }, {
    key: 'toObject',
    value: function toObject() {
      if (!this._toObject) {
        this._toObject = _get(Object.getPrototypeOf(Syncable.prototype), 'toObject', this).call(this);
        this._toObject.isNew = this.isNew();
        this._toObject.isSaving = this.isSaving();
        this._toObject.isSaved = this.isSaved();
        this._toObject.isSynced = this.isSynced();
      }
      return this._toObject;
    }

    /**
     * Object is new, and is not yet queued for syncing
     *
     * @method isNew
     * @returns {boolean}
     */

  }, {
    key: 'isNew',
    value: function isNew() {
      return this.syncState === SYNC_STATE.NEW;
    }

    /**
     * Object is new, and is queued for syncing
     *
     * @method isSaving
     * @returns {boolean}
     */

  }, {
    key: 'isSaving',
    value: function isSaving() {
      return this.syncState === SYNC_STATE.SAVING;
    }

    /**
     * Object exists on server.
     *
     * @method isSaved
     * @returns {boolean}
     */

  }, {
    key: 'isSaved',
    value: function isSaved() {
      return !(this.isNew() || this.isSaving());
    }

    /**
     * Object is fully synced.
     *
     * As best we know, server and client have the same values.
     *
     * @method isSynced
     * @returns {boolean}
     */

  }, {
    key: 'isSynced',
    value: function isSynced() {
      return this.syncState === SYNC_STATE.SYNCED;
    }
  }], [{
    key: 'load',
    value: function load(id, client) {
      if (!client || !(client instanceof Root)) throw new Error(LayerError.dictionary.clientMissing);
      if (!client.isReady) throw new Error(LayerError.dictionary.clientMustBeReady);

      var obj = {
        id: id,
        url: client.url + id.substring(8),
        clientId: client.appId
      };

      if (!Syncable.sortedSubclasses) {
        Syncable.sortedSubclasses = Syncable.subclasses.filter(function (item) {
          return item.prefixUUID;
        }).sort(function (a, b) {
          return a.prefixUUID.length - b.prefixUUID.length;
        });
      }

      var ConstructorClass = Syncable.sortedSubclasses.filter(function (aClass) {
        if (aClass.prefixUUID.indexOf('layer:///') === 0) {
          return obj.id.indexOf(aClass.prefixUUID) === 0;
        } else {
          return obj.id.indexOf(aClass.prefixUUID) !== -1;
        }
      })[0];
      var syncItem = new ConstructorClass(obj);
      var typeName = ConstructorClass.eventPrefix;

      if (typeName) {
        client.dbManager.getObject(typeName, id, function (item) {
          if (syncItem.isDestroyed) return;
          if (item) {
            syncItem._populateFromServer(item);
            syncItem.trigger(typeName + ':loaded');
          } else {
            syncItem._load();
          }
        });
      } else {
        syncItem._load();
      }

      syncItem.syncState = SYNC_STATE.LOADING;
      return syncItem;
    }
  }]);

  return Syncable;
}(Root);

/**
 * Unique identifier.
 *
 * @type {string}
 */


Syncable.prototype.id = '';

/**
 * URL to access the object on the server.
 *
 * @type {string}
 * @readonly
 * @protected
 */
Syncable.prototype.url = '';

/**
 * The time that this client created this instance.
 *
 * This value is not tied to when it was first created on the server.  Creating a new instance
 * based on server data will result in a new `localCreateAt` value.
 *
 * @type {Date}
 */
Syncable.prototype.localCreatedAt = null;

/**
 * layer.Client that the object belongs to.
 *
 * Actual value of this string matches the appId.
 * @type {string}
 * @protected
 * @readonly
 */
Syncable.prototype.clientId = '';

/**
 * Temporary property indicating that the instance was loaded from local database rather than server.
 *
 * @type {boolean}
 * @private
 */
Syncable.prototype._fromDB = false;

/**
 * The current sync state of this object.
 *
 * Possible values are:
 *
 *  * layer.Constants.SYNC_STATE.NEW: Newly created; local only.
 *  * layer.Constants.SYNC_STATE.SAVING: Newly created; being sent to the server
 *  * layer.Constants.SYNC_STATE.SYNCING: Exists on both client and server, but changes are being sent to server.
 *  * layer.Constants.SYNC_STATE.SYNCED: Exists on both client and server and is synced.
 *  * layer.Constants.SYNC_STATE.LOADING: Exists on server; loading it into client.
 *
 * @type {string}
 */
Syncable.prototype.syncState = SYNC_STATE.NEW;

/**
 * Number of sync requests that have been requested.
 *
 * Counts down to zero; once it reaches zero, all sync
 * requests have been completed.
 *
 * @type {Number}
 * @private
 */
Syncable.prototype._syncCounter = 0;

/**
 * Prefix to use when triggering events
 * @private
 * @static
 */
Syncable.eventPrefix = '';

Syncable.enableOpsIfNew = false;

/**
 * Is the object loading from the server?
 *
 * @type {boolean}
 */
Object.defineProperty(Syncable.prototype, 'isLoading', {
  enumerable: true,
  get: function get() {
    return this.syncState === SYNC_STATE.LOADING;
  }
});

/**
 * Array of classes that are subclasses of Syncable.
 *
 * Used by Factory function.
 * @private
 */
Syncable.subclasses = [];

Syncable._supportedEvents = [].concat(Root._supportedEvents);
Syncable.inObjectIgnore = Root.inObjectIgnore;
module.exports = Syncable;


},{"../client-registry":81,"../const":84,"../layer-error":86,"../root":116}],107:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This class manages a state variable for whether we are online/offline, triggers events
 * when the state changes, and determines when to perform tests to validate our online status.
 *
 * It performs the following tasks:
 *
 * 1. Any time we go more than this.pingFrequency (100 seconds) without any data from the server, flag us as being offline.
 *    Rationale: The websocket manager is calling `getCounter` every 30 seconds; so it would have had to fail to get any response
 *    3 times before we give up.
 * 2. While we are offline, ping the server until we determine we are in fact able to connect to the server
 * 3. Trigger events `connected` and `disconnected` to let the rest of the system know when we are/are not connected.
 *    NOTE: The Websocket manager will use that to reconnect its websocket, and resume its `getCounter` call every 30 seconds.
 *
 * NOTE: Apps that want to be notified of changes to online/offline state should see layer.Client's `online` event.
 *
 * NOTE: One iteration of this class treated navigator.onLine = false as fact.  If onLine is false, then we don't need to test
 * anything.  If its true, then this class verifies it can reach layer's servers.  However, https://code.google.com/p/chromium/issues/detail?id=277372 has replicated multiple times in chrome; this bug causes one tab of chrome to have navigator.onLine=false while all other tabs
 * correctly report navigator.onLine=true.  As a result, we can't rely on this value and this class must continue to poll the server while
 * offline and to ignore values from navigator.onLine.  Future Work: Allow non-chrome browsers to use navigator.onLine.
 *
 * @class  layer.OnlineStateManager
 * @private
 * @extends layer.Root
 *
 */
var Root = require('./root');
var xhr = require('./xhr');
var logger = require('./logger');
var Utils = require('./client-utils');

var _require = require('./const');

var ACCEPT = _require.ACCEPT;

var OnlineStateManager = function (_Root) {
  _inherits(OnlineStateManager, _Root);

  /**
   * Creates a new OnlineStateManager.
   *
   * An Application is expected to only have one of these.
   *
   *      var onlineStateManager = new layer.OnlineStateManager({
   *          socketManager: socketManager,
   *          testUrl: 'https://api.layer.com/nonces'
   *      });
   *
   * @method constructor
   * @param  {Object} options
   * @param  {layer.Websockets.SocketManager} options.socketManager - A websocket manager to monitor for messages
   * @param  {string} options.testUrl - A url to send requests to when testing if we are online
   */
  function OnlineStateManager(options) {
    _classCallCheck(this, OnlineStateManager);

    // Listen to all xhr events and websocket messages for online-status info
    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(OnlineStateManager).call(this, options));

    xhr.addConnectionListener(function (evt) {
      return _this._connectionListener(evt);
    });
    _this.socketManager.on('message', function () {
      return _this._connectionListener({ status: 'connection:success' });
    }, _this);

    // Any change in online status reported by the browser should result in
    // an immediate update to our online/offline state
    /* istanbul ignore else */
    if (typeof window !== 'undefined') {
      window.addEventListener('online', _this._handleOnlineEvent.bind(_this));
      window.addEventListener('offline', _this._handleOnlineEvent.bind(_this));
    }
    return _this;
  }

  /**
   * We don't actually start managing our online state until after the client has authenticated.
   * Call start() when we are ready for the client to start managing our state.
   *
   * The client won't call start() without first validating that we have a valid session, so by definition,
   * calling start means we are online.
   *
   * @method start
   */


  _createClass(OnlineStateManager, [{
    key: 'start',
    value: function start() {
      logger.info('OnlineStateManager: start');
      this.isClientReady = true;
      this.isOnline = true;

      this.checkOnlineStatus();
    }

    /**
     * If the client becomes unauthenticated, stop checking if we are online, and announce that we are offline.
     *
     * @method stop
     */

  }, {
    key: 'stop',
    value: function stop() {
      logger.info('OnlineStateManager: stop');
      this.isClientReady = false;
      this._clearCheck();
      this._changeToOffline();
    }

    /**
     * Schedules our next call to _onlineExpired if online or checkOnlineStatus if offline.
     *
     * @method _scheduleNextOnlineCheck
     * @private
     */

  }, {
    key: '_scheduleNextOnlineCheck',
    value: function _scheduleNextOnlineCheck(connectionFailure, callback) {
      logger.debug('OnlineStateManager: skip schedule');
      if (this.isDestroyed || !this.isClientReady) return;

      // Replace any scheduled calls with the newly scheduled call:
      this._clearCheck();

      // If this is called while we are online, then we are using this to detect when we've gone without data for more than pingFrequency.
      // Call this._onlineExpired after pingFrequency of no server responses.
      if (!connectionFailure) {
        logger.debug('OnlineStateManager: Scheduled onlineExpired');
        this.onlineCheckId = setTimeout(this._onlineExpired.bind(this), this.pingFrequency);
      }

      // If this is called while we are offline, we're doing exponential backoff pinging the server to see if we've come back online.
      else {
          logger.info('OnlineStateManager: Scheduled checkOnlineStatus');
          var duration = Utils.getExponentialBackoffSeconds(this.maxOfflineWait, Math.min(10, this.offlineCounter++));
          this.onlineCheckId = setTimeout(this.checkOnlineStatus.bind(this, callback), Math.floor(duration * 1000));
        }
    }

    /**
     * Cancels any upcoming calls to checkOnlineStatus
     *
     * @method _clearCheck
     * @private
     */

  }, {
    key: '_clearCheck',
    value: function _clearCheck() {
      if (this.onlineCheckId) {
        clearTimeout(this.onlineCheckId);
        this.onlineCheckId = 0;
      }
    }

    /**
     * Respond to the browser's online/offline events.
     *
     * Our response is not to trust them, but to use them as
     * a trigger to indicate we should immediately do our own
     * validation.
     *
     * @method _handleOnlineEvent
     * @private
     * @param  {Event} evt - Browser online/offline event object
     */

  }, {
    key: '_handleOnlineEvent',
    value: function _handleOnlineEvent(evt) {
      // Reset the counter because our first request may fail as they may not be
      // fully connected yet
      this.offlineCounter = 0;
      this.checkOnlineStatus();
    }

    /**
     * Our online state has expired; we are now offline.
     *
     * If this method gets called, it means that our connection has gone too long without any data
     * and is now considered to be disconnected.  Start scheduling tests to see when we are back online.
     *
     * @method _onlineExpired
     * @private
     */

  }, {
    key: '_onlineExpired',
    value: function _onlineExpired() {
      this._clearCheck();
      this._changeToOffline();
      this._scheduleNextOnlineCheck();
    }

    /**
     * Get a nonce to see if we can reach the server.
     *
     * We don't care about the result,
     * we just care about triggering a 'connection:success' or 'connection:error' event
     * which connectionListener will respond to.
     *
     *      client.onlineManager.checkOnlineStatus(function(result) {
     *          alert(result ? 'We're online!' : 'Doh!');
     *      });
     *
     * @method checkOnlineStatus
     * @param {Function} callback
     * @param {boolean} callback.isOnline - Callback is called with true if online, false if not
     */

  }, {
    key: 'checkOnlineStatus',
    value: function checkOnlineStatus(callback) {
      this._clearCheck();

      logger.info('OnlineStateManager: Firing XHR for online check');
      this._lastCheckOnlineStatus = new Date();
      // Ping the server and see if we're connected.
      xhr({
        url: this.socketManager.client.url + '/?action=validateIsOnline&client=' + this.socketManager.client.constructor.version,
        method: 'GET',
        headers: {
          accept: ACCEPT
        }
      }, function (_ref) {
        var status = _ref.status;

        // this.isOnline will be updated via _connectionListener prior to this line executing
        if (callback) callback(status !== 408);
      });
    }

    /**
     * On determining that we are offline, handles the state transition and logging.
     *
     * @method _changeToOffline
     * @private
     */

  }, {
    key: '_changeToOffline',
    value: function _changeToOffline() {
      if (this.isOnline) {
        this.isOnline = false;
        this.trigger('disconnected');
        logger.info('OnlineStateManager: Connection lost');
      }
    }

    /**
     * Called whenever a websocket event arrives, or an xhr call completes; updates our isOnline state.
     *
     * Any call to this method will reschedule our next is-online test
     *
     * @method _connectionListener
     * @private
     * @param  {string} evt - Name of the event; either 'connection:success' or 'connection:error'
     */

  }, {
    key: '_connectionListener',
    value: function _connectionListener(evt) {
      var _this2 = this;

      // If event is a success, change us to online
      var failed = evt.status !== 'connection:success';
      if (!failed) {
        var lastTime = this.lastMessageTime;
        this.lastMessageTime = new Date();
        if (!this.isOnline) {
          this.isOnline = true;
          this.offlineCounter = 0;
          this.trigger('connected', { offlineDuration: lastTime ? Date.now() - lastTime : 0 });
          if (this.connectedCounter === undefined) this.connectedCounter = 0;
          this.connectedCounter++;
          logger.info('OnlineStateManager: Connected restored');
        }
      }

      this._scheduleNextOnlineCheck(failed, function (result) {
        if (!result) _this2._changeToOffline();
      });
    }

    /**
     * Cleanup/shutdown
     *
     * @method destroy
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this._clearCheck();
      this.socketManager = null;
      _get(Object.getPrototypeOf(OnlineStateManager.prototype), 'destroy', this).call(this);
    }
  }]);

  return OnlineStateManager;
}(Root);

OnlineStateManager.prototype.isClientReady = false;

/**
 * URL To fire when testing to see if we are online.
 * @type {String}
 */
OnlineStateManager.prototype.testUrl = '';

/**
 * A Websocket manager whose 'message' event we will listen to
 * in order to know that we are still online.
 * @type {layer.Websockets.SocketManager}
 */
OnlineStateManager.prototype.socketManager = null;

/**
 * Number of testUrl requests we've been offline for.
 *
 * Will stop growing once the number is suitably large (10-20).
 * @type {Number}
 */
OnlineStateManager.prototype.offlineCounter = 0;

/**
 * Maximum wait during exponential backoff while offline.
 *
 * While offline, exponential backoff is used to calculate how long to wait between checking with the server
 * to see if we are online again. This value determines the maximum wait; any higher value returned by exponential backoff
 * are ignored and this value used instead.
 * Value is measured in seconds.
 * @type {Number}
 */
OnlineStateManager.prototype.maxOfflineWait = 5 * 60;

/**
 * Minimum wait between tries in ms.
 * @type {Number}
 */
OnlineStateManager.prototype.minBackoffWait = 100;

/**
 * Time that the last successful message was observed.
 * @type {Date}
 */
OnlineStateManager.prototype.lastMessageTime = null;

/**
 * For debugging, tracks the last time we checked if we are online.
 * @type {Date}
 */
OnlineStateManager.prototype._lastCheckOnlineStatus = null;

/**
 * Are we currently online?
 * @type {Boolean}
 */
OnlineStateManager.prototype.isOnline = false;

/**
 * setTimeoutId for the next checkOnlineStatus() call.
 * @type {Number}
 */
OnlineStateManager.prototype.onlineCheckId = 0;

/**
 * If we are online, how often do we need to ping to verify we are still online.
 *
 * Value is reset any time we observe any messages from the server.
 * Measured in miliseconds. NOTE: Websocket has a separate ping which mostly makes
 * this one unnecessary.  May end up removing this one... though we'd keep the
 * ping for when our state is offline.
 * @type {Number}
 */
OnlineStateManager.prototype.pingFrequency = 100 * 1000;

OnlineStateManager._supportedEvents = [
/**
 * We appear to be online and able to send and receive
 * @event connected
 * @param {number} onlineDuration - Number of miliseconds since we were last known to be online
 */
'connected',

/**
 * We appear to be offline and unable to send or receive
 * @event disconnected
 */
'disconnected'].concat(Root._supportedEvents);
Root.initClass.apply(OnlineStateManager, [OnlineStateManager, 'OnlineStateManager']);
module.exports = OnlineStateManager;


},{"./client-utils":82,"./const":84,"./logger":88,"./root":116,"./xhr":126}],108:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Query class for running a Query on Announcements
 *
 *      var announcementQuery = client.createQuery({
 *        client: client,
 *        model: layer.Query.Announcement
 *      });
 *
 *
 * You can change the `paginationWindow` property at any time using:
 *
 *      query.update({
 *        paginationWindow: 200
 *      });
 *
 * You can release data held in memory by your queries when done with them:
 *
 *      query.destroy();
 *
 * @class  layer.AnnouncementsQuery
 * @extends layer.Query
 */
var Root = require('../root');
var Query = require('./query');
var MessagesQuery = require('./messages-query');

var AnnouncementsQuery = function (_MessagesQuery) {
  _inherits(AnnouncementsQuery, _MessagesQuery);

  function AnnouncementsQuery() {
    _classCallCheck(this, AnnouncementsQuery);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(AnnouncementsQuery).apply(this, arguments));
  }

  _createClass(AnnouncementsQuery, [{
    key: '_fixPredicate',
    value: function _fixPredicate(inValue) {
      return Query.prototype._fixPredicate.apply(this, [inValue]);
    }
  }, {
    key: '_fetchData',
    value: function _fetchData(pageSize) {
      var _this2 = this;

      // Retrieve data from db cache in parallel with loading data from server
      this.client.dbManager.loadAnnouncements(this._nextDBFromId, pageSize, function (messages) {
        if (messages.length) _this2._appendResults({ data: messages }, true);
      });

      var newRequest = 'announcements?page_size=' + pageSize + (this._nextServerFromId ? '&from_id=' + this._nextServerFromId : '');

      // Don't repeat still firing queries
      if (newRequest !== this._firingRequest) {
        this.isFiring = true;
        this._firingRequest = newRequest;
        this.client.xhr({
          url: newRequest,
          method: 'GET',
          sync: false
        }, function (results) {
          return _this2._processRunResults(results, newRequest, pageSize);
        });
      }
    }
  }]);

  return AnnouncementsQuery;
}(MessagesQuery);

AnnouncementsQuery._supportedEvents = [].concat(MessagesQuery._supportedEvents);

AnnouncementsQuery.MaxPageSize = 100;

AnnouncementsQuery.prototype.model = Query.Announcement;

Root.initClass.apply(AnnouncementsQuery, [AnnouncementsQuery, 'AnnouncementsQuery']);

module.exports = AnnouncementsQuery;


},{"../root":116,"./messages-query":113,"./query":115}],109:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Query class for running a Query on Channels
 *
 *      var channelQuery = client.createQuery({
 *        client: client,
 *        model: layer.Query.Channel
 *      });
 *
 *
 * You can change the `paginationWindow` property at any time using:
 *
 *      query.update({
 *        paginationWindow: 200
 *      });
 *
 * You can release data held in memory by your queries when done with them:
 *
 *      query.destroy();
 *
 * @class  layer.ChannelsQuery
 * @extends layer.Query
 */
var Root = require('../root');

var _require = require('../const');

var SYNC_STATE = _require.SYNC_STATE;

var Query = require('./query');
var ConversationsQuery = require('./conversations-query');

var ChannelsQuery = function (_ConversationsQuery) {
  _inherits(ChannelsQuery, _ConversationsQuery);

  function ChannelsQuery() {
    _classCallCheck(this, ChannelsQuery);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(ChannelsQuery).apply(this, arguments));
  }

  _createClass(ChannelsQuery, [{
    key: '_fetchData',
    value: function _fetchData(pageSize) {
      var _this2 = this;

      this.client.dbManager.loadChannels(this._nextDBFromId, pageSize, function (channels) {
        if (channels.length) _this2._appendResults({ data: channels }, true);
      });

      var newRequest = 'channels?page_size=' + pageSize + (this._nextServerFromId ? '&from_id=' + this._nextServerFromId : '');

      if (newRequest !== this._firingRequest) {
        this.isFiring = true;
        this._firingRequest = newRequest;
        this.client.xhr({
          url: this._firingRequest,
          method: 'GET',
          sync: false
        }, function (results) {
          return _this2._processRunResults(results, _this2._firingRequest, pageSize);
        });
      }
    }
  }, {
    key: '_getSortField',
    value: function _getSortField() {
      return 'created_at';
    }
  }, {
    key: '_getItem',
    value: function _getItem(id) {
      return Query.prototype._getItem.apply(this, [id]);
    }
  }, {
    key: '_handleEvents',
    value: function _handleEvents(eventName, evt) {
      switch (eventName) {

        // If a Conversation's property has changed, and the Conversation is in this
        // Query's data, then update it.
        case 'channels:change':
          this._handleChangeEvent('channels', evt);
          break;

        // If a Conversation is added, and it isn't already in the Query,
        // add it and trigger an event
        case 'channels:add':
          this._handleAddEvent('channels', evt);
          break;

        // If a Conversation is deleted, and its still in our data,
        // remove it and trigger an event.
        case 'channels:remove':
          this._handleRemoveEvent('channels', evt);
          break;
      }
    }
  }, {
    key: '_appendResultsSplice',
    value: function _appendResultsSplice(item) {
      this.data.unshift(this._getData(item));
    }
  }, {
    key: '_handleChangeEvent',
    value: function _handleChangeEvent(name, evt) {
      var index = this._getIndex(evt.target.id);

      // If its an ID change (matching named channel returned by server) make sure to update our data.
      // If dataType is an instance, its been updated for us.
      if (this.dataType === Query.ObjectDataType) {
        var idChanges = evt.getChangesFor('id');
        if (idChanges.length) {
          index = this._getIndex(idChanges[0].oldValue);
        }
      }

      // If dataType is "object" then update the object and our array;
      // else the object is already updated.
      // Ignore results that aren't already in our data; Results are added via
      // channels:add events.  Websocket Manager automatically loads anything that receives an event
      // for which we have no object, so we'll get the add event at that time.
      if (index !== -1) {
        var sortField = this._getSortField();
        var reorder = evt.hasProperty('lastMessage') && sortField === 'last_message';
        var newIndex = void 0;

        if (this.dataType === Query.ObjectDataType) {
          if (!reorder) {
            // Replace the changed Channel with a new immutable object
            this.data = [].concat(_toConsumableArray(this.data.slice(0, index)), [evt.target.toObject()], _toConsumableArray(this.data.slice(index + 1)));
          } else {
            newIndex = this._getInsertIndex(evt.target, this.data);
            this.data.splice(index, 1);
            this.data.splice(newIndex, 0, this._getData(evt.target));
            this.data = this.data.concat([]);
          }
        }

        // Else dataType is instance not object
        else if (reorder) {
            newIndex = this._getInsertIndex(evt.target, this.data);
            if (newIndex !== index) {
              this.data.splice(index, 1);
              this.data.splice(newIndex, 0, evt.target);
            }
          }

        // Trigger a 'property' event
        this._triggerChange({
          type: 'property',
          target: this._getData(evt.target),
          query: this,
          isChange: true,
          changes: evt.changes
        });

        if (reorder && newIndex !== index) {
          this._triggerChange({
            type: 'move',
            target: this._getData(evt.target),
            query: this,
            isChange: false,
            fromIndex: index,
            toIndex: newIndex
          });
        }
      }
    }
  }, {
    key: '_getInsertIndex',
    value: function _getInsertIndex(channel, data) {
      if (!channel.isSaved()) return 0;
      var sortField = this._getSortField();
      var index = void 0;
      if (sortField === 'created_at') {
        for (index = 0; index < data.length; index++) {
          var item = data[index];
          if (item.syncState === SYNC_STATE.NEW || item.syncState === SYNC_STATE.SAVING) {
            // No-op do not insert server data before new and unsaved data
          } else if (channel.createdAt >= item.createdAt) {
            break;
          }
        }
        return index;
      } else {
        var oldIndex = -1;
        var d1 = channel.lastMessage ? channel.lastMessage.sentAt : channel.createdAt;
        for (index = 0; index < data.length; index++) {
          var _item = data[index];
          if (_item.id === channel.id) {
            oldIndex = index;
          } else if (_item.syncState === SYNC_STATE.NEW || _item.syncState === SYNC_STATE.SAVING) {
            // No-op do not insert server data before new and unsaved data
          } else {
            var d2 = _item.lastMessage ? _item.lastMessage.sentAt : _item.createdAt;
            if (d1 >= d2) break;
          }
        }
        return oldIndex === -1 || oldIndex > index ? index : index - 1;
      }
    }
  }, {
    key: '_handleAddEvent',
    value: function _handleAddEvent(name, evt) {
      var _this3 = this;

      // Filter out any Channels already in our data
      var list = evt[name].filter(function (channel) {
        return _this3._getIndex(channel.id) === -1;
      });

      if (list.length) {
        (function () {
          var data = _this3.data;
          list.forEach(function (channel) {
            var newIndex = _this3._getInsertIndex(channel, data);
            data.splice(newIndex, 0, _this3._getData(channel));
          });

          // Whether sorting by last_message or created_at, new results go at the top of the list
          if (_this3.dataType === Query.ObjectDataType) {
            _this3.data = [].concat(data);
          }
          _this3.totalSize += list.length;

          // Trigger an 'insert' event for each item added;
          // typically bulk inserts happen via _appendResults().
          list.forEach(function (channel) {
            var item = _this3._getData(channel);
            _this3._triggerChange({
              type: 'insert',
              index: _this3.data.indexOf(item),
              target: item,
              query: _this3
            });
          });
        })();
      }
    }
  }, {
    key: '_handleRemoveEvent',
    value: function _handleRemoveEvent(name, evt) {
      var _this4 = this;

      var removed = [];
      evt[name].forEach(function (channel) {
        var index = _this4._getIndex(channel.id);
        if (index !== -1) {
          if (channel.id === _this4._nextDBFromId) _this4._nextDBFromId = _this4._updateNextFromId(index);
          if (channel.id === _this4._nextServerFromId) _this4._nextServerFromId = _this4._updateNextFromId(index);
          removed.push({
            data: channel,
            index: index
          });
          if (_this4.dataType === Query.ObjectDataType) {
            _this4.data = [].concat(_toConsumableArray(_this4.data.slice(0, index)), _toConsumableArray(_this4.data.slice(index + 1)));
          } else {
            _this4.data.splice(index, 1);
          }
        }
      });

      this.totalSize -= removed.length;
      removed.forEach(function (removedObj) {
        _this4._triggerChange({
          type: 'remove',
          index: removedObj.index,
          target: _this4._getData(removedObj.data),
          query: _this4
        });
      });
    }
  }]);

  return ChannelsQuery;
}(ConversationsQuery);

ChannelsQuery._supportedEvents = [].concat(ConversationsQuery._supportedEvents);

ChannelsQuery.MaxPageSize = 100;

ChannelsQuery.prototype.model = Query.Channel;

Root.initClass.apply(ChannelsQuery, [ChannelsQuery, 'ChannelsQuery']);

module.exports = ChannelsQuery;


},{"../const":84,"../root":116,"./conversations-query":110,"./query":115}],110:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Query class for running a Query on Conversations.
 *
 *
 *      var conversationQuery = client.createQuery({
 *        client: client,
 *        model: layer.Query.Conversation,
 *        sortBy: [{'createdAt': 'desc'}]
 *      });
 *
 *
 * You can change the `paginationWindow` and `sortBy` properties at any time using:
 *
 *      query.update({
 *        paginationWindow: 200
 *      });
 *
 * You can release data held in memory by your queries when done with them:
 *
 *      query.destroy();
 *
 * #### sortBy
 *
 * Note that the `sortBy` property is only supported for Conversations at this time and only
 * supports "createdAt" and "lastMessage.sentAt" as sort fields, and only supports `desc` sort direction.
 *
 *      query.update({
 *        sortBy: [{'lastMessage.sentAt': 'desc'}]
 *      });
 *
 *
 * @class  layer.ConversationsQuery
 * @extends layer.Query
 */
var Root = require('../root');
var Util = require('../client-utils');

var _require = require('../const');

var SYNC_STATE = _require.SYNC_STATE;

var Query = require('./query');

var ConversationsQuery = function (_Query) {
  _inherits(ConversationsQuery, _Query);

  function ConversationsQuery() {
    _classCallCheck(this, ConversationsQuery);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(ConversationsQuery).apply(this, arguments));
  }

  _createClass(ConversationsQuery, [{
    key: '_fetchData',
    value: function _fetchData(pageSize) {
      var _this2 = this;

      var sortBy = this._getSortField();

      this.client.dbManager.loadConversations(sortBy, this._nextDBFromId, pageSize, function (conversations) {
        if (conversations.length) _this2._appendResults({ data: conversations }, true);
      });

      var newRequest = 'conversations?sort_by=' + sortBy + '&page_size=' + pageSize + (this._nextServerFromId ? '&from_id=' + this._nextServerFromId : '');

      if (newRequest !== this._firingRequest) {
        this.isFiring = true;
        this._firingRequest = newRequest;
        this.client.xhr({
          url: this._firingRequest,
          method: 'GET',
          sync: false
        }, function (results) {
          return _this2._processRunResults(results, newRequest, pageSize);
        });
      }
    }
  }, {
    key: '_getSortField',
    value: function _getSortField() {
      if (this.sortBy && this.sortBy[0] && this.sortBy[0]['lastMessage.sentAt']) {
        return 'last_message';
      } else {
        return 'created_at';
      }
    }
  }, {
    key: '_getItem',
    value: function _getItem(id) {
      switch (Util.typeFromID(id)) {
        case 'messages':
          for (var index = 0; index < this.data.length; index++) {
            var conversation = this.data[index];
            if (conversation.lastMessage && conversation.lastMessage.id === id) return conversation.lastMessage;
          }
          return null;
        case 'conversations':
          return _get(Object.getPrototypeOf(ConversationsQuery.prototype), '_getItem', this).call(this, id);
      }
    }
  }, {
    key: '_appendResultsSplice',
    value: function _appendResultsSplice(item) {
      var data = this.data;
      var index = this._getInsertIndex(item, data);
      data.splice(index, 0, this._getData(item));
    }
  }, {
    key: '_handleEvents',
    value: function _handleEvents(eventName, evt) {
      switch (eventName) {

        // If a Conversation's property has changed, and the Conversation is in this
        // Query's data, then update it.
        case 'conversations:change':
          this._handleChangeEvent('conversations', evt);
          break;

        // If a Conversation is added, and it isn't already in the Query,
        // add it and trigger an event
        case 'conversations:add':
          this._handleAddEvent('conversations', evt);
          break;

        // If a Conversation is deleted, and its still in our data,
        // remove it and trigger an event.
        case 'conversations:remove':
          this._handleRemoveEvent('conversations', evt);
          break;
      }
    }

    // TODO WEB-968: Refactor this into functions for instance, object, sortBy createdAt, sortBy lastMessage

  }, {
    key: '_handleChangeEvent',
    value: function _handleChangeEvent(name, evt) {
      var index = this._getIndex(evt.target.id);

      // If its an ID change (matching Distinct Conversation returned by server) make sure to update our data.
      // If dataType is an instance, its been updated for us.
      if (this.dataType === Query.ObjectDataType) {
        var idChanges = evt.getChangesFor('id');
        if (idChanges.length) {
          index = this._getIndex(idChanges[0].oldValue);
        }
      }

      // If dataType is "object" then update the object and our array;
      // else the object is already updated.
      // Ignore results that aren't already in our data; Results are added via
      // conversations:add events.  Websocket Manager automatically loads anything that receives an event
      // for which we have no object, so we'll get the add event at that time.
      if (index !== -1) {
        var sortField = this._getSortField();
        var reorder = evt.hasProperty('lastMessage') && sortField === 'last_message';
        var newIndex = void 0;

        if (this.dataType === Query.ObjectDataType) {
          if (!reorder) {
            // Replace the changed Conversation with a new immutable object
            this.data = [].concat(_toConsumableArray(this.data.slice(0, index)), [evt.target.toObject()], _toConsumableArray(this.data.slice(index + 1)));
          } else {
            newIndex = this._getInsertIndex(evt.target, this.data);
            this.data.splice(index, 1);
            this.data.splice(newIndex, 0, this._getData(evt.target));
            this.data = this.data.concat([]);
          }
        }

        // Else dataType is instance not object
        else if (reorder) {
            newIndex = this._getInsertIndex(evt.target, this.data);
            if (newIndex !== index) {
              this.data.splice(index, 1);
              this.data.splice(newIndex, 0, evt.target);
            }
          }

        // Trigger a 'property' event
        this._triggerChange({
          type: 'property',
          target: this._getData(evt.target),
          query: this,
          isChange: true,
          changes: evt.changes
        });

        if (reorder && newIndex !== index) {
          this._triggerChange({
            type: 'move',
            target: this._getData(evt.target),
            query: this,
            isChange: false,
            fromIndex: index,
            toIndex: newIndex
          });
        }
      }
    }
  }, {
    key: '_getInsertIndex',
    value: function _getInsertIndex(conversation, data) {
      if (!conversation.isSaved()) return 0;
      var sortField = this._getSortField();
      var index = void 0;
      if (sortField === 'created_at') {
        for (index = 0; index < data.length; index++) {
          var item = data[index];
          if (item.syncState === SYNC_STATE.NEW || item.syncState === SYNC_STATE.SAVING) {
            // No-op do not insert server data before new and unsaved data
          } else if (conversation.createdAt >= item.createdAt) {
            break;
          }
        }
        return index;
      } else {
        var oldIndex = -1;
        var d1 = conversation.lastMessage ? conversation.lastMessage.sentAt : conversation.createdAt;
        for (index = 0; index < data.length; index++) {
          var _item = data[index];
          if (_item.id === conversation.id) {
            oldIndex = index;
          } else if (_item.syncState === SYNC_STATE.NEW || _item.syncState === SYNC_STATE.SAVING) {
            // No-op do not insert server data before new and unsaved data
          } else {
            var d2 = _item.lastMessage ? _item.lastMessage.sentAt : _item.createdAt;
            if (d1 >= d2) break;
          }
        }
        return oldIndex === -1 || oldIndex > index ? index : index - 1;
      }
    }
  }, {
    key: '_handleAddEvent',
    value: function _handleAddEvent(name, evt) {
      var _this3 = this;

      // Filter out any Conversations already in our data
      var list = evt[name].filter(function (conversation) {
        return _this3._getIndex(conversation.id) === -1;
      });

      if (list.length) {
        (function () {
          var data = _this3.data;
          list.forEach(function (conversation) {
            var newIndex = _this3._getInsertIndex(conversation, data);
            data.splice(newIndex, 0, _this3._getData(conversation));
          });

          // Whether sorting by last_message or created_at, new results go at the top of the list
          if (_this3.dataType === Query.ObjectDataType) {
            _this3.data = [].concat(data);
          }
          _this3.totalSize += list.length;

          // Trigger an 'insert' event for each item added;
          // typically bulk inserts happen via _appendResults().
          list.forEach(function (conversation) {
            var item = _this3._getData(conversation);
            _this3._triggerChange({
              type: 'insert',
              index: _this3.data.indexOf(item),
              target: item,
              query: _this3
            });
          });
        })();
      }
    }
  }, {
    key: '_handleRemoveEvent',
    value: function _handleRemoveEvent(name, evt) {
      var _this4 = this;

      var removed = [];
      evt[name].forEach(function (conversation) {
        var index = _this4._getIndex(conversation.id);
        if (index !== -1) {
          if (conversation.id === _this4._nextDBFromId) _this4._nextDBFromId = _this4._updateNextFromId(index);
          if (conversation.id === _this4._nextServerFromId) _this4._nextServerFromId = _this4._updateNextFromId(index);
          removed.push({
            data: conversation,
            index: index
          });
          if (_this4.dataType === Query.ObjectDataType) {
            _this4.data = [].concat(_toConsumableArray(_this4.data.slice(0, index)), _toConsumableArray(_this4.data.slice(index + 1)));
          } else {
            _this4.data.splice(index, 1);
          }
        }
      });

      this.totalSize -= removed.length;
      removed.forEach(function (removedObj) {
        _this4._triggerChange({
          type: 'remove',
          index: removedObj.index,
          target: _this4._getData(removedObj.data),
          query: _this4
        });
      });
    }
  }]);

  return ConversationsQuery;
}(Query);

ConversationsQuery._supportedEvents = [].concat(Query._supportedEvents);

ConversationsQuery.MaxPageSize = 100;

ConversationsQuery.prototype.model = Query.Conversation;

Root.initClass.apply(ConversationsQuery, [ConversationsQuery, 'ConversationsQuery']);

module.exports = ConversationsQuery;


},{"../client-utils":82,"../const":84,"../root":116,"./query":115}],111:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Query class for running a Query on Identities
 *
 *      var identityQuery = client.createQuery({
 *        client: client,
 *        model: layer.Query.Identity
 *      });
 *
 *
 * You can change the `paginationWindow` property at any time using:
 *
 *      query.update({
 *        paginationWindow: 200
 *      });
 *
 * You can release data held in memory by your queries when done with them:
 *
 *      query.destroy();
 *
 * @class  layer.IdentitiesQuery
 * @extends layer.Query
 */
var Root = require('../root');
var Query = require('./query');

var IdentitiesQuery = function (_Query) {
  _inherits(IdentitiesQuery, _Query);

  function IdentitiesQuery() {
    _classCallCheck(this, IdentitiesQuery);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(IdentitiesQuery).apply(this, arguments));
  }

  _createClass(IdentitiesQuery, [{
    key: '_fetchData',
    value: function _fetchData(pageSize) {
      var _this2 = this;

      // There is not yet support for paging Identities;  as all identities are loaded,
      // if there is a _nextDBFromId, we no longer need to get any more from the database
      if (!this._nextDBFromId) {
        this.client.dbManager.loadIdentities(function (identities) {
          if (identities.length) _this2._appendResults({ data: identities }, true);
        });
      }

      var newRequest = 'identities?page_size=' + pageSize + (this._nextServerFromId ? '&from_id=' + this._nextServerFromId : '');

      // Don't repeat still firing queries
      if (newRequest !== this._firingRequest) {
        this.isFiring = true;
        this._firingRequest = newRequest;
        this.client.xhr({
          url: newRequest,
          method: 'GET',
          sync: false
        }, function (results) {
          return _this2._processRunResults(results, newRequest, pageSize);
        });
      }
    }
  }, {
    key: '_appendResultsSplice',
    value: function _appendResultsSplice(item) {
      this.data.push(this._getData(item));
    }
  }, {
    key: '_handleEvents',
    value: function _handleEvents(eventName, evt) {
      switch (eventName) {

        // If a Identity has changed and its in our result set, replace
        // it with a new immutable object
        case 'identities:change':
          this._handleChangeEvent('identities', evt);
          break;

        // If Identities are added, and they aren't already in our result set
        // add them.
        case 'identities:add':
          this._handleAddEvent('identities', evt);
          break;

        // If a Identity is deleted and its in our result set, remove it
        // and trigger an event
        case 'identities:remove':
          this._handleRemoveEvent('identities', evt);
          break;
      }
    }
  }]);

  return IdentitiesQuery;
}(Query);

IdentitiesQuery._supportedEvents = [].concat(Query._supportedEvents);

IdentitiesQuery.MaxPageSize = 500;

IdentitiesQuery.prototype.model = Query.Identity;

Root.initClass.apply(IdentitiesQuery, [IdentitiesQuery, 'IdentitiesQuery']);

module.exports = IdentitiesQuery;


},{"../root":116,"./query":115}],112:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Query class for running a Query on Channel Members
 *
 *      var membersQuery = client.createQuery({
 *        client: client,
 *        model: layer.Query.Membership,
 *        predicate: 'channel.id = "layer:///channels/UUID"'
 *      });
 *
 * You can change the data selected by your query any time you want using:
 *
 *      query.update({
 *        predicate: 'channel.id = "layer:///channels/UUID2"'
 *      });
 *
 * You can release data held in memory by your queries when done with them:
 *
 *      query.destroy();
 *
 * #### predicate
 *
 * Note that the `predicate` property is only supported for Messages and Membership, and only supports
 * querying by Channel.
 *
 * @class  layer.MembersQuery
 * @extends layer.Query
 */
var Root = require('../root');
var LayerError = require('../layer-error');
var Logger = require('../logger');
var Query = require('./query');

var findChannelIdRegex = new RegExp(/^channel.id\s*=\s*['"]((layer:\/\/\/channels\/)?.{8}-.{4}-.{4}-.{4}-.{12})['"]$/);

var MembersQuery = function (_Query) {
  _inherits(MembersQuery, _Query);

  function MembersQuery() {
    _classCallCheck(this, MembersQuery);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(MembersQuery).apply(this, arguments));
  }

  _createClass(MembersQuery, [{
    key: '_fixPredicate',
    value: function _fixPredicate(inValue) {
      if (inValue === '') return '';
      if (inValue.indexOf('channel.id') !== -1) {
        var channelId = inValue.match(findChannelIdRegex) ? inValue.replace(findChannelIdRegex, '$1') : null;
        if (!channelId) throw new Error(LayerError.dictionary.invalidPredicate);
        if (channelId.indexOf('layer:///channels/') !== 0) channelId = 'layer:///channels/' + channelId;
        return 'channel.id = \'' + channelId + '\'';
      } else {
        throw new Error(LayerError.dictionary.invalidPredicate);
      }
    }

    /**
     * Get the Channel UUID from the predicate property.
     *
     * Extract the Channel's UUID from the predicate... or returned the cached value.
     *
     * @method _getChannelPredicateIds
     * @private
     */

  }, {
    key: '_getChannelPredicateIds',
    value: function _getChannelPredicateIds() {
      if (this.predicate.match(findChannelIdRegex)) {
        var channelId = this.predicate.replace(findChannelIdRegex, '$1');

        // We will already have a this._predicate if we are paging; else we need to extract the UUID from
        // the channelId.
        var uuid = (this._predicate || channelId).replace(/^layer:\/\/\/channels\//, '');
        if (uuid) {
          return {
            uuid: uuid,
            id: channelId,
            type: Query.Channel
          };
        }
      }
    }
  }, {
    key: '_fetchData',
    value: function _fetchData(pageSize) {
      var _this2 = this;

      var predicateIds = this._getChannelPredicateIds();

      // Do nothing if we don't have a conversation to query on
      if (!predicateIds) {
        if (this.predicate && !this.predicate.match(/['"]/)) {
          Logger.error('This query may need to quote its value');
        }
        return;
      }

      var channelId = 'layer:///channels/' + predicateIds.uuid;
      if (!this._predicate) this._predicate = predicateIds.id;
      var channel = this.client.getChannel(channelId);

      var newRequest = 'channels/' + predicateIds.uuid + '/members?page_size=' + pageSize + (this._nextServerFromId ? '&from_id=' + this._nextServerFromId : '');

      // Don't query on unsaved channels, nor repeat still firing queries
      if ((!channel || channel.isSaved()) && newRequest !== this._firingRequest) {
        this.isFiring = true;
        this._firingRequest = newRequest;
        this.client.xhr({
          url: newRequest,
          method: 'GET',
          sync: false
        }, function (results) {
          return _this2._processRunResults(results, newRequest, pageSize);
        });
      }
    }
  }, {
    key: '_appendResultsSplice',
    value: function _appendResultsSplice(item) {
      this.data.push(this._getData(item));
    }
  }, {
    key: '_handleEvents',
    value: function _handleEvents(eventName, evt) {
      switch (eventName) {

        // If a member has changed and its in our result set, replace
        // it with a new immutable object
        case 'members:change':
          this._handleChangeEvent('members', evt);
          break;

        // If members are added, and they aren't already in our result set
        // add them.
        case 'members:add':
          this._handleAddEvent('members', evt);
          break;

        // If a Identity is deleted and its in our result set, remove it
        // and trigger an event
        case 'members:remove':
          this._handleRemoveEvent('members', evt);
          break;
      }
    }
  }]);

  return MembersQuery;
}(Query);

MembersQuery._supportedEvents = [].concat(Query._supportedEvents);

MembersQuery.MaxPageSize = 500;

MembersQuery.prototype.model = Query.Membership;

Root.initClass.apply(MembersQuery, [MembersQuery, 'MembersQuery']);

module.exports = MembersQuery;


},{"../layer-error":86,"../logger":88,"../root":116,"./query":115}],113:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Query class for running a Query on Messages
 *
 *      var messageQuery = client.createQuery({
 *        client: client,
 *        model: layer.Query.Message,
 *        predicate: 'conversation.id = "layer:///conversations/UUID"'
 *      });
 *
 * You can change the data selected by your query any time you want using:
 *
 *      query.update({
 *        predicate: 'channel.id = "layer:///channels/UUID2"'
 *      });
 *
 * You can release data held in memory by your queries when done with them:
 *
 *      query.destroy();
 *
 * #### predicate
 *
 * Note that the `predicate` property is only supported for Messages and layer.Membership, and only supports
 * querying by Conversation or Channel:
 *
 * * `conversation.id = 'layer:///conversations/UUIUD'`
 * * `channel.id = 'layer:///channels/UUIUD'`
 *
 * @class  layer.MessagesQuery
 * @extends layer.Query
 */
var Root = require('../root');
var LayerError = require('../layer-error');
var Util = require('../client-utils');
var Logger = require('../logger');
var Query = require('./query');

var findConvIdRegex = new RegExp(/^conversation.id\s*=\s*['"]((layer:\/\/\/conversations\/)?.{8}-.{4}-.{4}-.{4}-.{12})['"]$/);
var findChannelIdRegex = new RegExp(/^channel.id\s*=\s*['"]((layer:\/\/\/channels\/)?.{8}-.{4}-.{4}-.{4}-.{12})['"]$/);

var MessagesQuery = function (_Query) {
  _inherits(MessagesQuery, _Query);

  function MessagesQuery() {
    _classCallCheck(this, MessagesQuery);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(MessagesQuery).apply(this, arguments));
  }

  _createClass(MessagesQuery, [{
    key: '_fixPredicate',
    value: function _fixPredicate(inValue) {
      if (inValue === '') return '';
      if (inValue.indexOf('conversation.id') !== -1) {
        var conversationId = inValue.match(findConvIdRegex) ? inValue.replace(findConvIdRegex, '$1') : null;
        if (!conversationId) throw new Error(LayerError.dictionary.invalidPredicate);
        if (conversationId.indexOf('layer:///conversations/') !== 0) conversationId = 'layer:///conversations/' + conversationId;
        return 'conversation.id = \'' + conversationId + '\'';
      } else if (inValue.indexOf('channel.id') !== -1) {
        var channelId = inValue.match(findChannelIdRegex) ? inValue.replace(findChannelIdRegex, '$1') : null;
        if (!channelId) throw new Error(LayerError.dictionary.invalidPredicate);
        if (channelId.indexOf('layer:///channels/') !== 0) channelId = 'layer:///channels/' + channelId;
        return 'channel.id = \'' + channelId + '\'';
      } else {
        throw new Error(LayerError.dictionary.invalidPredicate);
      }
    }
  }, {
    key: '_fetchData',
    value: function _fetchData(pageSize) {
      var predicateIds = this._getConversationPredicateIds();

      // Do nothing if we don't have a conversation to query on
      if (!predicateIds) {
        if (this.predicate && !this.predicate.match(/['"]/)) {
          Logger.error('This query may need to quote its value');
        }
        return;
      }

      switch (predicateIds.type) {
        case Query.Conversation:
          this._fetchConversationMessages(pageSize, predicateIds);
          break;
        case Query.Channel:
          this._fetchChannelMessages(pageSize, predicateIds);
          break;
      }
    }
  }, {
    key: '_getSortField',
    value: function _getSortField() {
      return 'position';
    }

    /**
     * Get the Conversation UUID from the predicate property.
     *
     * Extract the Conversation's UUID from the predicate... or returned the cached value.
     *
     * @method _getConversationPredicateIds
     * @private
     */

  }, {
    key: '_getConversationPredicateIds',
    value: function _getConversationPredicateIds() {
      if (this.predicate.indexOf('conversation.id') !== -1) {
        if (this.predicate.match(findConvIdRegex)) {
          var conversationId = this.predicate.replace(findConvIdRegex, '$1');

          // We will already have a this._predicate if we are paging; else we need to extract the UUID from
          // the conversationId.
          var uuid = (this._predicate || conversationId).replace(/^layer:\/\/\/conversations\//, '');
          if (uuid) {
            return {
              uuid: uuid,
              id: conversationId,
              type: Query.Conversation
            };
          }
        }
      } else if (this.predicate.indexOf('channel.id') !== -1) {
        if (this.predicate.match(findChannelIdRegex)) {
          var channelId = this.predicate.replace(findChannelIdRegex, '$1');

          // We will already have a this._predicate if we are paging; else we need to extract the UUID from
          // the channelId.
          var _uuid = (this._predicate || channelId).replace(/^layer:\/\/\/channels\//, '');
          if (_uuid) {
            return {
              uuid: _uuid,
              id: channelId,
              type: Query.Channel
            };
          }
        }
      }
    }
  }, {
    key: '_fetchConversationMessages',
    value: function _fetchConversationMessages(pageSize, predicateIds) {
      var _this2 = this;

      var conversationId = 'layer:///conversations/' + predicateIds.uuid;
      if (!this._predicate) this._predicate = predicateIds.id;
      var conversation = this.client.getConversation(conversationId);

      // Retrieve data from db cache in parallel with loading data from server
      this.client.dbManager.loadMessages(conversationId, this._nextDBFromId, pageSize, function (messages) {
        if (messages.length) _this2._appendResults({ data: messages }, true);
      });

      var newRequest = 'conversations/' + predicateIds.uuid + '/messages?page_size=' + pageSize + (this._nextServerFromId ? '&from_id=' + this._nextServerFromId : '');

      // Don't query on unsaved conversations, nor repeat still firing queries
      if ((!conversation || conversation.isSaved()) && newRequest !== this._firingRequest) {
        this.isFiring = true;
        this._firingRequest = newRequest;
        this.client.xhr({
          url: newRequest,
          method: 'GET',
          sync: false
        }, function (results) {
          return _this2._processRunResults(results, newRequest, pageSize);
        });
      }

      // If there are no results, then its a new query; automatically populate it with the Conversation's lastMessage.
      if (this.data.length === 0) {
        if (conversation && conversation.lastMessage) {
          this.data = [this._getData(conversation.lastMessage)];
          // Trigger the change event
          this._triggerChange({
            type: 'data',
            data: [this._getData(conversation.lastMessage)],
            query: this,
            target: this.client
          });
        }
      }
    }
  }, {
    key: '_fetchChannelMessages',
    value: function _fetchChannelMessages(pageSize, predicateIds) {
      var _this3 = this;

      var channelId = 'layer:///channels/' + predicateIds.uuid;
      if (!this._predicate) this._predicate = predicateIds.id;
      var channel = this.client.getChannel(channelId);

      // Retrieve data from db cache in parallel with loading data from server
      this.client.dbManager.loadMessages(channelId, this._nextDBFromId, pageSize, function (messages) {
        if (messages.length) _this3._appendResults({ data: messages }, true);
      });

      var newRequest = 'channels/' + predicateIds.uuid + '/messages?page_size=' + pageSize + (this._nextServerFromId ? '&from_id=' + this._nextServerFromId : '');

      // Don't query on unsaved channels, nor repeat still firing queries
      if ((!channel || channel.isSaved()) && newRequest !== this._firingRequest) {
        this.isFiring = true;
        this._firingRequest = newRequest;
        this.client.xhr({
          url: newRequest,
          method: 'GET',
          sync: false
        }, function (results) {
          return _this3._processRunResults(results, newRequest, pageSize);
        });
      }
    }
  }, {
    key: '_appendResultsSplice',
    value: function _appendResultsSplice(item) {
      var data = this.data;
      var index = this._getInsertIndex(item, data);
      data.splice(index, 0, this._getData(item));
    }
  }, {
    key: '_getInsertIndex',
    value: function _getInsertIndex(message, data) {
      var index = void 0;
      for (index = 0; index < data.length; index++) {
        if (message.position > data[index].position) {
          break;
        }
      }
      return index;
    }
  }, {
    key: '_handleEvents',
    value: function _handleEvents(eventName, evt) {
      switch (eventName) {

        // If a Conversation's ID has changed, check our predicate, and update it automatically if needed.
        case 'conversations:change':
          this._handleConvIdChangeEvent(evt);
          break;

        // If a Message has changed and its in our result set, replace
        // it with a new immutable object
        case 'messages:change':
        case 'messages:read':
          this._handleChangeEvent('messages', evt);
          break;

        // If Messages are added, and they aren't already in our result set
        // add them.
        case 'messages:add':
          this._handleAddEvent('messages', evt);
          break;

        // If a Message is deleted and its in our result set, remove it
        // and trigger an event
        case 'messages:remove':
          this._handleRemoveEvent('messages', evt);
          break;
      }
    }

    /**
     * A Conversation or Channel ID changes if a matching Distinct Conversation or named Channel was found on the server.
     *
     * If this Query's Conversation's ID has changed, update the predicate.
     *
     * @method _handleConvIdChangeEvent
     * @param {layer.LayerEvent} evt - A Message Change Event
     * @private
     */

  }, {
    key: '_handleConvIdChangeEvent',
    value: function _handleConvIdChangeEvent(evt) {
      var cidChanges = evt.getChangesFor('id');
      if (cidChanges.length) {
        if (this._predicate === cidChanges[0].oldValue) {
          this._predicate = cidChanges[0].newValue;
          this.predicate = "conversation.id = '" + this._predicate + "'";
          this._run();
        }
      }
    }

    /**
     * If the ID of the message has changed, then the position property has likely changed as well.
     *
     * This method tests to see if changes to the position property have impacted the message's position in the
     * data array... and updates the array if it has.
     *
     * @method _handlePositionChange
     * @private
     * @param {layer.LayerEvent} evt  A Message Change event
     * @param {number} index  Index of the message in the current data array
     * @return {boolean} True if a data was changed and a change event was emitted
     */

  }, {
    key: '_handlePositionChange',
    value: function _handlePositionChange(evt, index) {
      // If the message is not in the current data, then there is no change to our query results.
      if (index === -1) return false;

      // Create an array without our data item and then find out where the data item Should be inserted.
      // Note: we could just lookup the position in our current data array, but its too easy to introduce
      // errors where comparing this message to itself may yield index or index + 1.
      var newData = [].concat(_toConsumableArray(this.data.slice(0, index)), _toConsumableArray(this.data.slice(index + 1)));
      var newIndex = this._getInsertIndex(evt.target, newData);

      // If the data item goes in the same index as before, then there is no change to be handled here;
      // else insert the item at the right index, update this.data and fire a change event
      if (newIndex !== index) {
        newData.splice(newIndex, 0, this._getData(evt.target));
        this.data = newData;
        this._triggerChange({
          type: 'property',
          target: this._getData(evt.target),
          query: this,
          isChange: true,
          changes: evt.changes
        });
        return true;
      }
      return false;
    }
  }, {
    key: '_handleChangeEvent',
    value: function _handleChangeEvent(name, evt) {
      var index = this._getIndex(evt.target.id);
      var positionChanges = evt.getChangesFor('position');

      // If there are position changes, handle them.  If all the changes are position changes,
      // exit when done.
      if (positionChanges.length) {
        if (this._handlePositionChange(evt, index)) {
          if (positionChanges.length === evt.changes.length) return;
          index = this._getIndex(evt.target.id); // Get the updated position
        }
      }

      if (index !== -1) {
        if (this.dataType === Query.ObjectDataType) {
          this.data = [].concat(_toConsumableArray(this.data.slice(0, index)), [evt.target.toObject()], _toConsumableArray(this.data.slice(index + 1)));
        }
        this._triggerChange({
          type: 'property',
          target: this._getData(evt.target),
          query: this,
          isChange: true,
          changes: evt.changes
        });
      }
    }
  }, {
    key: '_handleAddEvent',
    value: function _handleAddEvent(name, evt) {
      var _this4 = this;

      // Only use added messages that are part of this Conversation
      // and not already in our result set
      var list = evt[name]
      // Filter so that we only see Messages if doing a Messages query or Announcements if doing an Announcements Query.
      .filter(function (message) {
        var type = Util.typeFromID(message.id);
        return type === 'messages' && _this4.model === Query.Message || type === 'announcements' && _this4.model === Query.Announcement;
      })
      // Filter out Messages that aren't part of this Conversation
      .filter(function (message) {
        var type = Util.typeFromID(message.id);
        return type === 'announcements' || message.conversationId === _this4._predicate;
      })
      // Filter out Messages that are already in our data set
      .filter(function (message) {
        return _this4._getIndex(message.id) === -1;
      }).map(function (message) {
        return _this4._getData(message);
      });

      // Add them to our result set and trigger an event for each one
      if (list.length) {
        (function () {
          var data = _this4.data = _this4.dataType === Query.ObjectDataType ? [].concat(_this4.data) : _this4.data;
          list.forEach(function (item) {
            var index = _this4._getInsertIndex(item, data);
            data.splice(index, 0, item);
          });

          _this4.totalSize += list.length;

          // Index calculated above may shift after additional insertions.  This has
          // to be done after the above insertions have completed.
          list.forEach(function (item) {
            _this4._triggerChange({
              type: 'insert',
              index: _this4.data.indexOf(item),
              target: item,
              query: _this4
            });
          });
        })();
      }
    }
  }, {
    key: '_handleRemoveEvent',
    value: function _handleRemoveEvent(name, evt) {
      var _this5 = this;

      var removed = [];
      evt[name].forEach(function (message) {
        var index = _this5._getIndex(message.id);
        if (index !== -1) {
          if (message.id === _this5._nextDBFromId) _this5._nextDBFromId = _this5._updateNextFromId(index);
          if (message.id === _this5._nextServerFromId) _this5._nextServerFromId = _this5._updateNextFromId(index);
          removed.push({
            data: message,
            index: index
          });
          if (_this5.dataType === Query.ObjectDataType) {
            _this5.data = [].concat(_toConsumableArray(_this5.data.slice(0, index)), _toConsumableArray(_this5.data.slice(index + 1)));
          } else {
            _this5.data.splice(index, 1);
          }
        }
      });

      this.totalSize -= removed.length;
      removed.forEach(function (removedObj) {
        _this5._triggerChange({
          type: 'remove',
          target: _this5._getData(removedObj.data),
          index: removedObj.index,
          query: _this5
        });
      });
    }
  }]);

  return MessagesQuery;
}(Query);

MessagesQuery._supportedEvents = [].concat(Query._supportedEvents);

MessagesQuery.MaxPageSize = 100;

MessagesQuery.prototype.model = Query.Message;

Root.initClass.apply(MessagesQuery, [MessagesQuery, 'MessagesQuery']);

module.exports = MessagesQuery;


},{"../client-utils":82,"../layer-error":86,"../logger":88,"../root":116,"./query":115}],114:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Query = require('./query');

/**
 * Query builder class generating queries for a set of messages.
 * Used in Creating and Updating layer.Query instances.
 *
 * Using the Query Builder, we should be able to instantiate a Query
 *
 *      var qBuilder = QueryBuilder
 *       .messages()
 *       .forConversation('layer:///conversations/ffffffff-ffff-ffff-ffff-ffffffffffff')
 *       .paginationWindow(100);
 *      var query = client.createQuery(qBuilder);
 *
 *
 * You can then create additional builders and update the query:
 *
 *      var qBuilder2 = QueryBuilder
 *       .messages()
 *       .forConversation('layer:///conversations/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb')
 *       .paginationWindow(200);
 *      query.update(qBuilder);
 *
 * @class layer.QueryBuilder.MessagesQuery
 */

var MessagesQuery = function () {

  /**
   * Creates a new query builder for a set of messages.
   *
   * Standard use is without any arguments.
   *
   * @method constructor
   * @param  {Object} [query=null]
   */
  function MessagesQuery(query) {
    _classCallCheck(this, MessagesQuery);

    if (query) {
      this._query = {
        model: query.model,
        returnType: query.returnType,
        dataType: query.dataType,
        paginationWindow: query.paginationWindow
      };
    } else {
      this._query = {
        model: Query.Message,
        returnType: 'object',
        dataType: 'object',
        paginationWindow: Query.prototype.paginationWindow
      };
    }

    // TODO remove when messages can be fetched via query API rather than `GET /messages`
    this._conversationIdSet = false;
  }

  /**
   * Query for messages in this Conversation or Channel.
   *
   * @method forConversation
   * @param  {String} conversationId  Accepts a Conversation ID or Channel ID
   */


  _createClass(MessagesQuery, [{
    key: 'forConversation',
    value: function forConversation(conversationId) {
      if (conversationId.indexOf('layer:///channels/') === 0) {
        this._query.predicate = 'channel.id = \'' + conversationId + '\'';
        this._conversationIdSet = true;
      } else if (conversationId.indexOf('layer:///conversations/') === 0) {
        this._query.predicate = 'conversation.id = \'' + conversationId + '\'';
        this._conversationIdSet = true;
      } else {
        this._query.predicate = '';
        this._conversationIdSet = false;
      }
      return this;
    }

    /**
     * Sets the pagination window/number of messages to fetch from the local cache or server.
     *
     * Currently only positive integers are supported.
     *
     * @method paginationWindow
     * @param  {number} win
     */

  }, {
    key: 'paginationWindow',
    value: function paginationWindow(win) {
      this._query.paginationWindow = win;
      return this;
    }

    /**
     * Returns the built query object to send to the server.
     *
     * Called by layer.QueryBuilder. You should not need to call this.
     *
     * @method build
     */

  }, {
    key: 'build',
    value: function build() {
      return this._query;
    }
  }]);

  return MessagesQuery;
}();

/**
 * Query builder class generating queries for a set of Announcements.
 *
 * To get started:
 *
 *      var qBuilder = QueryBuilder
 *       .announcements()
 *       .paginationWindow(100);
 *      var query = client.createQuery(qBuilder);
 *
 * @class layer.QueryBuilder.AnnouncementsQuery
 * @extends layer.QueryBuilder.MessagesQuery
 */


var AnnouncementsQuery = function (_MessagesQuery) {
  _inherits(AnnouncementsQuery, _MessagesQuery);

  function AnnouncementsQuery(options) {
    _classCallCheck(this, AnnouncementsQuery);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AnnouncementsQuery).call(this, options));

    _this._query.model = Query.Announcement;
    return _this;
  }

  _createClass(AnnouncementsQuery, [{
    key: 'build',
    value: function build() {
      return this._query;
    }
  }]);

  return AnnouncementsQuery;
}(MessagesQuery);

/**
 * Query builder class generating queries for a set of Conversations.
 *
 * Used in Creating and Updating layer.Query instances.
 *
 * To get started:
 *
 *      var qBuilder = QueryBuilder
 *       .conversations()
 *       .paginationWindow(100);
 *      var query = client.createQuery(qBuilder);
 *
 * You can then create additional builders and update the query:
 *
 *      var qBuilder2 = QueryBuilder
 *       .conversations()
 *       .paginationWindow(200);
 *      query.update(qBuilder);
 *
 * @class layer.QueryBuilder.ConversationsQuery
 */


var ConversationsQuery = function () {

  /**
   * Creates a new query builder for a set of conversations.
   *
   * Standard use is without any arguments.
   *
   * @method constructor
   * @param  {Object} [query=null]
   */
  function ConversationsQuery(query) {
    _classCallCheck(this, ConversationsQuery);

    if (query) {
      this._query = {
        model: query.model,
        returnType: query.returnType,
        dataType: query.dataType,
        paginationWindow: query.paginationWindow,
        sortBy: query.sortBy
      };
    } else {
      this._query = {
        model: Query.Conversation,
        returnType: 'object',
        dataType: 'object',
        paginationWindow: Query.prototype.paginationWindow,
        sortBy: null
      };
    }
  }

  /**
   * Sets the pagination window/number of messages to fetch from the local cache or server.
   *
   * Currently only positive integers are supported.
   *
   * @method paginationWindow
   * @param  {number} win
   * @return {layer.QueryBuilder} this
   */


  _createClass(ConversationsQuery, [{
    key: 'paginationWindow',
    value: function paginationWindow(win) {
      this._query.paginationWindow = win;
      return this;
    }

    /**
     * Sets the sorting options for the Conversation.
     *
     * Currently only supports descending order
     * Currently only supports fieldNames of "createdAt" and "lastMessage.sentAt"
     *
     * @method sortBy
     * @param  {string} fieldName  - field to sort by
     * @param  {boolean} asc - Is an ascending sort?
     * @return {layer.QueryBuilder} this
     */

  }, {
    key: 'sortBy',
    value: function sortBy(fieldName) {
      var asc = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      this._query.sortBy = [_defineProperty({}, fieldName, asc ? 'asc' : 'desc')];
      return this;
    }

    /**
     * Returns the built query object to send to the server.
     *
     * Called by layer.QueryBuilder. You should not need to call this.
     *
     * @method build
     */

  }, {
    key: 'build',
    value: function build() {
      return this._query;
    }
  }]);

  return ConversationsQuery;
}();

/**
 * Query builder class generating queries for a set of Channels.
 *
 * Used in Creating and Updating layer.Query instances.
 *
 * To get started:
 *
 *      var qBuilder = QueryBuilder
 *       .channels()
 *       .paginationWindow(100);
 *      var query = client.createQuery(qBuilder);
 *
 * You can then create additional builders and update the query:
 *
 *      var qBuilder2 = QueryBuilder
 *       .conversations()
 *       .paginationWindow(200);
 *      query.update(qBuilder);
 *
 * @class layer.QueryBuilder.ChannelsQuery
 */


var ChannelsQuery = function () {

  /**
   * Creates a new query builder for a set of conversations.
   *
   * Standard use is without any arguments.
   *
   * @method constructor
   * @param  {Object} [query=null]
   */
  function ChannelsQuery(query) {
    _classCallCheck(this, ChannelsQuery);

    if (query) {
      this._query = {
        model: query.model,
        returnType: query.returnType,
        dataType: query.dataType,
        paginationWindow: query.paginationWindow,
        sortBy: null
      };
    } else {
      this._query = {
        model: Query.Channel,
        returnType: 'object',
        dataType: 'object',
        paginationWindow: Query.prototype.paginationWindow,
        sortBy: null
      };
    }
  }

  /**
   * Sets the pagination window/number of messages to fetch from the local cache or server.
   *
   * Currently only positive integers are supported.
   *
   * @method paginationWindow
   * @param  {number} win
   * @return {layer.QueryBuilder} this
   */


  _createClass(ChannelsQuery, [{
    key: 'paginationWindow',
    value: function paginationWindow(win) {
      this._query.paginationWindow = win;
      return this;
    }

    /**
     * Returns the built query object to send to the server.
     *
     * Called by layer.QueryBuilder. You should not need to call this.
     *
     * @method build
     */

  }, {
    key: 'build',
    value: function build() {
      return this._query;
    }
  }]);

  return ChannelsQuery;
}();

/**
 * Query builder class generating queries for getting members of a Channel.
 *
 * Used in Creating and Updating layer.Query instances.
 *
 * To get started:
 *
 *      var qBuilder = QueryBuilder
 *       .members()
 *       .forChannel(channelId)
 *       .paginationWindow(100);
 *      var query = client.createQuery(qBuilder);
 *
 * You can then create additional builders and update the query:
 *
 *      var qBuilder2 = QueryBuilder
 *       .members()
 *       .forChannel(channelId)
 *       .paginationWindow(200);
 *      query.update(qBuilder);
 *
 * @class layer.QueryBuilder.MembersQuery
 */


var MembersQuery = function () {

  /**
   * Creates a new query builder for a set of conversations.
   *
   * Standard use is without any arguments.
   *
   * @method constructor
   * @param  {Object} [query=null]
   */
  function MembersQuery(query) {
    _classCallCheck(this, MembersQuery);

    if (query) {
      this._query = {
        model: query.model,
        returnType: query.returnType,
        dataType: query.dataType,
        paginationWindow: query.paginationWindow,
        sortBy: null
      };
    } else {
      this._query = {
        model: Query.Membership,
        returnType: 'object',
        dataType: 'object',
        paginationWindow: Query.prototype.paginationWindow,
        sortBy: null
      };
    }
  }

  /**
   * Sets the pagination window/number of messages to fetch from the local cache or server.
   *
   * Currently only positive integers are supported.
   *
   * @method paginationWindow
   * @param  {number} win
   * @return {layer.QueryBuilder} this
   */


  _createClass(MembersQuery, [{
    key: 'paginationWindow',
    value: function paginationWindow(win) {
      this._query.paginationWindow = win;
      return this;
    }

    /**
     * Query for members in this Channel.
     *
     * @method forChannel
     * @param  {String} channelId
     */

  }, {
    key: 'forChannel',
    value: function forChannel(channelId) {
      if (channelId.indexOf('layer:///channels/') === 0) {
        this._query.predicate = 'channel.id = \'' + channelId + '\'';
      } else {
        this._query.predicate = '';
      }
      return this;
    }

    /**
     * Returns the built query object to send to the server.
     *
     * Called by layer.QueryBuilder. You should not need to call this.
     *
     * @method build
     */

  }, {
    key: 'build',
    value: function build() {
      return this._query;
    }
  }]);

  return MembersQuery;
}();

/**
 * Query builder class generating queries for a set of Identities followed by this user.
 *
 * Used in Creating and Updating layer.Query instances.
 *
 * To get started:
 *
 *      var qBuilder = QueryBuilder
 *       .identities()
 *       .paginationWindow(100);
 *      var query = client.createQuery(qBuilder);
 *
 * @class layer.QueryBuilder.IdentitiesQuery
 */


var IdentitiesQuery = function () {

  /**
   * Creates a new query builder for a set of conversations.
   *
   * Standard use is without any arguments.
   *
   * @method constructor
   * @param  {Object} [query=null]
   */
  function IdentitiesQuery(query) {
    _classCallCheck(this, IdentitiesQuery);

    if (query) {
      this._query = {
        model: query.model,
        returnType: query.returnType,
        dataType: query.dataType,
        paginationWindow: query.paginationWindow
      };
    } else {
      this._query = {
        model: Query.Identity,
        returnType: 'object',
        dataType: 'object',
        paginationWindow: Query.prototype.paginationWindow
      };
    }
  }

  /**
   * Sets the pagination window/number of messages to fetch from the local cache or server.
   *
   * Currently only positive integers are supported.
   *
   * @method paginationWindow
   * @param  {number} win
   * @return {layer.QueryBuilder} this
   */


  _createClass(IdentitiesQuery, [{
    key: 'paginationWindow',
    value: function paginationWindow(win) {
      this._query.paginationWindow = win;
      return this;
    }

    /**
     * Returns the built query object to send to the server.
     *
     * Called by layer.QueryBuilder. You should not need to call this.
     *
     * @method build
     */

  }, {
    key: 'build',
    value: function build() {
      return this._query;
    }
  }]);

  return IdentitiesQuery;
}();

/**
 * Query builder class. Used with layer.Query to specify what local/remote
 * data changes to subscribe to.  For examples, see layer.QueryBuilder.MessagesQuery
 * and layer.QueryBuilder.ConversationsQuery.  This static class is used to instantiate
 * MessagesQuery and ConversationsQuery Builder instances:
 *
 *      var conversationsQueryBuilder = QueryBuilder.conversations();
 *      var messagesQueryBuidler = QueryBuilder.messages();
 *
 * Should you use these instead of directly using the layer.Query class?
 * That is a matter of programming style and preference, there is no
 * correct answer.
 *
 * @class layer.QueryBuilder
 */


var QueryBuilder = {

  /**
   * Create a new layer.MessagesQuery instance.
   *
   * @method messages
   * @static
   * @returns {layer.QueryBuilder.MessagesQuery}
   */
  messages: function messages() {
    return new MessagesQuery();
  },


  /**
   * Create a new layer.AnnouncementsQuery instance.
   *
   * @method announcements
   * @static
   * @returns {layer.QueryBuilder.AnnouncementsQuery}
   */
  announcements: function announcements() {
    return new AnnouncementsQuery();
  },


  /**
   * Create a new layer.ConversationsQuery instance.
   *
   * @method conversations
   * @static
   * @returns {layer.QueryBuilder.ConversationsQuery}
   */
  conversations: function conversations() {
    return new ConversationsQuery();
  },


  /**
   * Create a new layer.ChannelsQuery instance.
   *
   * @method channels
   * @static
   * @returns {layer.QueryBuilder.ChannelsQuery}
   */
  channels: function channels() {
    return new ChannelsQuery();
  },


  /**
   * Create a new layer.MembersQuery instance.
   *
   * @method members
   * @static
   * @returns {layer.QueryBuilder.MembersQuery}
   */
  members: function members() {
    return new MembersQuery();
  },


  /**
   * Create a new layer.IdentitiesQuery instance.
   *
   * @method identities
   * @static
   * @returns {layer.QueryBuilder.IdentitiesQuery}
   */
  identities: function identities() {
    return new IdentitiesQuery();
  },


  /**
   * Takes the return value of QueryBuilder.prototype.build and creates a
   * new QueryBuilder.
   *
   * Used within layer.Query.prototype.toBuilder.
   *
   * @method fromQueryObject
   * @private
   * @param {Object} obj
   * @static
   */
  fromQueryObject: function fromQueryObject(obj) {
    switch (obj.model) {
      case Query.Message:
        return new MessagesQuery(obj);
      case Query.Announcement:
        return new AnnouncementsQuery(obj);
      case Query.Conversation:
        return new ConversationsQuery(obj);
      case Query.Channel:
        return new ChannelsQuery(obj);
      case Query.Identity:
        return new IdentitiesQuery(obj);
      case Query.Membership:
        return new MembersQuery(obj);
      default:
        return null;
    }
  }
};

module.exports = QueryBuilder;


},{"./query":115}],115:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * There are two ways to instantiate this class:
 *
 *      // 1. Using a Query Builder
 *      var conversationQueryBuilder = QueryBuilder.conversations().sortBy('lastMessage');
 *      var conversationQuery = client.createQuery(queryBuilder);
 *      var channelQueryBuilder = QueryBuilder.channels();
 *      var channelQuery = client.createQuery(queryBuilder);
 *
 *      // 2. Passing properties directly
 *      var conversationQuery = client.createQuery({
 *        client: client,
 *        model: layer.Query.Conversation,
 *        sortBy: [{'createdAt': 'desc'}]
 *      });
 *      var channelQuery = client.createQuery({
 *        client: client,
 *        model: layer.Query.Channel
 *      });
 *
 * You can change the data selected by your query any time you want using:
 *
 *      query.update({
 *        paginationWindow: 200
 *      });
 *
 *      query.update({
 *        predicate: 'conversation.id = "' + conv.id + "'"
 *      });
 *
 *     // Or use the Query Builder:
 *     queryBuilder.paginationWindow(200);
 *     query.update(queryBuilder);
 *
 * You can release data held in memory by your queries when done with them:
 *
 *      query.destroy();
 *
 * #### Query Types
 *
 * For documentation on creating each of these types of queries, see the specified Query Subclass:
 *
 * * layer.ConversationsQuery
 * * layer.ChannelsQuery
 * * layer.MessagesQuery
 * * layer.IdentitiesQuery
 * * layer.MembersQuery
 *
 * #### dataType
 *
 * The layer.Query.dataType property lets you specify what type of data shows up in your results:
 *
 * ```javascript
 * var query = client.createQuery({
 *     model: layer.Query.Message,
 *     predicate: "conversation.id = 'layer:///conversations/uuid'",
 *     dataType: layer.Query.InstanceDataType
 * })
 *
 * var query = client.createQuery({
 *     model: layer.Query.Message,
 *     predicate: "conversation.id = 'layer:///conversations/uuid'",
 *     dataType: layer.Query.ObjectDataType
 * })
 * ```
 *
 * The property defaults to layer.Query.InstanceDataType.  Instances support methods and let you subscribe to events for direct notification
 * of changes to any of the results of your query:
 *
* ```javascript
 * query.data[0].on('messages:change', function(evt) {
 *     alert('The first message has had a property change; probably isRead or recipient_status!');
 * });
 * ```
 *
 * A value of layer.Query.ObjectDataType will cause the data to be an array of immutable objects rather than instances.  One can still get an instance from the POJO:
 *
 * ```javascript
 * var m = client.getMessage(query.data[0].id);
 * m.on('messages:change', function(evt) {
 *     alert('The first message has had a property change; probably isRead or recipient_status!');
 * });
 * ```
 *
 * ## Query Events
 *
 * Queries fire events whenever their data changes.  There are 5 types of events;
 * all events are received by subscribing to the `change` event.
 *
 * ### 1. Data Events
 *
 * The Data event is fired whenever a request is sent to the server for new query results.  This could happen when first creating the query, when paging for more data, or when changing the query's properties, resulting in a new request to the server.
 *
 * The Event object will have an `evt.data` array of all newly added results.  But frequently you may just want to use the `query.data` array and get ALL results.
 *
 * ```javascript
 * query.on('change', function(evt) {
 *   if (evt.type === 'data') {
 *      var newData = evt.data;
 *      var allData = query.data;
 *   }
 * });
 * ```
 *
 * Note that `query.on('change:data', function(evt) {}` is also supported.
 *
 * ### 2. Insert Events
 *
 * A new Conversation or Message was created. It may have been created locally by your user, or it may have been remotely created, received via websocket, and added to the Query's results.
 *
 * The layer.LayerEvent.target property contains the newly inserted object.
 *
 * ```javascript
 *  query.on('change', function(evt) {
 *    if (evt.type === 'insert') {
 *       var newItem = evt.target;
 *       var allData = query.data;
 *    }
 *  });
 * ```
 *
 * Note that `query.on('change:insert', function(evt) {}` is also supported.
 *
 * ### 3. Remove Events
 *
 * A Conversation or Message was deleted. This may have been deleted locally by your user, or it may have been remotely deleted, a notification received via websocket, and removed from the Query results.
 *
 * The layer.LayerEvent.target property contains the removed object.
 *
 * ```javascript
 * query.on('change', function(evt) {
 *   if (evt.type === 'remove') {
 *       var removedItem = evt.target;
 *       var allData = query.data;
 *   }
 * });
 * ```
 *
 * Note that `query.on('change:remove', function(evt) {}` is also supported.
 *
 * ### 4. Reset Events
 *
 * Any time your query's model or predicate properties have been changed
 * the query is reset, and a new request is sent to the server.  The reset event informs your UI that the current result set is empty, and that the reason its empty is that it was `reset`.  This helps differentiate it from a `data` event that returns an empty array.
 *
 * ```javascript
 * query.on('change', function(evt) {
 *   if (evt.type === 'reset') {
 *       var allData = query.data; // []
 *   }
 * });
 * ```
 *
 * Note that `query.on('change:reset', function(evt) {}` is also supported.
 *
 * ### 5. Property Events
 *
 * If any properties change in any of the objects listed in your layer.Query.data property, a `property` event will be fired.
 *
 * The layer.LayerEvent.target property contains object that was modified.
 *
 * See layer.LayerEvent.changes for details on how changes are reported.
 *
 * ```javascript
 * query.on('change', function(evt) {
 *   if (evt.type === 'property') {
 *       var changedItem = evt.target;
 *       var isReadChanges = evt.getChangesFor('isRead');
 *       var recipientStatusChanges = evt.getChangesFor('recipientStatus');
 *       if (isReadChanges.length) {
 *           ...
 *       }
 *
 *       if (recipientStatusChanges.length) {
 *           ...
 *       }
 *   }
 * });
 *```
 * Note that `query.on('change:property', function(evt) {}` is also supported.
 *
 * ### 6. Move Events
 *
 * Occasionally, a property change will cause an item to be sorted differently, causing a Move event.
 * The event will tell you what index the item was at, and where it has moved to in the Query results.
 * This is currently only supported for Conversations.
 *
 * ```javascript
 * query.on('change', function(evt) {
 *   if (evt.type === 'move') {
 *       var changedItem = evt.target;
 *       var oldIndex = evt.fromIndex;
 *       var newIndex = evt.newIndex;
 *       var moveNode = list.childNodes[oldIndex];
 *       list.removeChild(moveNode);
 *       list.insertBefore(moveNode, list.childNodes[newIndex]);
 *   }
 * });
 *```
 * Note that `query.on('change:move', function(evt) {}` is also supported.
 *
 * @class  layer.Query
 * @extends layer.Root
 *
 */
var Root = require('../root');
var LayerError = require('../layer-error');
var Logger = require('../logger');
var Utils = require('../client-utils');

var Query = function (_Root) {
  _inherits(Query, _Root);

  function Query() {
    _classCallCheck(this, Query);

    var options = void 0;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 2) {
      options = args[1].build();
      options.client = args[0];
    } else {
      options = args[0];
    }

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Query).call(this, options));

    _this.predicate = _this._fixPredicate(options.predicate || '');

    if ('paginationWindow' in options) {
      var paginationWindow = options.paginationWindow;
      _this.paginationWindow = Math.min(_this._getMaxPageSize(), options.paginationWindow);
      if (options.paginationWindow !== paginationWindow) {
        Logger.warn('paginationWindow value ' + paginationWindow + ' in Query constructor ' + ('excedes Query.MaxPageSize of ' + _this._getMaxPageSize()));
      }
    }

    _this.data = [];
    _this._initialPaginationWindow = _this.paginationWindow;
    if (!_this.client) throw new Error(LayerError.dictionary.clientMissing);
    _this.client.on('all', _this._handleEvents, _this);

    if (!_this.client.isReady) {
      _this.client.once('ready', function () {
        return _this._run();
      }, _this);
    } else {
      _this._run();
    }
    return _this;
  }

  /**
   * Cleanup and remove this Query, its subscriptions and data.
   *
   * @method destroy
   */


  _createClass(Query, [{
    key: 'destroy',
    value: function destroy() {
      this.data = [];
      this._triggerChange({
        data: [],
        type: 'reset'
      });
      this.client.off(null, null, this);
      this.client._removeQuery(this);
      this.data = null;
      _get(Object.getPrototypeOf(Query.prototype), 'destroy', this).call(this);
    }

    /**
     * Get the maximum number of items allowed in a page
     *
     * @method _getMaxPageSize
     * @private
     * @returns {number}
     */

  }, {
    key: '_getMaxPageSize',
    value: function _getMaxPageSize() {
      return this.constructor.MaxPageSize;
    }

    /**
     * Updates properties of the Query.
     *
     * Currently supports updating:
     *
     * * paginationWindow
     * * predicate
     * * sortBy
     *
     * Any change to predicate or model results in clearing all data from the
     * query's results and triggering a change event with [] as the new data.
     *
     * ```
     * query.update({
     *    paginationWindow: 200
     * });
     * ```
     *
     * ```
     * query.update({
     *    paginationWindow: 100,
     *    predicate: 'conversation.id = "layer:///conversations/UUID"'
     * });
     * ```
     *
     * ```
     * query.update({
     *    sortBy: [{"lastMessage.sentAt": "desc"}]
     * });
     * ```
     *
     * @method update
     * @param  {Object} options
     * @param {string} [options.predicate] - A new predicate for the query
     * @param {string} [options.model] - A new model for the Query
     * @param {number} [paginationWindow] - Increase/decrease our result size to match this pagination window.
     * @return {layer.Query} this
     */

  }, {
    key: 'update',
    value: function update() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var needsRefresh = void 0,
          needsRecreate = void 0;

      var optionsBuilt = typeof options.build === 'function' ? options.build() : options;

      if ('paginationWindow' in optionsBuilt && this.paginationWindow !== optionsBuilt.paginationWindow) {
        this.paginationWindow = Math.min(this._getMaxPageSize() + this.size, optionsBuilt.paginationWindow);
        if (this.paginationWindow < optionsBuilt.paginationWindow) {
          Logger.warn('paginationWindow value ' + optionsBuilt.paginationWindow + ' in Query.update() ' + ('increases size greater than Query.MaxPageSize of ' + this._getMaxPageSize()));
        }
        needsRefresh = true;
      }
      if ('model' in optionsBuilt && this.model !== optionsBuilt.model) {
        throw new Error(LayerError.dictionary.modelImmutable);
      }

      if ('predicate' in optionsBuilt) {
        var predicate = this._fixPredicate(optionsBuilt.predicate || '');
        if (this.predicate !== predicate) {
          this.predicate = predicate;
          needsRecreate = true;
        }
      }
      if ('sortBy' in optionsBuilt && JSON.stringify(this.sortBy) !== JSON.stringify(optionsBuilt.sortBy)) {
        this.sortBy = optionsBuilt.sortBy;
        needsRecreate = true;
      }
      if (needsRecreate) {
        this._reset();
      }
      if (needsRecreate || needsRefresh) this._run();
      return this;
    }

    /**
     * Normalizes the predicate.
     *
     * @method _fixPredicate
     * @param {String} inValue
     * @private
     */

  }, {
    key: '_fixPredicate',
    value: function _fixPredicate(inValue) {
      if (inValue) throw new Error(LayerError.dictionary.predicateNotSupported);
      return '';
    }

    /**
     * After redefining the query, reset it: remove all data/reset all state.
     *
     * @method _reset
     * @private
     */

  }, {
    key: '_reset',
    value: function _reset() {
      if (this._isSyncingId) {
        clearTimeout(this._isSyncingId);
        this._isSyncingId = 0;
      }
      this.totalSize = 0;
      var data = this.data;
      this.data = [];
      this.client._checkAndPurgeCache(data);
      this.isFiring = false;
      this._predicate = null;
      this._nextDBFromId = '';
      this._nextServerFromId = '';
      this._isServerSyncing = false;
      this._isSyncingCount = 0;
      this.pagedToEnd = false;
      this.paginationWindow = this._initialPaginationWindow;
      this._triggerChange({
        data: [],
        type: 'reset'
      });
    }

    /**
     * Reset your query to its initial state and then rerun it.
     *
     * @method reset
     */

  }, {
    key: 'reset',
    value: function reset() {
      this._reset();
      this._run();
    }

    /**
     * Execute the query.
     *
     * No, don't murder it, just fire it.  No, don't make it unemployed,
     * just connect to the server and get the results.
     *
     * @method _run
     * @private
     */

  }, {
    key: '_run',
    value: function _run() {
      // Find the number of items we need to request.
      var pageSize = Math.min(this.paginationWindow - this.size, this._getMaxPageSize());

      // If there is a reduction in pagination window, then this variable will be negative, and we can shrink
      // the data.
      if (pageSize < 0) {
        var removedData = this.data.slice(this.paginationWindow);
        this.data = this.data.slice(0, this.paginationWindow);
        this.client._checkAndPurgeCache(removedData);
        this.pagedToEnd = false;
        this._triggerAsync('change', { data: [] });
      } else if (pageSize === 0 || this.pagedToEnd) {
        // No need to load 0 results.
      } else {
        this._fetchData(pageSize);
      }
    }
  }, {
    key: '_fetchData',
    value: function _fetchData(pageSize) {}
    // Noop


    /**
     * Returns the sort field for the query.
     *
     * Returns One of:
     *
     * * 'position' (Messages only)
     * * 'last_message' (Conversations only)
     * * 'created_at' (Conversations only)
     * @method _getSortField
     * @private
     * @return {String} sort key used by server
     */

  }, {
    key: '_getSortField',
    value: function _getSortField() {}
    // Noop


    /**
     * Process the results of the `_run` method; calls __appendResults.
     *
     * @method _processRunResults
     * @private
     * @param  {Object} results - Full xhr response object with server results
     * @param {Number} pageSize - Number of entries that were requested
     */

  }, {
    key: '_processRunResults',
    value: function _processRunResults(results, requestUrl, pageSize) {
      var _this2 = this;

      if (requestUrl !== this._firingRequest || this.isDestroyed) return;
      // _isSyncingCount == 9 means we've waited roughly 30 seconds; give up if we've waited longer, and report the results that we have.
      var isSyncing = results.xhr.getResponseHeader('Layer-Conversation-Is-Syncing') === 'true' && this._isSyncingCount < 9;

      // isFiring is false... unless we are still syncing
      this.isFiring = isSyncing;
      this._firingRequest = '';
      if (results.success) {
        if (isSyncing) {
          var duration = Utils.getExponentialBackoffSeconds(30, Math.min(10, this._isSyncingCount));
          this._isSyncingId = setTimeout(function () {
            _this2._isSyncingId = 0;
            _this2._run();
          }, Math.floor(duration * 1000));
          this._isSyncingCount++;
        } else {
          this._isSyncingCount = 0;
          this._isSyncingId = 0;
          this.totalSize = Number(results.xhr.getResponseHeader('Layer-Count'));
          this._appendResults(results, false);

          if (results.data.length < pageSize) this.pagedToEnd = true;
        }
      } else if (results.data.getNonce()) {
        this.client.once('ready', function () {
          _this2._run();
        });
      } else {
        this.trigger('error', { error: results.data });
      }
    }

    /**
     * Appends arrays of data to the Query results.
     *
     * @method  _appendResults
     * @private
     */

  }, {
    key: '_appendResults',
    value: function _appendResults(results, fromDb) {
      var _this3 = this;

      // For all results, register them with the client
      // If already registered with the client, properties will be updated as needed
      // Database results rather than server results will arrive already registered.
      results.data.forEach(function (item) {
        if (!(item instanceof Root)) _this3.client._createObject(item);
      });

      // Filter results to just the new results
      var newResults = results.data.filter(function (item) {
        return _this3._getIndex(item.id) === -1;
      });

      // Update the next ID to use in pagination
      var resultLength = results.data.length;
      if (resultLength) {
        if (fromDb) {
          this._nextDBFromId = results.data[resultLength - 1].id;
        } else {
          this._nextServerFromId = results.data[resultLength - 1].id;
        }
      }

      // Update this.data
      if (this.dataType === Query.ObjectDataType) {
        this.data = [].concat(this.data);
      }

      // Insert the results... if the results are a match
      newResults.forEach(function (itemIn) {
        var item = _this3.client.getObject(itemIn.id);
        if (item) _this3._appendResultsSplice(item);
      });

      // Trigger the change event
      this._triggerChange({
        type: 'data',
        data: newResults.map(function (item) {
          return _this3._getData(_this3.client.getObject(item.id));
        }),
        query: this,
        target: this.client
      });
    }
  }, {
    key: '_appendResultsSplice',
    value: function _appendResultsSplice(item) {}
    // Noop


    /**
     * Returns a correctly formatted object representing a result.
     *
     * Format is specified by the `dataType` property.
     *
     * @method _getData
     * @private
     * @param  {layer.Root} item - Conversation, Message, etc... instance
     * @return {Object} - Conversation, Message, etc... instance or Object
     */

  }, {
    key: '_getData',
    value: function _getData(item) {
      if (this.dataType === Query.ObjectDataType) {
        return item.toObject();
      }
      return item;
    }

    /**
     * Returns an instance regardless of whether the input is instance or object
     * @method _getInstance
     * @private
     * @param {layer.Root|Object} item - Conversation, Message, etc... object/instance
     * @return {layer.Root}
     */

  }, {
    key: '_getInstance',
    value: function _getInstance(item) {
      if (item instanceof Root) return item;
      return this.client.getObject(item.id);
    }

    /**
     * Ask the query for the item matching the ID.
     *
     * Returns undefined if the ID is not found.
     *
     * @method _getItem
     * @private
     * @param  {string} id
     * @return {Object} Conversation, Message, etc... object or instance
     */

  }, {
    key: '_getItem',
    value: function _getItem(id) {
      var index = this._getIndex(id);
      return index === -1 ? null : this.data[index];
    }

    /**
     * Get the index of the item represented by the specified ID; or return -1.
     *
     * @method _getIndex
     * @private
     * @param  {string} id
     * @return {number}
     */

  }, {
    key: '_getIndex',
    value: function _getIndex(id) {
      for (var index = 0; index < this.data.length; index++) {
        if (this.data[index].id === id) return index;
      }
      return -1;
    }

    /**
     * Handle any change event received from the layer.Client.
     *
     * These can be caused by websocket events, as well as local
     * requests to create/delete/modify Conversations and Messages.
     *
     * The event does not necessarily apply to this Query, but the Query
     * must examine it to determine if it applies.
     *
     * @method _handleEvents
     * @private
     * @param {string} eventName - "messages:add", "conversations:change"
     * @param {layer.LayerEvent} evt
     */

  }, {
    key: '_handleEvents',
    value: function _handleEvents(eventName, evt) {}
    // Noop


    /**
     * Handle a change event... for models that don't require custom handling
     *
     * @method _handleChangeEvent
     * @param {layer.LayerEvent} evt
     * @private
     */

  }, {
    key: '_handleChangeEvent',
    value: function _handleChangeEvent(name, evt) {
      var index = this._getIndex(evt.target.id);

      if (index !== -1) {
        if (this.dataType === Query.ObjectDataType) {
          this.data = [].concat(_toConsumableArray(this.data.slice(0, index)), [evt.target.toObject()], _toConsumableArray(this.data.slice(index + 1)));
        }
        this._triggerChange({
          type: 'property',
          target: this._getData(evt.target),
          query: this,
          isChange: true,
          changes: evt.changes
        });
      }
    }
  }, {
    key: '_handleAddEvent',
    value: function _handleAddEvent(name, evt) {
      var _this4 = this;

      var list = evt[name].filter(function (obj) {
        return _this4._getIndex(obj.id) === -1;
      }).map(function (obj) {
        return _this4._getData(obj);
      });

      // Add them to our result set and trigger an event for each one
      if (list.length) {
        (function () {
          var data = _this4.data = _this4.dataType === Query.ObjectDataType ? [].concat(_this4.data) : _this4.data;
          list.forEach(function (item) {
            return data.push(item);
          });

          _this4.totalSize += list.length;

          // Index calculated above may shift after additional insertions.  This has
          // to be done after the above insertions have completed.
          list.forEach(function (item) {
            _this4._triggerChange({
              type: 'insert',
              index: _this4.data.indexOf(item),
              target: item,
              query: _this4
            });
          });
        })();
      }
    }
  }, {
    key: '_handleRemoveEvent',
    value: function _handleRemoveEvent(name, evt) {
      var _this5 = this;

      var removed = [];
      evt[name].forEach(function (obj) {
        var index = _this5._getIndex(obj.id);

        if (index !== -1) {
          if (obj.id === _this5._nextDBFromId) _this5._nextDBFromId = _this5._updateNextFromId(index);
          if (obj.id === _this5._nextServerFromId) _this5._nextServerFromId = _this5._updateNextFromId(index);
          removed.push({
            data: obj,
            index: index
          });
          if (_this5.dataType === Query.ObjectDataType) {
            _this5.data = [].concat(_toConsumableArray(_this5.data.slice(0, index)), _toConsumableArray(_this5.data.slice(index + 1)));
          } else {
            _this5.data.splice(index, 1);
          }
        }
      });

      this.totalSize -= removed.length;
      removed.forEach(function (removedObj) {
        _this5._triggerChange({
          type: 'remove',
          target: _this5._getData(removedObj.data),
          index: removedObj.index,
          query: _this5
        });
      });
    }

    /**
     * If the current next-id is removed from the list, get a new nextId.
     *
     * If the index is greater than 0, whatever is after that index may have come from
     * websockets or other sources, so decrement the index to get the next safe paging id.
     *
     * If the index if 0, even if there is data, that data did not come from paging and
     * can not be used safely as a paging id; return '';
     *
     * @method _updateNextFromId
     * @private
     * @param {number} index - Current index of the nextFromId
     * @returns {string} - Next ID or empty string
     */

  }, {
    key: '_updateNextFromId',
    value: function _updateNextFromId(index) {
      if (index > 0) return this.data[index - 1].id;else return '';
    }

    /*
     * If this is ever changed to be async, make sure that destroy() still triggers synchronous events
     */

  }, {
    key: '_triggerChange',
    value: function _triggerChange(evt) {
      if (this.isDestroyed || this.client._inCleanup) return;
      this.trigger('change', evt);
      this.trigger('change:' + evt.type, evt);
    }
  }, {
    key: 'toString',
    value: function toString() {
      return this.id;
    }
  }]);

  return Query;
}(Root);

Query.prefixUUID = 'layer:///queries/';

/**
 * Query for Conversations.
 *
 * Use this value in the layer.Query.model property.
 * @type {string}
 * @static
 */
Query.Conversation = 'Conversation';

/**
 * Query for Channels.
 *
 * Use this value in the layer.Query.model property.
 * @type {string}
 * @static
 */
Query.Channel = 'Channel';

/**
 * Query for Messages.
 *
 * Use this value in the layer.Query.model property.
 * @type {string}
 * @static
 */
Query.Message = 'Message';

/**
 * Query for Announcements.
 *
 * Use this value in the layer.Query.model property.
 * @type {string}
 * @static
 */
Query.Announcement = 'Announcement';

/**
 * Query for Identities.
 *
 * Use this value in the layer.Query.model property.
 * @type {string}
 * @static
 */
Query.Identity = 'Identity';

/**
 * Query for Members of a Channel.
 *
 * Use this value in the layer.Query.model property.
 * @type {string}
 * @static
 */
Query.Membership = 'Membership';

/**
 * Get data as POJOs/immutable objects.
 *
 * This value of layer.Query.dataType will cause your Query data and events to provide Messages/Conversations as immutable objects.
 *
 * @type {string}
 * @static
 */
Query.ObjectDataType = 'object';

/**
 * Get data as instances of layer.Message and layer.Conversation.
 *
 * This value of layer.Query.dataType will cause your Query data and events to provide Messages/Conversations as instances.
 *
 * @type {string}
 * @static
 */
Query.InstanceDataType = 'instance';

/**
 * Set the maximum page size for queries.
 *
 * @type {number}
 * @static
 */
Query.MaxPageSize = 100;

/**
 * Access the number of results currently loaded.
 *
 * @type {Number}
 * @readonly
 */
Object.defineProperty(Query.prototype, 'size', {
  enumerable: true,
  get: function get() {
    return !this.data ? 0 : this.data.length;
  }
});

/** Access the total number of results on the server.
 *
 * Will be 0 until the first query has successfully loaded results.
 *
 * @type {Number}
 * @readonly
 */
Query.prototype.totalSize = 0;

/**
 * Access to the client so it can listen to websocket and local events.
 *
 * @type {layer.Client}
 * @protected
 * @readonly
 */
Query.prototype.client = null;

/**
 * Query results.
 *
 * Array of data resulting from the Query; either a layer.Root subclass.
 *
 * or plain Objects
 * @type {Object[]}
 * @readonly
 */
Query.prototype.data = null;

/**
 * Specifies the type of data being queried for.
 *
 * Model is one of
 *
 * * layer.Query.Conversation
 * * layer.Query.Channel
 * * layer.Query.Message
 * * layer.Query.Announcement
 * * layer.Query.Identity
 *
 * Value can be set via constructor and layer.Query.update().
 *
 * @type {String}
 * @readonly
 */
Query.prototype.model = '';

/**
 * What type of results to request of the server.
 *
 * Not yet supported; returnType is one of
 *
 * * object
 * * id
 * * count
 *
 *  Value set via constructor.
 + *
 * This Query API is designed only for use with 'object' at this time; waiting for updates to server for
 * this functionality.
 *
 * @type {String}
 * @readonly
 */
Query.prototype.returnType = 'object';

/**
 * Specify what kind of data array your application requires.
 *
 * Used to specify query dataType.  One of
 * * Query.ObjectDataType
 * * Query.InstanceDataType
 *
 * @type {String}
 * @readonly
 */
Query.prototype.dataType = Query.InstanceDataType;

/**
 * Number of results from the server to request/cache.
 *
 * The pagination window can be increased to download additional items, or decreased to purge results
 * from the data property.
 *
 *     query.update({
 *       paginationWindow: 150
 *     })
 *
 * This call will aim to achieve 150 results.  If it previously had 100,
 * then it will load 50 more. If it previously had 200, it will drop 50.
 *
 * Note that the server will only permit 100 at a time.
 *
 * @type {Number}
 * @readonly
 */
Query.prototype.paginationWindow = 100;

/**
 * Sorting criteria for Conversation Queries.
 *
 * Only supports an array of one field/element.
 * Only supports the following options:
 *
 * ```
 * query.update({sortBy: [{'createdAt': 'desc'}]})
 * query.update({sortBy: [{'lastMessage.sentAt': 'desc'}]
 *
 * client.createQuery({
 *   sortBy: [{'lastMessage.sentAt': 'desc'}]
 * });
 * client.createQuery({
 *   sortBy: [{'lastMessage.sentAt': 'desc'}]
 * });
 * ```
 *
 * Why such limitations? Why this structure?  The server will be exposing a Query API at which point the
 * above sort options will make a lot more sense, and full sorting will be provided.
 *
 * @type {String}
 * @readonly
 */
Query.prototype.sortBy = null;

/**
 * This value tells us what to reset the paginationWindow to when the query is redefined.
 *
 * @type {Number}
 * @private
 */
Query.prototype._initialPaginationWindow = 100;

/**
 * Your Query's WHERE clause.
 *
 * Currently, the only queries supported are:
 *
 * ```
 *  "conversation.id = 'layer:///conversations/uuid'"
 *  "channel.id = 'layer:///channels/uuid"
 * ```
 *
 * Note that both ' and " are supported.
 *
 * @type {string}
 * @readonly
 */
Query.prototype.predicate = null;

/**
 * True if the Query is connecting to the server.
 *
 * It is not gaurenteed that every `update()` will fire a request to the server.
 * For example, updating a paginationWindow to be smaller,
 * Or changing a value to the existing value would cause the request not to fire.
 *
 * Recommended pattern is:
 *
 *      query.update({paginationWindow: 50});
 *      if (!query.isFiring) {
 *        alert("Done");
 *      } else {
 *          query.once("change", function(evt) {
 *            if (evt.type == "data") alert("Done");
 *          });
 *      }
 *
 * @type {Boolean}
 * @readonly
 */
Query.prototype.isFiring = false;

/**
 * True if we have reached the last result, and further paging will just return []
 *
 * @type {Boolean}
 * @readonly
 */
Query.prototype.pagedToEnd = false;

/**
 * The last request fired.
 *
 * If multiple requests are inflight, the response
 * matching this request is the ONLY response we will process.
 * @type {String}
 * @private
 */
Query.prototype._firingRequest = '';

/**
 * The ID to use in paging the server.
 *
 * Why not just use the ID of the last item in our result set?
 * Because as we receive websocket events, we insert and append items to our data.
 * That websocket event may not in fact deliver the NEXT item in our data, but simply an item, that sequentially
 * belongs at the end despite skipping over other items of data.  Paging should not be from this new item, but
 * only the last item pulled via this query from the server.
 *
 * @type {string}
 */
Query.prototype._nextServerFromId = '';

/**
 * The ID to use in paging the database.
 *
 * Why not just use the ID of the last item in our result set?
 * Because as we receive websocket events, we insert and append items to our data.
 * That websocket event may not in fact deliver the NEXT item in our data, but simply an item, that sequentially
 * belongs at the end despite skipping over other items of data.  Paging should not be from this new item, but
 * only the last item pulled via this query from the database.
 *
 * @type {string}
 */
Query.prototype._nextDBFromId = '';

/**
 * Number of times we've gotten back an `is-syncing` response from the server implying results are incomplete
 * and not properly ordered.
 *
 * @private {Number}
 */
Query.prototype._isSyncingCount = 0;

Query._supportedEvents = [
/**
 * The query data has changed; any change event will cause this event to trigger.
 * @event change
 */
'change',

/**
 * A new page of data has been loaded from the server
 * @event 'change:data'
 */
'change:data',

/**
 * All data for this query has been reset due to a change in the Query predicate.
 * @event 'change:reset'
 */
'change:reset',

/**
 * An item of data within this Query has had a property change its value.
 * @event 'change:property'
 */
'change:property',

/**
 * A new item of data has been inserted into the Query. Not triggered by loading
 * a new page of data from the server, but is triggered by locally creating a matching
 * item of data, or receiving a new item of data via websocket.
 * @event 'change:insert'
 */
'change:insert',

/**
 * An item of data has been removed from the Query. Not triggered for every removal, but
 * is triggered by locally deleting a result, or receiving a report of deletion via websocket.
 * @event 'change:remove'
 */
'change:remove',

/**
 * An item of data has been moved to a new index in the Query results.
 * @event 'change:move'
 */
'change:move',

/**
 * The query data failed to load from the server.
 * @event error
 */
'error'].concat(Root._supportedEvents);

Root.initClass.apply(Query, [Query, 'Query']);

module.exports = Query;


},{"../client-utils":82,"../layer-error":86,"../logger":88,"../root":116}],116:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Utils = require('./client-utils');
var LayerEvent = require('./layer-event');
var LayerError = require('./layer-error');
var Events = require('backbone-events-standalone/backbone-events-standalone');
var Logger = require('./logger');

/*
 * Provides a system bus that can be accessed by all components of the system.
 * Currently used to listen to messages sent via postMessage, but envisioned to
 * do far more.
 */
function EventClass() {}
EventClass.prototype = Events;

var SystemBus = new EventClass();
if (typeof postMessage === 'function') {
  addEventListener('message', function (event) {
    if (event.data.type === 'layer-delayed-event') {
      SystemBus.trigger(event.data.internalId + '-delayed-event');
    }
  });
}

// Used to generate a unique internalId for every Root instance
var uniqueIds = {};

// Regex for splitting an event string such as obj.on('evtName1 evtName2 evtName3')
var eventSplitter = /\s+/;

/**
 * The root class of all layer objects. Provides the following utilities
 *
 * 1. Mixes in the Backbone event model
 *
 *        var person = new Person();
 *        person.on('destroy', function() {
 *            console.log('I have been destroyed!');
 *        });
 *
 *        // Fire the console log handler:
 *        person.trigger('destroy');
 *
 *        // Unsubscribe
 *        person.off('destroy');
 *
 * 2. Adds a subscriptions object so that any event handlers on an object can be quickly found and removed
 *
 *        var person1 = new Person();
 *        var person2 = new Person();
 *        person2.on('destroy', function() {
 *            console.log('I have been destroyed!');
 *        }, person1);
 *
 *        // Pointers to person1 held onto by person2 are removed
 *        person1.destroy();
 *
 * 3. Adds support for event listeners in the constructor
 *    Any event handler can be passed into the constructor
 *    just as though it were a property.
 *
 *        var person = new Person({
 *            age: 150,
 *            destroy: function() {
 *                console.log('I have been destroyed!');
 *            }
 *        });
 *
 * 4. A _disableEvents property
 *
 *        myMethod() {
 *          if (this.isInitializing) {
 *              this._disableEvents = true;
 *
 *              // Event only received if _disableEvents = false
 *              this.trigger('destroy');
 *              this._disableEvents = false;
 *          }
 *        }
 *
 * 5. A _supportedEvents static property for each class
 *
 *     This property defines which events can be triggered.
 *
 *     * Any attempt to trigger
 *       an event not in _supportedEvents will log an error.
 *     * Any attempt to register a listener for an event not in _supportedEvents will
 *     *throw* an error.
 *
 *     This allows us to insure developers only subscribe to valid events.
 *
 *     This allows us to control what events can be fired and which ones blocked.
 *
 * 6. Adds an internalId property
 *
 *        var person = new Person();
 *        console.log(person.internalId); // -> 'Person1'
 *
 * 7. Adds a toObject method to create a simplified Plain Old Javacript Object from your object
 *
 *        var person = new Person();
 *        var simplePerson = person.toObject();
 *
 * 8. Provides __adjustProperty method support
 *
 *     For any property of a class, an `__adjustProperty` method can be defined.  If its defined,
 *     it will be called prior to setting that property, allowing:
 *
 *     A. Modification of the value that is actually set
 *     B. Validation of the value; throwing errors if invalid.
 *
 * 9. Provides __udpateProperty method support
 *
 *     After setting any property for which there is an `__updateProperty` method defined,
 *     the method will be called, allowing the new property to be applied.
 *
 *     Typically used for
 *
 *     A. Triggering events
 *     B. Firing XHR requests
 *     C. Updating the UI to match the new property value
 *
 *
 * @class layer.Root
 * @abstract
 * @author Michael Kantor
 */

var Root = function (_EventClass) {
  _inherits(Root, _EventClass);

  /**
   * Superclass constructor handles copying in properties and registering event handlers.
   *
   * @method constructor
   * @param  {Object} options - a hash of properties and event handlers
   * @return {layer.Root}
   */
  function Root() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Root);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Root).call(this));

    _this._layerEventSubscriptions = [];
    _this._delayedTriggers = [];
    _this._lastDelayedTrigger = Date.now();
    _this._events = {};

    // Generate an internalId
    var name = _this.constructor.name;
    if (!uniqueIds[name]) uniqueIds[name] = 0;
    _this.internalId = name + uniqueIds[name]++;

    // Every component listens to the SystemBus for postMessage (triggerAsync) events
    SystemBus.on(_this.internalId + '-delayed-event', _this._processDelayedTriggers, _this);

    // Generate a temporary id if there isn't an id
    if (!_this.id && !options.id && _this.constructor.prefixUUID) {
      _this.id = _this.constructor.prefixUUID + Utils.generateUUID();
    }

    // Copy in all properties; setup all event handlers
    var key = void 0;
    for (key in options) {
      if (_this.constructor._supportedEvents.indexOf(key) !== -1) {
        _this.on(key, options[key]);
      } else if (key in _this && typeof _this[key] !== 'function') {
        _this[key] = options[key];
      }
    }
    _this.isInitializing = false;
    return _this;
  }

  /**
   * Destroys the object.
   *
   * Cleans up all events / subscriptions
   * and marks the object as isDestroyed.
   *
   * @method destroy
   */


  _createClass(Root, [{
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      if (this.isDestroyed) throw new Error(LayerError.dictionary.alreadyDestroyed);

      // If anyone is listening, notify them
      this.trigger('destroy');

      // Cleanup pointers to SystemBus. Failure to call destroy
      // will have very serious consequences...
      SystemBus.off(this.internalId + '-delayed-event', null, this);

      // Remove all events, and all pointers passed to this object by other objects
      this.off();

      // Find all of the objects that this object has passed itself to in the form
      // of event handlers and remove all references to itself.
      this._layerEventSubscriptions.forEach(function (item) {
        return item.off(null, null, _this2);
      });

      this._layerEventSubscriptions = null;
      this._delayedTriggers = null;
      this.isDestroyed = true;
    }
  }, {
    key: 'toObject',


    /**
     * Convert class instance to Plain Javascript Object.
     *
     * Strips out all private members, and insures no datastructure loops.
     * Recursively converting all subobjects using calls to toObject.
     *
     *      console.dir(myobj.toObject());
     *
     * Note: While it would be tempting to have noChildren default to true,
     * this would result in Message.toObject() not outputing its MessageParts.
     *
     * Private data (_ prefixed properties) will not be output.
     *
     * @method toObject
     * @param  {boolean} [noChildren=false] Don't output sub-components
     * @return {Object}
     */
    value: function toObject() {
      var _this3 = this;

      var noChildren = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      this.__inToObject = true;
      var obj = {};

      // Iterate over all formally defined properties
      try {
        var keys = [];
        var aKey = void 0;
        for (aKey in this.constructor.prototype) {
          if (!(aKey in Root.prototype)) keys.push(aKey);
        }keys.forEach(function (key) {
          var v = _this3[key];

          // Ignore private/protected properties and functions
          if (key.indexOf('_') === 0) return;
          if (typeof v === 'function') return;

          // Generate arrays...
          if (Array.isArray(v)) {
            obj[key] = [];
            v.forEach(function (item) {
              if (item instanceof Root) {
                if (noChildren) {
                  delete obj[key];
                } else if (!item.__inToObject) {
                  obj[key].push(item.toObject());
                }
              } else {
                obj[key].push(item);
              }
            });
          }

          // Generate subcomponents
          else if (v instanceof Root) {
              if (!v.__inToObject && !noChildren) {
                obj[key] = v.toObject();
              }
            }

            // Generate dates (creates a copy to separate it from the source object)
            else if (v instanceof Date) {
                obj[key] = new Date(v);
              }

              // Generate simple properties
              else {
                  obj[key] = v;
                }
        });
      } catch (e) {
        // no-op
      }
      this.__inToObject = false;
      return obj;
    }

    /**
     * Log a warning for attempts to subscribe to unsupported events.
     *
     * @method _warnForEvent
     * @private
     */

  }, {
    key: '_warnForEvent',
    value: function _warnForEvent(eventName) {
      if (!Utils.includes(this.constructor._supportedEvents, eventName)) {
        throw new Error('Event ' + eventName + ' not defined for ' + this.toString());
      }
    }

    /**
     * Prepare for processing an event subscription call.
     *
     * If context is a Root class, add this object to the context's subscriptions.
     *
     * @method _prepareOn
     * @private
     */

  }, {
    key: '_prepareOn',
    value: function _prepareOn(name, handler, context) {
      var _this4 = this;

      if (context) {
        if (context instanceof Root) {
          if (context.isDestroyed) {
            throw new Error(LayerError.dictionary.isDestroyed);
          }
        }
        if (context._layerEventSubscriptions) {
          context._layerEventSubscriptions.push(this);
        }
      }
      if (typeof name === 'string' && name !== 'all') {
        if (eventSplitter.test(name)) {
          var names = name.split(eventSplitter);
          names.forEach(function (n) {
            return _this4._warnForEvent(n);
          });
        } else {
          this._warnForEvent(name);
        }
      } else if (name && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
        Object.keys(name).forEach(function (keyName) {
          return _this4._warnForEvent(keyName);
        });
      }
    }

    /**
     * Subscribe to events.
     *
     * Note that the context parameter serves double importance here:
     *
     * 1. It determines the context in which to execute the event handler
     * 2. Create a backlink so that if either subscriber or subscribee is destroyed,
     *    all pointers between them can be found and removed.
     *
     * ```
     * obj.on('someEventName someOtherEventName', mycallback, mycontext);
     * ```
     *
     * ```
     * obj.on({
     *    eventName1: callback1,
     *    eventName2: callback2
     * }, mycontext);
     * ```
     *
     * @method on
     * @param  {String} name - Name of the event
     * @param  {Function} handler - Event handler
     * @param  {layer.LayerEvent} handler.event - Event object delivered to the handler
     * @param  {Object} context - This pointer AND link to help with cleanup
     * @return {layer.Root} this
     */

  }, {
    key: 'on',
    value: function on(name, handler, context) {
      this._prepareOn(name, handler, context);
      Events.on.apply(this, [name, handler, context]);
      return this;
    }

    /**
     * Subscribe to the first occurance of the specified event.
     *
     * @method once
     * @return {layer.Root} this
     */

  }, {
    key: 'once',
    value: function once(name, handler, context) {
      this._prepareOn(name, handler, context);
      Events.once.apply(this, [name, handler, context]);
      return this;
    }

    /**
     * Unsubscribe from events.
     *
     * ```
     * // Removes all event handlers for this event:
     * obj.off('someEventName');
     *
     * // Removes all event handlers using this function pointer as callback
     * obj.off(null, f, null);
     *
     * // Removes all event handlers that `this` has subscribed to; requires
     * // obj.on to be called with `this` as its `context` parameter.
     * obj.off(null, null, this);
     * ```
     *
     * @method off
     * @param  {String} name - Name of the event; null for all event names
     * @param  {Function} handler - Event handler; null for all functions
     * @param  {Object} context - The context from the `on()` call to search for; null for all contexts
     * @return {layer.Root} this
     */

    /**
     * Trigger an event for any event listeners.
     *
     * Events triggered this way will be blocked if _disableEvents = true
     *
     * @method trigger
     * @param {string} eventName    Name of the event that one should subscribe to in order to receive this event
     * @param {Mixed} arg           Values that will be placed within a layer.LayerEvent
     * @return {layer.Root} this
     */

  }, {
    key: 'trigger',
    value: function trigger() {
      if (this._disableEvents) return this;
      return this._trigger.apply(this, arguments);
    }

    /**
     * Triggers an event.
     *
     * @method trigger
     * @private
     * @param {string} eventName    Name of the event that one should subscribe to in order to receive this event
     * @param {Mixed} arg           Values that will be placed within a layer.LayerEvent
     */

  }, {
    key: '_trigger',
    value: function _trigger() {
      if (!Utils.includes(this.constructor._supportedEvents, arguments.length <= 0 ? undefined : arguments[0])) {
        if (!Utils.includes(this.constructor._ignoredEvents, arguments.length <= 0 ? undefined : arguments[0])) {
          Logger.error(this.toString() + ' ignored ' + (arguments.length <= 0 ? undefined : arguments[0]));
        }
        return;
      }

      var computedArgs = this._getTriggerArgs.apply(this, arguments);

      Events.trigger.apply(this, computedArgs);

      var parentProp = this.constructor.bubbleEventParent;
      if (parentProp && (arguments.length <= 0 ? undefined : arguments[0]) !== 'destroy') {
        var _parentValue;

        var parentValue = this[parentProp];
        parentValue = typeof parentValue === 'function' ? parentValue.apply(this) : parentValue;
        if (parentValue) (_parentValue = parentValue).trigger.apply(_parentValue, _toConsumableArray(computedArgs));
      }
    }

    /**
     * Generates a layer.LayerEvent from a trigger call's arguments.
     *
     * * If parameter is already a layer.LayerEvent, we're done.
     * * If parameter is an object, a `target` property is added to that object and its delivered to all subscribers
     * * If the parameter is non-object value, it is added to an object with a `target` property, and the value is put in
     *   the `data` property.
     *
     * @method _getTriggerArgs
     * @private
     * @return {Mixed[]} - First element of array is eventName, second element is layer.LayerEvent.
     */

  }, {
    key: '_getTriggerArgs',
    value: function _getTriggerArgs() {
      var _this5 = this;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var computedArgs = Array.prototype.slice.call(args);

      if (args[1]) {
        (function () {
          var newArg = { target: _this5 };

          if (computedArgs[1] instanceof LayerEvent) {
            // A LayerEvent will be an argument when bubbling events up; these args can be used as-is
          } else {
            if (_typeof(computedArgs[1]) === 'object') {
              Object.keys(computedArgs[1]).forEach(function (name) {
                return newArg[name] = computedArgs[1][name];
              });
            } else {
              newArg.data = computedArgs[1];
            }
            computedArgs[1] = new LayerEvent(newArg, computedArgs[0]);
          }
        })();
      } else {
        computedArgs[1] = new LayerEvent({ target: this }, computedArgs[0]);
      }

      return computedArgs;
    }

    /**
     * Same as _trigger() method, but delays briefly before firing.
     *
     * When would you want to delay an event?
     *
     * 1. There is an event rollup that may be needed for the event;
     *    this requires the framework to be able to see ALL events that have been
     *    generated, roll them up, and THEN fire them.
     * 2. The event is intended for UI rendering... which should not hold up the rest of
     *    this framework's execution.
     *
     * When NOT to delay an event?
     *
     * 1. Lifecycle events frequently require response at the time the event has fired
     *
     * @method _triggerAsync
     * @private
     * @param {string} eventName    Name of the event that one should subscribe to in order to receive this event
     * @param {Mixed} arg           Values that will be placed within a layer.LayerEvent
     * @return {layer.Root} this
     */

  }, {
    key: '_triggerAsync',
    value: function _triggerAsync() {
      var _this6 = this;

      var computedArgs = this._getTriggerArgs.apply(this, arguments);
      this._delayedTriggers.push(computedArgs);

      // NOTE: It is unclear at this time how it happens, but on very rare occasions, we see processDelayedTriggers
      // fail to get called when length = 1, and after that length just continuously grows.  So we add
      // the _lastDelayedTrigger test to insure that it will still run.
      var shouldScheduleTrigger = this._delayedTriggers.length === 1 || this._delayedTriggers.length && this._lastDelayedTrigger + 500 < Date.now();
      if (shouldScheduleTrigger) {
        this._lastDelayedTrigger = Date.now();
        if (typeof postMessage === 'function' && typeof jasmine === 'undefined') {
          var messageData = {
            type: 'layer-delayed-event',
            internalId: this.internalId
          };
          if (typeof document !== 'undefined') {
            window.postMessage(messageData, '*');
          } else {
            // React Native reportedly lacks a document, and throws errors on the second parameter
            window.postMessage(messageData);
          }
        } else {
          setTimeout(function () {
            return _this6._processDelayedTriggers();
          }, 0);
        }
      }
    }

    /**
     * Combines a set of events into a single event.
     *
     * Given an event structure of
     * ```
     *      {
     *          customName: [value1]
     *      }
     *      {
     *          customName: [value2]
     *      }
     *      {
     *          customName: [value3]
     *      }
     * ```
     *
     * Merge them into
     *
     * ```
     *      {
     *          customName: [value1, value2, value3]
     *      }
     * ```
     *
     * @method _foldEvents
     * @private
     * @param  {layer.LayerEvent[]} events
     * @param  {string} name      Name of the property (i.e. 'customName')
     * @param  {layer.Root}    newTarget Value of the target for the folded resulting event
     */

  }, {
    key: '_foldEvents',
    value: function _foldEvents(events, name, newTarget) {
      var _this7 = this;

      var firstEvt = events.length ? events[0][1] : null;
      var firstEvtProp = firstEvt ? firstEvt[name] : null;
      events.forEach(function (evt, i) {
        if (i > 0) {
          firstEvtProp.push(evt[1][name][0]);
          _this7._delayedTriggers.splice(_this7._delayedTriggers.indexOf(evt), 1);
        }
      });
      if (events.length && newTarget) events[0][1].target = newTarget;
    }

    /**
     * Fold a set of Change events into a single Change event.
     *
     * Given a set change events on this component,
     * fold all change events into a single event via
     * the layer.LayerEvent's changes array.
     *
     * @method _foldChangeEvents
     * @private
     */

  }, {
    key: '_foldChangeEvents',
    value: function _foldChangeEvents() {
      var _this8 = this;

      var events = this._delayedTriggers.filter(function (evt) {
        return evt[1].isChange;
      });
      events.forEach(function (evt, i) {
        if (i > 0) {
          events[0][1]._mergeChanges(evt[1]);
          _this8._delayedTriggers.splice(_this8._delayedTriggers.indexOf(evt), 1);
        }
      });
    }

    /**
     * Execute all delayed events for this compoennt.
     *
     * @method _processDelayedTriggers
     * @private
     */

  }, {
    key: '_processDelayedTriggers',
    value: function _processDelayedTriggers() {
      if (this.isDestroyed) return;
      this._foldChangeEvents();

      this._delayedTriggers.forEach(function (evt) {
        this.trigger.apply(this, _toConsumableArray(evt));
      }, this);
      this._delayedTriggers = [];
    }
  }, {
    key: '_runMixins',
    value: function _runMixins(mixinName, argArray) {
      var _this9 = this;

      this.constructor.mixins.forEach(function (mixin) {
        if (mixin.lifecycle[mixinName]) mixin.lifecycle[mixinName].apply(_this9, argArray);
      });
    }

    /**
     * Returns a string representation of the class that is nicer than `[Object]`.
     *
     * @method toString
     * @return {String}
     */

  }, {
    key: 'toString',
    value: function toString() {
      return this.internalId;
    }
  }], [{
    key: 'isValidId',
    value: function isValidId(id) {
      return id.indexOf(this.prefixUUID) === 0;
    }
  }]);

  return Root;
}(EventClass);

function defineProperty(newClass, propertyName) {
  var pKey = '__' + propertyName;
  var camel = propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
  var hasDefinitions = newClass.prototype['__adjust' + camel] || newClass.prototype['__update' + camel] || newClass.prototype['__get' + camel];
  if (hasDefinitions) {
    // set default value
    newClass.prototype[pKey] = newClass.prototype[propertyName];

    Object.defineProperty(newClass.prototype, propertyName, {
      enumerable: true,
      get: function get() {
        return this['__get' + camel] ? this['__get' + camel](pKey) : this[pKey];
      },
      set: function set(inValue) {
        if (this.isDestroyed) return;
        var initial = this[pKey];
        if (inValue !== initial) {
          if (this['__adjust' + camel]) {
            var result = this['__adjust' + camel](inValue);
            if (result !== undefined) inValue = result;
          }
          this[pKey] = inValue;
        }
        if (inValue !== initial) {
          if (!this.isInitializing && this['__update' + camel]) {
            this['__update' + camel](inValue, initial);
          }
        }
      }
    });
  }
}

function initClass(newClass, className) {
  // Make sure our new class has a name property
  if (!newClass.name) newClass.name = className;

  // Make sure our new class has a _supportedEvents, _ignoredEvents, _inObjectIgnore and EVENTS properties
  if (!newClass._supportedEvents) newClass._supportedEvents = Root._supportedEvents;
  if (!newClass._ignoredEvents) newClass._ignoredEvents = Root._ignoredEvents;

  if (newClass.mixins) {
    newClass.mixins.forEach(function (mixin) {
      if (mixin.events) newClass._supportedEvents = newClass._supportedEvents.concat(mixin.events);
      if (mixin.properties) {
        Object.keys(mixin.properties).forEach(function (key) {
          newClass.prototype[key] = mixin.properties[key];
        });
      }
      if (mixin.methods) {
        Object.keys(mixin.methods).forEach(function (key) {
          newClass.prototype[key] = mixin.methods[key];
        });
      }
    });
  }

  // Generate a list of properties for this class; we don't include any
  // properties from layer.Root
  var keys = Object.keys(newClass.prototype).filter(function (key) {
    return newClass.prototype.hasOwnProperty(key) && !Root.prototype.hasOwnProperty(key) && typeof newClass.prototype[key] !== 'function';
  });

  // Define getters/setters for any property that has __adjust or __update methods defined
  keys.forEach(function (name) {
    return defineProperty(newClass, name);
  });
}

/**
 * Set to true once destroy() has been called.
 *
 * A destroyed object will likely cause errors in any attempt
 * to call methods on it, and will no longer trigger events.
 *
 * @type {boolean}
 * @readonly
 */
Root.prototype.isDestroyed = false;

/**
 * Every instance has its own internal ID.
 *
 * This ID is distinct from any IDs assigned by the server.
 * The internal ID is gaurenteed not to change within the lifetime of the Object/session;
 * it is possible, on creating a new object, for its `id` property to change.
 *
 * @type {string}
 * @readonly
 */
Root.prototype.internalId = '';

/**
 * True while we are in the constructor.
 *
 * @type {boolean}
 * @readonly
 */
Root.prototype.isInitializing = true;

/**
 * Objects that this object is listening for events from.
 *
 * @type {layer.Root[]}
 * @private
 */
Root.prototype._layerEventSubscriptions = null;

/**
 * Disable all events triggered on this object.
 * @type {boolean}
 * @private
 */
Root.prototype._disableEvents = false;

Root._supportedEvents = ['destroy', 'all'];
Root._ignoredEvents = [];
module.exports = Root;
module.exports.initClass = initClass;


},{"./client-utils":82,"./layer-error":86,"./layer-event":87,"./logger":88,"backbone-events-standalone/backbone-events-standalone":127}],117:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A Sync Event represents a request to the server.
 * A Sync Event may fire immediately, or may wait in the layer.SyncManager's
 * queue for a long duration before firing.
 *
 * DO NOT confuse this with layer.LayerEvent which represents a change notification
 * to your application.  layer.SyncEvent represents a request to the server that
 * is either in progress or in queue.
 *
 * GET requests are typically NOT done via a SyncEvent as these are typically
 * needed to render a UI and should either fail or succeed promptly.
 *
 * Applications typically do not interact with these objects.
 *
 * @class  layer.SyncEvent
 * @extends layer.Root
 */
var Utils = require('./client-utils');

var SyncEvent = function () {
  /**
   * Create a layer.SyncEvent.  See layer.ClientAuthenticator for examples of usage.
   *
   * @method  constructor
   * @private
   * @return {layer.SyncEvent}
   */
  function SyncEvent(options) {
    _classCallCheck(this, SyncEvent);

    var key = void 0;
    for (key in options) {
      if (key in this) {
        this[key] = options[key];
      }
    }
    if (!this.depends) this.depends = [];
    if (!this.id) this.id = 'layer:///syncevents/' + Utils.generateUUID();
    if (!this.createdAt) this.createdAt = Date.now();
  }

  /**
   * Not strictly required, but nice to clean things up.
   *
   * @method destroy
   */


  _createClass(SyncEvent, [{
    key: 'destroy',
    value: function destroy() {
      this.target = null;
      this.depends = null;
      this.callback = null;
      this.data = null;
    }

    /**
     * Get the Real parameters for the request.
     *
     * @method _updateData
     * @private
     */

  }, {
    key: '_updateData',
    value: function _updateData(client) {
      if (!this.target) return;
      var target = client.getObject(this.target);
      if (target && this.operation === 'POST' && target._getSendData) {
        this.data = target._getSendData(this.data);
      }
    }

    /**
     * Returns a POJO version of this object suitable for serializing for the network
     * @method toObject
     * @returns {Object}
     */

  }, {
    key: 'toObject',
    value: function toObject() {
      return { data: this.data };
    }
  }]);

  return SyncEvent;
}();

/**
 * The type of operation being performed.
 *
 * Either GET, PATCH, DELETE, POST or PUT
 *
 * @property {String}
 */


SyncEvent.prototype.operation = '';

SyncEvent.prototype.fromDB = false;

SyncEvent.prototype.createdAt = 0;

/**
 * Indicates whether this request currently in-flight.
 *
 * * Set to true by _xhr() method,
 * * set to false on completion by layer.SyncManager.
 * * set to false automatically after 2 minutes
 *
 * @property {Boolean}
 */
Object.defineProperty(SyncEvent.prototype, 'isFiring', {
  enumerable: true,
  set: function set(value) {
    this.__isFiring = value;
    if (value) this.__firedAt = Date.now();
  },
  get: function get() {
    return Boolean(this.__isFiring && Date.now() - this.__firedAt < SyncEvent.FIRING_EXPIRATION);
  }
});

/**
 * Indicates whether this request currently being validated to insure it wasn't read
 * from IndexedDB and fired by another tab.
 *
 * @property {Boolean}
 */
Object.defineProperty(SyncEvent.prototype, '_isValidating', {
  enumerable: true,
  set: function set(value) {
    this.__isValidating = value;
    if (value) this.__validatedAt = Date.now();
  },
  get: function get() {
    return Boolean(this.__isValidating && Date.now() - this.__validatedAt < SyncEvent.VALIDATION_EXPIRATION);
  }
});

SyncEvent.prototype.id = '';

/**
 * Indicates whether the request completed successfully.
 *
 * Set by layer.SyncManager.
 * @type {Boolean}
 */
SyncEvent.prototype.success = null;

/**
 * Callback to fire on completing this sync event.
 *
 * WARNING: The nature of this callback may change;
 * a persistence layer that persists the SyncManager's queue
 * must have serializable callbacks (object id + method name; not a function)
 * or must accept that callbacks are not always fired.
 * @type {Function}
 */
SyncEvent.prototype.callback = null;

/**
 * Number of retries on this request.
 *
 * Retries are only counted if its a 502 or 503
 * error.  Set and managed by layer.SyncManager.
 * @type {Number}
 */
SyncEvent.prototype.retryCount = 0;

/**
 * The target of the request.
 *
 * Any Component; typically a Conversation or Message.
 * @type {layer.Root}
 */
SyncEvent.prototype.target = null;

/**
 * Components that this request depends upon.
 *
 * A message cannot be sent if its
 * Conversation fails to get created.
 *
 * NOTE: May prove redundant with the target property and needs further review.
 * @type {layer.Root[]}
 */
SyncEvent.prototype.depends = null;

/**
 * Data field of the xhr call; can be an Object or string (including JSON string)
 * @type {Object}
 */
SyncEvent.prototype.data = null;

/**
 * After firing a request, if that firing state fails to clear after this number of miliseconds,
 * consider it to no longer be firing.  Under normal conditions, firing will be set to false explicitly.
 * This check insures that any failure of that process does not leave us stuck with a firing request
 * blocking the queue.
 * @type {number}
 * @static
 */
SyncEvent.FIRING_EXPIRATION = 1000 * 15;

/**
 * After checking the database to see if this event has been claimed by another browser tab,
 * how long to wait before flagging it as failed, in the event of no-response.  Measured in ms.
 * @type {number}
 * @static
 */
SyncEvent.VALIDATION_EXPIRATION = 500;

/**
 * A layer.SyncEvent intended to be fired as an XHR request.
 *
 * @class layer.SyncEvent.XHRSyncEvent
 * @extends layer.SyncEvent
 */

var XHRSyncEvent = function (_SyncEvent) {
  _inherits(XHRSyncEvent, _SyncEvent);

  function XHRSyncEvent() {
    _classCallCheck(this, XHRSyncEvent);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(XHRSyncEvent).apply(this, arguments));
  }

  _createClass(XHRSyncEvent, [{
    key: '_getRequestData',


    /**
     * Fire the request associated with this instance.
     *
     * Actually it just returns the parameters needed to make the xhr call:
     *
     *      var xhr = require('./xhr');
     *      xhr(event._getRequestData(client));
     *
     * @method _getRequestData
     * @param {layer.Client} client
     * @protected
     * @returns {Object}
     */
    value: function _getRequestData(client) {
      this._updateUrl(client);
      this._updateData(client);
      return {
        url: this.url,
        method: this.method,
        headers: this.headers,
        data: this.data
      };
    }

    /**
     * Get the Real URL.
     *
     * If the url property is a function, call it to set the actual url.
     * Used when the URL is unknown until a prior SyncEvent has completed.
     *
     * @method _updateUrl
     * @private
     */

  }, {
    key: '_updateUrl',
    value: function _updateUrl(client) {
      if (!this.target) return;
      var target = client.getObject(this.target);
      if (target && !this.url.match(/^http(s):\/\//)) {
        this.url = target._getUrl(this.url);
      }
    }
  }, {
    key: 'toObject',
    value: function toObject() {
      return {
        data: this.data,
        url: this.url,
        method: this.method
      };
    }
  }, {
    key: '_getCreateId',
    value: function _getCreateId() {
      return this.operation === 'POST' && this.data ? this.data.id : '';
    }
  }]);

  return XHRSyncEvent;
}(SyncEvent);

/**
 * How long before the request times out?
 * @type {Number} [timeout=15000]
 */


XHRSyncEvent.prototype.timeout = 15000;

/**
 * URL to send the request to
 */
XHRSyncEvent.prototype.url = '';

/**
 * Counts number of online state changes.
 *
 * If this number becomes high in a short time period, its probably
 * failing due to a CORS error.
 */
XHRSyncEvent.prototype.returnToOnlineCount = 0;

/**
 * Headers for the request
 */
XHRSyncEvent.prototype.headers = null;

/**
 * Request method.
 */
XHRSyncEvent.prototype.method = 'GET';

/**
 * A layer.SyncEvent intended to be fired as a websocket request.
 *
 * @class layer.SyncEvent.WebsocketSyncEvent
 * @extends layer.SyncEvent
 */

var WebsocketSyncEvent = function (_SyncEvent2) {
  _inherits(WebsocketSyncEvent, _SyncEvent2);

  function WebsocketSyncEvent() {
    _classCallCheck(this, WebsocketSyncEvent);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(WebsocketSyncEvent).apply(this, arguments));
  }

  _createClass(WebsocketSyncEvent, [{
    key: '_getRequestData',


    /**
     * Get the websocket request object.
     *
     * @method _getRequestData
     * @private
     * @param {layer.Client} client
     * @return {Object}
     */
    value: function _getRequestData(client) {
      this._updateData(client);
      return this.data;
    }
  }, {
    key: 'toObject',
    value: function toObject() {
      return this.data;
    }
  }, {
    key: '_getCreateId',
    value: function _getCreateId() {
      return this.operation === 'POST' && this.data.data ? this.data.data.id : '';
    }
  }]);

  return WebsocketSyncEvent;
}(SyncEvent);

/**
 * Does this websocket request return a changes array to be processed by the request-manager?
 */


WebsocketSyncEvent.prototype.returnChangesArray = false;

module.exports = { SyncEvent: SyncEvent, XHRSyncEvent: XHRSyncEvent, WebsocketSyncEvent: WebsocketSyncEvent };


},{"./client-utils":82}],118:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class  layer.SyncManager
 * @extends layer.Root
 * @protected
 *
 * This class manages
 *
 * 1. a queue of requests that need to be made
 * 2. when a request should be fired, based on authentication state, online state, websocket connection state, and position in the queue
 * 3. when a request should be aborted
 * 4. triggering any request callbacks
 *
 * TODO: In the event of a DNS error, we may have a valid websocket receiving events and telling us we are online,
 * and be unable to create a REST call.  This will be handled wrong because evidence will suggest that we are online.
 * This issue goes away when we use bidirectional websockets for all requests.
 *
 * Applications do not typically interact with this class, but may subscribe to its events
 * to get richer detailed information than is available from the layer.Client instance.
 */
var Root = require('./root');

var _require = require('./sync-event');

var WebsocketSyncEvent = _require.WebsocketSyncEvent;

var xhr = require('./xhr');
var logger = require('./logger');
var Utils = require('./client-utils');

var MAX_RECEIPT_CONNECTIONS = 4;

var SyncManager = function (_Root) {
  _inherits(SyncManager, _Root);

  /**
   * Creates a new SyncManager.
   *
   * An Application is expected to only have one SyncManager.
   *
   *      var socketManager = new layer.Websockets.SocketManager({client: client});
   *      var requestManager = new layer.Websockets.RequestManager({client: client, socketManager: socketManager});
   *
   *      var onlineManager = new layer.OnlineManager({
   *          socketManager: socketManager
   *      });
   *
   *      // Now we can instantiate this thing...
   *      var SyncManager = new layer.SyncManager({
   *          client: client,
   *          onlineManager: onlineManager,
   *          socketManager: socketManager,
   *          requestManager: requestManager
   *      });
   *
   * @method constructor
   * @param  {Object} options
   * @param {layer.OnlineStateManager} options.onlineManager
   * @param {layer.Websockets.RequestManager} options.requestManager
   * @param {layer.Client} options.client
   */
  function SyncManager(options) {
    _classCallCheck(this, SyncManager);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SyncManager).call(this, options));

    _this.client = options.client;

    // Note we do not store a pointer to client... it is not needed.
    if (_this.client) {
      _this.client.on('ready', function () {
        _this._processNextRequest();
        _this._loadPersistedQueue();
      }, _this);
    }
    _this.queue = [];
    _this.receiptQueue = [];

    // Rather than listen for onlineManager 'connected', let the socketManager listen for that, connect, and the syncManager
    // waits until its actually connected
    _this.onlineManager.on('disconnected', _this._onlineStateChange, _this);
    _this.socketManager.on('connected disconnected', _this._onlineStateChange, _this);
    return _this;
  }

  /**
   * Returns whether the Client is online/offline.
   *
   * For internal use; applications should use layer.Client.isOnline.
   *
   * @method isOnline
   * @returns {Boolean}
   */


  _createClass(SyncManager, [{
    key: 'isOnline',
    value: function isOnline() {
      return this.onlineManager.isOnline;
    }

    /**
     * Process sync request when connection is restored.
     *
     * Any time we go back online (as signaled by the onlineStateManager),
     * Process the next Sync Event (will do nothing if one is already firing)
     *
     * @method _onlineStateChange
     * @private
     * @param  {string} evtName - 'connected' or 'disconnected'
     * @param  {layer.LayerEvent} evt
     */

  }, {
    key: '_onlineStateChange',
    value: function _onlineStateChange(evt) {
      var _this2 = this;

      if (evt.eventName === 'connected') {
        if (this.queue.length) this.queue[0].returnToOnlineCount++;
        setTimeout(function () {
          return _this2._processNextRequest();
        }, 100);
      } else if (evt.eventName === 'disconnected') {
        if (this.queue.length) {
          this.queue[0].isFiring = false;
        }
        if (this.receiptQueue.length) {
          this.receiptQueue.forEach(function (syncEvt) {
            return syncEvt.isFiring = false;
          });
        }
      }
    }

    /**
     * Adds a new xhr request to the queue.
     *
     * If the queue is empty, this will be fired immediately; else it will be added to the queue and wait its turn.
     *
     * If its a read/delivery receipt request, it will typically be fired immediately unless there are many receipt
     * requests already in-flight.
     *
     * @method request
     * @param  {layer.SyncEvent} requestEvt - A SyncEvent specifying the request to be made
     */

  }, {
    key: 'request',
    value: function request(requestEvt) {
      // If its a PATCH request on an object that isn't yet created,
      // do not add it to the queue.
      if (requestEvt.operation !== 'PATCH' || !this._findUnfiredCreate(requestEvt)) {
        logger.info('Sync Manager Request ' + requestEvt.operation + ' on target ' + requestEvt.target, requestEvt.toObject());
        if (requestEvt.operation === 'RECEIPT') {
          this.receiptQueue.push(requestEvt);
        } else {
          this.queue.push(requestEvt);
        }
        this.trigger('sync:add', {
          request: requestEvt,
          target: requestEvt.target
        });
      } else {
        logger.info('Sync Manager Request PATCH ' + requestEvt.target + ' request ignored; create request still enqueued', requestEvt.toObject());
      }

      // If its a DELETE request, purge all other requests on that target.
      if (requestEvt.operation === 'DELETE') {
        this._purgeOnDelete(requestEvt);
      }

      this._processNextRequest(requestEvt);
    }
  }, {
    key: '_processNextRequest',
    value: function _processNextRequest(requestEvt) {
      var _this3 = this;

      // Fire the request if there aren't any existing requests already firing
      if (this.queue.length && !this.queue[0].isFiring) {
        if (requestEvt) {
          this.client.dbManager.writeSyncEvents([requestEvt], function () {
            return _this3._processNextStandardRequest();
          });
        } else {
          this._processNextStandardRequest();
        }
      }

      // If we have anything in the receipts queue, fire it
      if (this.receiptQueue.length) {
        this._processNextReceiptRequest();
      }
    }

    /**
     * Find create request for this resource.
     *
     * Determine if the given target has a POST request waiting to create
     * the resource, and return any matching requests. Used
     * for folding PATCH requests into an unfired CREATE/POST request.
     *
     * @method _findUnfiredCreate
     * @private
     * @param  {layer.SyncEvent} requestEvt
     * @return {Boolean}
     */

  }, {
    key: '_findUnfiredCreate',
    value: function _findUnfiredCreate(requestEvt) {
      return Boolean(this.queue.filter(function (evt) {
        return evt.target === requestEvt.target && evt.operation === 'POST' && !evt.isFiring;
      }).length);
    }

    /**
     * Process the next request in the queue.
     *
     * Request is dequeued on completing the process.
     * If the first request in the queue is firing, do nothing.
     *
     * @method _processNextRequest
     * @private
     */

  }, {
    key: '_processNextStandardRequest',
    value: function _processNextStandardRequest() {
      var _this4 = this;

      if (this.isDestroyed || !this.client.isAuthenticated) return;
      var requestEvt = this.queue[0];
      if (this.isOnline() && requestEvt && !requestEvt.isFiring && !requestEvt._isValidating) {
        requestEvt._isValidating = true;
        this._validateRequest(requestEvt, function (isValid) {
          requestEvt._isValidating = false;
          if (!isValid) {
            _this4._removeRequest(requestEvt, false);
            return _this4._processNextStandardRequest();
          } else {
            _this4._fireRequest(requestEvt);
          }
        });
      }
    }

    /**
     * Process up to MAX_RECEIPT_CONNECTIONS worth of receipts.
     *
     * These requests have no interdependencies. Just fire them all
     * as fast as we can, in parallel.
     *
     * @method _processNextReceiptRequest
     * @private
     */

  }, {
    key: '_processNextReceiptRequest',
    value: function _processNextReceiptRequest() {
      var _this5 = this;

      var firingReceipts = 0;
      this.receiptQueue.forEach(function (receiptEvt) {
        if (_this5.isOnline() && receiptEvt) {
          if (receiptEvt.isFiring || receiptEvt._isValidating) {
            firingReceipts++;
          } else if (firingReceipts < MAX_RECEIPT_CONNECTIONS) {
            firingReceipts++;
            _this5._fireRequest(receiptEvt);
          }
        }
      });
    }

    /**
     * Directly fire this sync request.
     *
     * This is intended to be called only after careful analysis of our state to make sure its safe to send the request.
     * See `_processNextRequest()`
     *
     * @method _fireRequest
     * @private
     * @param {layer.SyncEvent} requestEvt
     */

  }, {
    key: '_fireRequest',
    value: function _fireRequest(requestEvt) {
      if (requestEvt instanceof WebsocketSyncEvent) {
        this._fireRequestWebsocket(requestEvt);
      } else {
        this._fireRequestXHR(requestEvt);
      }
    }

    /**
     * Directly fire this XHR Sync request.
     *
     * @method _fireRequestXHR
     * @private
     * @param {layer.SyncEvent.XHRSyncEvent} requestEvt
     */

  }, {
    key: '_fireRequestXHR',
    value: function _fireRequestXHR(requestEvt) {
      var _this6 = this;

      requestEvt.isFiring = true;
      if (!requestEvt.headers) requestEvt.headers = {};
      requestEvt.headers.authorization = 'Layer session-token="' + this.client.sessionToken + '"';
      logger.info('Sync Manager XHR Request Firing ' + requestEvt.operation + ' ' + requestEvt.target + ' at ' + new Date().toISOString(), requestEvt.toObject());
      xhr(requestEvt._getRequestData(this.client), function (result) {
        return _this6._xhrResult(result, requestEvt);
      });
    }

    /**
     * Directly fire this Websocket Sync request.
     *
     * @method _fireRequestWebsocket
     * @private
     * @param {layer.SyncEvent.WebsocketSyncEvent} requestEvt
     */

  }, {
    key: '_fireRequestWebsocket',
    value: function _fireRequestWebsocket(requestEvt) {
      var _this7 = this;

      if (this.socketManager && this.socketManager._isOpen()) {
        logger.debug('Sync Manager Websocket Request Firing ' + requestEvt.operation + ' on target ' + requestEvt.target, requestEvt.toObject());
        requestEvt.isFiring = true;
        this.requestManager.sendRequest({
          data: requestEvt._getRequestData(this.client),
          callback: function callback(result) {
            return _this7._xhrResult(result, requestEvt);
          },
          isChangesArray: requestEvt.returnChangesArray
        });
      } else {
        logger.debug('Sync Manager Websocket Request skipped; socket closed');
      }
    }

    /**
     * Is the syncEvent still valid?
     *
     * This method specifically tests to see if some other tab has already sent this request.
     * If persistence of the syncQueue is not enabled, then the callback is immediately called with true.
     * If another tab has already sent the request, then the entry will no longer be in indexedDB and the callback
     * will call false.
     *
     * @method _validateRequest
     * @param {layer.SyncEvent} syncEvent
     * @param {Function} callback
     * @param {Function} callback.isValid - The request is still valid
     * @private
     */

  }, {
    key: '_validateRequest',
    value: function _validateRequest(syncEvent, callback) {
      this.client.dbManager.claimSyncEvent(syncEvent, function (isFound) {
        return callback(isFound);
      });
    }

    /**
     * Turn deduplication errors into success messages.
     *
     * If this request has already been made but we failed to get a response the first time and we retried the request,
     * we will reissue the request.  If the prior request was successful we'll get back a deduplication error
     * with the created object. As far as the WebSDK is concerned, this is a success.
     *
     * @method _handleDeduplicationErrors
     * @private
     */

  }, {
    key: '_handleDeduplicationErrors',
    value: function _handleDeduplicationErrors(result) {
      if (result.data && result.data.id === 'id_in_use' && result.data.data && result.data.data.id === result.request._getCreateId()) {
        result.success = true;
        result.data = result.data.data;
      }
    }

    /**
     * Process the result of an xhr call, routing it to the appropriate handler.
     *
     * @method _xhrResult
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {layer.SyncEvent} requestEvt - Request object
     */

  }, {
    key: '_xhrResult',
    value: function _xhrResult(result, requestEvt) {
      if (this.isDestroyed) return;
      result.request = requestEvt;
      requestEvt.isFiring = false;
      this._handleDeduplicationErrors(result);
      if (!result.success) {
        this._xhrError(result);
      } else {
        this._xhrSuccess(result);
      }
    }

    /**
     * Categorize the error for handling.
     *
     * @method _getErrorState
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {layer.SyncEvent} requestEvt - Request object
     * @param  {boolean} isOnline - Is our app state set to online
     * @returns {String}
     */

  }, {
    key: '_getErrorState',
    value: function _getErrorState(result, requestEvt, isOnline) {
      var errId = result.data ? result.data.id : '';
      if (!isOnline) {
        // CORS errors look identical to offline; but if our online state has transitioned from false to true repeatedly while processing this request,
        // thats a hint that that its a CORS error
        if (requestEvt.returnToOnlineCount >= SyncManager.MAX_RETRIES_BEFORE_CORS_ERROR) {
          return 'CORS';
        } else {
          return 'offline';
        }
      } else if (errId === 'not_found') {
        return 'notFound';
      } else if (errId === 'id_in_use') {
        return 'invalidId'; // This only fires if we get `id_in_use` but no Resource, which means the UUID was used by another user/app.
      } else if (result.status === 408 || errId === 'request_timeout') {
        if (requestEvt.retryCount >= SyncManager.MAX_RETRIES) {
          return 'tooManyFailuresWhileOnline';
        } else {
          return 'validateOnlineAndRetry';
        }
      } else if ([502, 503, 504].indexOf(result.status) !== -1) {
        if (requestEvt.retryCount >= SyncManager.MAX_RETRIES) {
          return 'tooManyFailuresWhileOnline';
        } else {
          return 'serverUnavailable';
        }
      } else if (errId === 'authentication_required' && result.data.data && result.data.data.nonce) {
        return 'reauthorize';
      } else {
        return 'serverRejectedRequest';
      }
    }

    /**
     * Handle failed requests.
     *
     * 1. If there was an error from the server, then the request has problems
     * 2. If we determine we are not in fact online, call the connectionError handler
     * 3. If we think we are online, verify we are online and then determine how to handle it.
     *
     * @method _xhrError
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {layer.SyncEvent} requestEvt - Request object
     */

  }, {
    key: '_xhrError',
    value: function _xhrError(result) {
      var requestEvt = result.request;

      logger.warn('Sync Manager ' + (requestEvt instanceof WebsocketSyncEvent ? 'Websocket' : 'XHR') + ' ' + (requestEvt.operation + ' Request on target ' + requestEvt.target + ' has Failed'), requestEvt.toObject());

      var errState = this._getErrorState(result, requestEvt, this.isOnline());
      logger.warn('Sync Manager Error State: ' + errState);
      switch (errState) {
        case 'tooManyFailuresWhileOnline':
          this._xhrHandleServerError(result, 'Sync Manager Server Unavailable Too Long; removing request', false);
          break;
        case 'notFound':
          this._xhrHandleServerError(result, 'Resource not found; presumably deleted', false);
          break;
        case 'invalidId':
          this._xhrHandleServerError(result, 'ID was not unique; request failed', false);
          break;
        case 'validateOnlineAndRetry':
          // Server appears to be hung but will eventually recover.
          // Retry a few times and then error out.
          // this._xhrValidateIsOnline(requestEvt);
          this._xhrHandleServerUnavailableError(requestEvt);
          break;
        case 'serverUnavailable':
          // Server is in a bad state but will eventually recover;
          // keep retrying.
          this._xhrHandleServerUnavailableError(requestEvt);
          break;
        case 'reauthorize':
          // sessionToken appears to no longer be valid; forward response
          // on to client-authenticator to process.
          // Do not retry nor advance to next request.
          if (requestEvt.callback) requestEvt.callback(result);

          break;
        case 'serverRejectedRequest':
          // Server presumably did not like the arguments to this call
          // or the url was invalid.  Do not retry; trigger the callback
          // and let the caller handle it.
          this._xhrHandleServerError(result, 'Sync Manager Server Rejects Request; removing request', true);
          break;
        case 'CORS':
          // A pattern of offline-like failures that suggests its actually a CORs error
          this._xhrHandleServerError(result, 'Sync Manager Server detects CORS-like errors; removing request', false);
          break;
        case 'offline':
          this._xhrHandleConnectionError();
          break;
      }

      // Write the sync event back to the database if we haven't completed processing it
      if (this.queue.indexOf(requestEvt) !== -1 || this.receiptQueue.indexOf(requestEvt) !== -1) {
        this.client.dbManager.writeSyncEvents([requestEvt]);
      }
    }

    /**
     * Handle a server unavailable error.
     *
     * In the event of a 502 (Bad Gateway), 503 (service unavailable)
     * or 504 (gateway timeout) error from the server
     * assume we have an error that is self correcting on the server.
     * Use exponential backoff to retry the request.
     *
     * Note that each call will increment retryCount; there is a maximum
     * of MAX_RETRIES before it is treated as an error
     *
     * @method  _xhrHandleServerUnavailableError
     * @private
     * @param {layer.SyncEvent} request
     */

  }, {
    key: '_xhrHandleServerUnavailableError',
    value: function _xhrHandleServerUnavailableError(request) {
      var maxDelay = SyncManager.MAX_UNAVAILABLE_RETRY_WAIT;
      var delay = Utils.getExponentialBackoffSeconds(maxDelay, Math.min(15, request.retryCount++));
      logger.warn('Sync Manager Server Unavailable; retry count ' + request.retryCount + '; retrying in ' + delay + ' seconds');
      setTimeout(this._processNextRequest.bind(this), delay * 1000);
    }

    /**
     * Handle a server error in response to firing sync event.
     *
     * If there is a server error, its presumably non-recoverable/non-retryable error, so
     * we're going to abort this request.
     *
     * 1. If a callback was provided, call it to handle the error
     * 2. If a rollback call is provided, call it to undo any patch/delete/etc... changes
     * 3. If the request was to create a resource, remove from the queue all requests
     *    that depended upon that resource.
     * 4. Advance to next request
     *
     * @method _xhrHandleServerError
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {string} logMsg - Message to display in console
     * @param  {boolean} stringify - log object for quick debugging
     *
     */

  }, {
    key: '_xhrHandleServerError',
    value: function _xhrHandleServerError(result, logMsg, stringify) {
      // Execute all callbacks provided by the request
      if (result.request.callback) result.request.callback(result);
      if (stringify) {
        logger.error(logMsg + '\nREQUEST: ' + JSON.stringify(result.request.toObject(), null, 4) + '\nRESPONSE: ' + JSON.stringify(result.data, null, 4));
      } else {
        logger.error(logMsg, result);
      }
      this.trigger('sync:error', {
        target: result.request.target,
        request: result.request,
        error: result.data
      });

      result.request.success = false;

      // If a POST request fails, all requests that depend upon this object
      // must be purged
      if (result.request.operation === 'POST') {
        this._purgeDependentRequests(result.request);
      }

      // Remove this request as well (side-effect: rolls back the operation)
      this._removeRequest(result.request, true);

      // And finally, we are ready to try the next request
      this._processNextRequest();
    }

    /**
     * If there is a connection error, wait for retry.
     *
     * In the event of what appears to be a connection error,
     * Wait until a 'connected' event before processing the next request (actually reprocessing the current event)
     *
     * @method _xhrHandleConnectionError
     * @private
     */

  }, {
    key: '_xhrHandleConnectionError',
    value: function _xhrHandleConnectionError() {}
    // Nothing to be done; we already have the below event handler setup
    // this.onlineManager.once('connected', () => this._processNextRequest());


    /**
     * Verify that we are online and retry request.
     *
     * This method is called when we think we're online, but
     * have determined we need to validate that assumption.
     *
     * Test that we have a connection; if we do,
     * retry the request once, and if it fails again,
     * _xhrError() will determine it to have failed and remove it from the queue.
     *
     * If we are offline, then let _xhrHandleConnectionError handle it.
     *
     * @method _xhrValidateIsOnline
     * @private
     */

  }, {
    key: '_xhrValidateIsOnline',
    value: function _xhrValidateIsOnline(requestEvt) {
      var _this8 = this;

      logger.debug('Sync Manager verifying online state');
      this.onlineManager.checkOnlineStatus(function (isOnline) {
        return _this8._xhrValidateIsOnlineCallback(isOnline, requestEvt);
      });
    }

    /**
     * If we have verified we are online, retry request.
     *
     * We should have received a response to our /nonces call
     * which assuming the server is actually alive,
     * will tell us if the connection is working.
     *
     * If we are offline, flag us as offline and let the ConnectionError handler handle this
     * If we are online, give the request a single retry (there is never more than one retry)
     *
     * @method _xhrValidateIsOnlineCallback
     * @private
     * @param  {boolean} isOnline  - Response object returned by xhr call
     * @param {layer.SyncEvent} requestEvt - The request that failed triggering this call
     */

  }, {
    key: '_xhrValidateIsOnlineCallback',
    value: function _xhrValidateIsOnlineCallback(isOnline, requestEvt) {
      logger.debug('Sync Manager online check result is ' + isOnline);
      if (!isOnline) {
        // Treat this as a Connection Error
        this._xhrHandleConnectionError();
      } else {
        // Retry the request in case we were offline, but are now online.
        // Of course, if this fails, give it up entirely.
        requestEvt.retryCount++;
        this._processNextRequest();
      }
    }

    /**
     * The XHR request was successful.
     *
     * Any xhr request that actually succedes:
     *
     * 1. Remove it from the queue
     * 2. Call any callbacks
     * 3. Advance to next request
     *
     * @method _xhrSuccess
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {layer.SyncEvent} requestEvt - Request object
     */

  }, {
    key: '_xhrSuccess',
    value: function _xhrSuccess(result) {
      var requestEvt = result.request;
      logger.debug('Sync Manager ' + (requestEvt instanceof WebsocketSyncEvent ? 'Websocket' : 'XHR') + ' ' + (requestEvt.operation + ' Request on target ' + requestEvt.target + ' has Succeeded'), requestEvt.toObject());
      if (result.data) logger.debug(result.data);
      requestEvt.success = true;
      this._removeRequest(requestEvt, true);
      if (requestEvt.callback) requestEvt.callback(result);
      this._processNextRequest();

      this.trigger('sync:success', {
        target: requestEvt.target,
        request: requestEvt,
        response: result.data
      });
    }

    /**
     * Remove the SyncEvent request from the queue.
     *
     * @method _removeRequest
     * @private
     * @param  {layer.SyncEvent} requestEvt - SyncEvent Request to remove
     * @param {Boolean} deleteDB - Delete from indexedDB
     */

  }, {
    key: '_removeRequest',
    value: function _removeRequest(requestEvt, deleteDB) {
      var queue = requestEvt.operation === 'RECEIPT' ? this.receiptQueue : this.queue;
      var index = queue.indexOf(requestEvt);
      if (index !== -1) queue.splice(index, 1);
      if (deleteDB) this.client.dbManager.deleteObjects('syncQueue', [requestEvt]);
    }

    /**
     * Remove requests from queue that depend on specified resource.
     *
     * If there is a POST request to create a new resource, and there are PATCH, DELETE, etc...
     * requests on that resource, if the POST request fails, then all PATCH, DELETE, etc
     * requests must be removed from the queue.
     *
     * Note that we do not call the rollback on these dependent requests because the expected
     * rollback is to destroy the thing that was created, which means any other rollback has no effect.
     *
     * @method _purgeDependentRequests
     * @private
     * @param  {layer.SyncEvent} request - Request whose target is no longer valid
     */

  }, {
    key: '_purgeDependentRequests',
    value: function _purgeDependentRequests(request) {
      this.queue = this.queue.filter(function (evt) {
        return evt.depends.indexOf(request.target) === -1 || evt === request;
      });
      this.receiptQueue = this.receiptQueue.filter(function (evt) {
        return evt.depends.indexOf(request.target) === -1 || evt === request;
      });
    }

    /**
     * Remove from queue all events that operate upon the deleted object.
     *
     * @method _purgeOnDelete
     * @private
     * @param  {layer.SyncEvent} evt - Delete event that requires removal of other events
     */

  }, {
    key: '_purgeOnDelete',
    value: function _purgeOnDelete(evt) {
      var _this9 = this;

      this.queue.filter(function (request) {
        return request.depends.indexOf(evt.target) !== -1 && evt !== request;
      }).forEach(function (requestEvt) {
        _this9.trigger('sync:abort', {
          target: requestEvt.target,
          request: requestEvt
        });
        _this9._removeRequest(requestEvt, true);
      });
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.queue.forEach(function (evt) {
        return evt.destroy();
      });
      this.queue = null;
      this.receiptQueue.forEach(function (evt) {
        return evt.destroy();
      });
      this.receiptQueue = null;
      _get(Object.getPrototypeOf(SyncManager.prototype), 'destroy', this).call(this);
    }

    /**
     * Load any unsent requests from indexedDB.
     *
     * If persistence is disabled, nothing will happen;
     * else all requests found in the database will be added to the queue.
     * @method _loadPersistedQueue
     * @private
     */

  }, {
    key: '_loadPersistedQueue',
    value: function _loadPersistedQueue() {
      var _this10 = this;

      this.client.dbManager.loadSyncQueue(function (data) {
        if (data.length) {
          _this10.queue = _this10.queue.concat(data);
          _this10._processNextRequest();
        }
      });
    }
  }]);

  return SyncManager;
}(Root);

/**
 * Websocket Manager for getting socket state.
 * @type {layer.Websockets.SocketManager}
 */


SyncManager.prototype.socketManager = null;

/**
 * Websocket Request Manager for sending requests.
 * @type {layer.Websockets.RequestManager}
 */
SyncManager.prototype.requestManager = null;

/**
 * Reference to the Online State Manager.
 *
 * Sync Manager uses online status to determine if it can fire sync-requests.
 * @private
 * @type {layer.OnlineStateManager}
 */
SyncManager.prototype.onlineManager = null;

/**
 * The array of layer.SyncEvent instances awaiting to be fired.
 * @type {layer.SyncEvent[]}
 */
SyncManager.prototype.queue = null;

/**
 * The array of layer.SyncEvent instances awaiting to be fired.
 *
 * Receipts can generally just be fired off all at once without much fretting about ordering or dependencies.
 * @type {layer.SyncEvent[]}
 */
SyncManager.prototype.receiptQueue = null;

/**
 * Reference to the Client so that we can pass it to SyncEvents  which may need to lookup their targets
 */
SyncManager.prototype.client = null;

/**
 * Maximum exponential backoff wait.
 *
 * If the server is returning 502, 503 or 504 errors, exponential backoff
 * should never wait longer than this number of seconds (15 minutes)
 * @type {Number}
 * @static
 */
SyncManager.MAX_UNAVAILABLE_RETRY_WAIT = 60 * 15;

/**
 * Retries before suspect CORS error.
 *
 * How many times can we transition from offline to online state
 * with this request at the front of the queue before we conclude
 * that the reason we keep thinking we're going offline is
 * a CORS error returning a status of 0.  If that pattern
 * shows 3 times in a row, there is likely a CORS error.
 * Note that CORS errors appear to javascript as a status=0 error,
 * which is the same as if the client were offline.
 * @type {number}
 * @static
 */
SyncManager.MAX_RETRIES_BEFORE_CORS_ERROR = 3;

/**
 * Abort request after this number of retries.
 *
 * @type {number}
 * @static
 */
SyncManager.MAX_RETRIES = 20;

SyncManager._supportedEvents = [
/**
 * A sync request has failed.
 *
 * ```
 * client.syncManager.on('sync:error', function(evt) {
 *    console.error(evt.target.id + ' failed to send changes to server: ', result.data.message);
 *    console.log('Request Event:', requestEvt);
 *    console.log('Server Response:', result.data);
 * });
 * ```
 *
 * @event
 * @param {layer.SyncEvent} evt - The request object
 * @param {Object} result
 * @param {string} result.target - ID of the message/conversation/etc. being operated upon
 * @param {layer.SyncEvent} result.request - The original request
 * @param {Object} result.error - The error object {id, code, message, url}
 */
'sync:error',

/**
 * A sync layer request has completed successfully.
 *
 * ```
 * client.syncManager.on('sync:success', function(evt) {
 *    console.log(evt.target.id + ' changes sent to server successfully');
 *    console.log('Request Event:', requestEvt);
 *    console.log('Server Response:', result.data);
 * });
 * ```
 *
 * @event
 * @param {Object} result
 * @param {string} result.target - ID of the message/conversation/etc. being operated upon
 * @param {layer.SyncEvent} result.request - The original request
 * @param {Object} result.data - null or any data returned by the call
 */
'sync:success',

/**
 * A new sync request has been added.
 *
 * ```
 * client.syncManager.on('sync:add', function(evt) {
 *    console.log(evt.target.id + ' has changes queued for the server');
 *    console.log('Request Event:', requestEvt);
 * });
 * ```
 *
 * @event
 * @param {Object} result
 * @param {string} result.target - ID of the message/conversation/etc. being operated upon
 * @param {layer.SyncEvent} evt - The request object
 */
'sync:add',

/**
 * A sync request has been canceled.
 *
 * Typically caused by a new SyncEvent that deletes the target of this SyncEvent
 *
 * @event
 * @param {layer.SyncEvent} evt - The request object
 * @param {Object} result
 * @param {string} result.target - ID of the message/conversation/etc. being operated upon
 * @param {layer.SyncEvent} result.request - The original request
 */
'sync:abort'].concat(Root._supportedEvents);

Root.initClass(SyncManager);
module.exports = SyncManager;


},{"./client-utils":82,"./logger":88,"./root":116,"./sync-event":117,"./xhr":126}],119:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The TypingIndicatorListener receives Typing Indicator state
 * for other users via a websocket, and notifies
 * the client of the updated state.  Typical applications
 * do not access this component directly, but DO subscribe
 * to events produced by this component:
 *
 *      client.on('typing-indicator-change', function(evt) {
 *        if (evt.conversationId == conversationICareAbout) {
 *          console.log('The following users are typing: ' + evt.typing.join(', '));
 *          console.log('The following users are paused: ' + evt.paused.join(', '));
 *        }
 *      });
 *
 * @class layer.TypingIndicators.TypingIndicatorListener
 * @extends {layer.Root}
 */

var Root = require('../root');
var ClientRegistry = require('../client-registry');

var _require = require('./typing-indicators');

var STARTED = _require.STARTED;
var PAUSED = _require.PAUSED;
var FINISHED = _require.FINISHED;

var TypingIndicatorListener = function (_Root) {
  _inherits(TypingIndicatorListener, _Root);

  /**
   * Creates a Typing Indicator Listener for this Client.
   *
   * @method constructor
   * @protected
   * @param  {Object} args
   * @param {string} args.clientId - ID of the client this belongs to
   */
  function TypingIndicatorListener(args) {
    _classCallCheck(this, TypingIndicatorListener);

    /**
     * Stores the state of all Conversations, indicating who is typing and who is paused.
     *
     * People who are stopped are removed from this state.
     * @property {Object} state
     */
    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TypingIndicatorListener).call(this, args));

    _this.state = {};
    _this._pollId = 0;
    var client = _this._getClient();
    client.on('ready', function () {
      return _this._clientReady();
    });
    return _this;
  }

  /**
   * Called when the client is ready
   *
   * @method _clientReady
   * @private
   */


  _createClass(TypingIndicatorListener, [{
    key: '_clientReady',
    value: function _clientReady() {
      var client = this._getClient();
      this.user = client.user;
      var ws = client.socketManager;
      ws.on('message', this._handleSocketEvent, this);
      this._startPolling();
    }

    /**
     * Determines if this event is relevant to report on.
     * Must be a typing indicator signal that is reporting on
     * someone other than this user.
     *
     * @method _isRelevantEvent
     * @private
     * @param  {Object}  Websocket event data
     * @return {Boolean}
     */

  }, {
    key: '_isRelevantEvent',
    value: function _isRelevantEvent(evt) {
      return evt.type === 'signal' && evt.body.type === 'typing_indicator' && evt.body.data.sender.id !== this.user.id;
    }

    /**
     * This method receives websocket events and
     * if they are typing indicator events, updates its state.
     *
     * @method _handleSocketEvent
     * @private
     * @param {layer.LayerEvent} evtIn - All websocket events
     */

  }, {
    key: '_handleSocketEvent',
    value: function _handleSocketEvent(evtIn) {
      var _this2 = this;

      var evt = evtIn.data;

      if (this._isRelevantEvent(evt)) {
        (function () {
          // Could just do _createObject() but for ephemeral events, going through _createObject and updating
          // objects for every typing indicator seems a bit much.  Try getIdentity and only create if needed.
          var identity = _this2._getClient().getIdentity(evt.body.data.sender.id) || _this2._getClient()._createObject(evt.body.data.sender);
          var state = evt.body.data.action;
          var conversationId = evt.body.object.id;
          var stateEntry = _this2.state[conversationId];
          if (!stateEntry) {
            stateEntry = _this2.state[conversationId] = {
              users: {},
              typing: [],
              paused: []
            };
          }
          stateEntry.users[identity.id] = {
            startTime: Date.now(),
            state: state,
            identity: identity
          };
          if (stateEntry.users[identity.id].state === FINISHED) {
            delete stateEntry.users[identity.id];
          }

          _this2._updateState(stateEntry, state, identity.id);

          _this2.trigger('typing-indicator-change', {
            conversationId: conversationId,
            typing: stateEntry.typing.map(function (id) {
              return stateEntry.users[id].identity.toObject();
            }),
            paused: stateEntry.paused.map(function (id) {
              return stateEntry.users[id].identity.toObject();
            })
          });
        })();
      }
    }

    /**
     * Get the current typing indicator state of a specified Conversation.
     *
     * Typically used to see if anyone is currently typing when first opening a Conversation.
     * Typically accessed via `client.getTypingState(conversationId)`
     *
     * @method getState
     * @param {String} conversationId
     */

  }, {
    key: 'getState',
    value: function getState(conversationId) {
      var stateEntry = this.state[conversationId];
      if (stateEntry) {
        return {
          typing: stateEntry.typing.map(function (id) {
            return stateEntry.users[id].identity.toObject();
          }),
          paused: stateEntry.paused.map(function (id) {
            return stateEntry.users[id].identity.toObject();
          })
        };
      } else {
        return {
          typing: [],
          paused: []
        };
      }
    }

    /**
     * Updates the state of a single stateEntry; a stateEntry
     * represents a single Conversation's typing indicator data.
     *
     * Updates typing and paused arrays following immutable strategies
     * in hope that this will help Flex based architectures.
     *
     * @method _updateState
     * @private
     * @param  {Object} stateEntry - A Conversation's typing indicator state
     * @param  {string} newState   - started, paused or finished
     * @param  {string} identityId     - ID of the user whose state has changed
     */

  }, {
    key: '_updateState',
    value: function _updateState(stateEntry, newState, identityId) {
      var typingIndex = stateEntry.typing.indexOf(identityId);
      if (newState !== STARTED && typingIndex !== -1) {
        stateEntry.typing = [].concat(_toConsumableArray(stateEntry.typing.slice(0, typingIndex)), _toConsumableArray(stateEntry.typing.slice(typingIndex + 1)));
      }
      var pausedIndex = stateEntry.paused.indexOf(identityId);
      if (newState !== PAUSED && pausedIndex !== -1) {
        stateEntry.paused = [].concat(_toConsumableArray(stateEntry.paused.slice(0, pausedIndex)), _toConsumableArray(stateEntry.paused.slice(pausedIndex + 1)));
      }

      if (newState === STARTED && typingIndex === -1) {
        stateEntry.typing = [].concat(_toConsumableArray(stateEntry.typing), [identityId]);
      } else if (newState === PAUSED && pausedIndex === -1) {
        stateEntry.paused = [].concat(_toConsumableArray(stateEntry.paused), [identityId]);
      }
    }

    /**
     * Any time a state change becomes more than 6 seconds stale,
     * assume that the user is 'finished'.
     *
     * In theory, we should
     * receive a new event every 2.5 seconds.  If the current user
     * has gone offline, lack of this code would cause the people
     * currently flagged as typing as still typing hours from now.
     *
     * For this first pass, we just mark the user as 'finished'
     * but a future pass may move from 'started' to 'paused'
     * and 'paused to 'finished'
     *
     * @method _startPolling
     * @private
     */

  }, {
    key: '_startPolling',
    value: function _startPolling() {
      var _this3 = this;

      if (this._pollId) return;
      this._pollId = setInterval(function () {
        return _this3._poll();
      }, 5000);
    }
  }, {
    key: '_poll',
    value: function _poll() {
      var _this4 = this;

      var conversationIds = Object.keys(this.state);

      conversationIds.forEach(function (id) {
        var state = _this4.state[id];
        Object.keys(state.users).forEach(function (identityId) {
          if (Date.now() >= state.users[identityId].startTime + 6000) {
            _this4._updateState(state, FINISHED, identityId);
            delete state.users[identityId];
            _this4.trigger('typing-indicator-change', {
              conversationId: id,
              typing: state.typing.map(function (aIdentityId) {
                return state.users[aIdentityId].identity.toObject();
              }),
              paused: state.paused.map(function (aIdentityId) {
                return state.users[aIdentityId].identity.toObject();
              })
            });
          }
        });
      });
    }

    /**
     * Get the Client associated with this class.  Uses the clientId
     * property.
     *
     * @method _getClient
     * @protected
     * @return {layer.Client}
     */

  }, {
    key: '_getClient',
    value: function _getClient() {
      return ClientRegistry.get(this.clientId);
    }
  }]);

  return TypingIndicatorListener;
}(Root);

/**
 * setTimeout ID for polling for states to transition
 * @type {Number}
 * @private
 */


TypingIndicatorListener.prototype._pollId = 0;

/**
 * ID of the client this instance is associated with
 * @type {String}
 */
TypingIndicatorListener.prototype.clientId = '';

TypingIndicatorListener.bubbleEventParent = '_getClient';

TypingIndicatorListener._supportedEvents = [
/**
 * There has been a change in typing indicator state of other users.
 * @event change
 * @param {layer.LayerEvent} evt
 * @param {layer.Identity[]} evt.typing - Array of Identities of people who are typing
 * @param {layer.Identity[]} evt.paused - Array of Identities of people who are paused
 * @param {string} evt.conversationId - ID of the Conversation that has changed typing indicator state
 */
'typing-indicator-change'].concat(Root._supportedEvents);

Root.initClass.apply(TypingIndicatorListener, [TypingIndicatorListener, 'TypingIndicatorListener']);
module.exports = TypingIndicatorListener;


},{"../client-registry":81,"../root":116,"./typing-indicators":120}],120:[function(require,module,exports){
'use strict';

/**
 * Static properties here only needed if your directly using
 * the layer.TypingIndicators.TypingPublisher (not needed if
 * you are using the layer.TypingIndicators.TypingListener).
 *
 *      typingPublisher.setState(layer.TypingIndicators.STARTED);
 *
 * @class  layer.TypingIndicators
 * @static
 */
module.exports = {
  /**
   * Typing has started/resumed
   * @type {String}
   * @static
   */
  STARTED: 'started',

  /**
   * Typing has paused
   * @type {String}
   * @static
   */
  PAUSED: 'paused',

  /**
   * Typing has finished
   * @type {String}
   * @static
   */
  FINISHED: 'finished'
};


},{}],121:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TypingPublisher = require('./typing-publisher');

var _require = require('./typing-indicators');

var STARTED = _require.STARTED;
var PAUSED = _require.PAUSED;
var FINISHED = _require.FINISHED;

/**
 * The Typing Listener Class listens to keyboard events on
 * your text field, and uses the layer.TypingPublisher to
 * send state based on keyboard behavior.
 *
 *      var typingListener = client.createTypingListener(document.getElementById('mytextarea'));
 *
 *  You change what Conversation
 *  the typing indicator reports your user to be typing
 *  in by calling:
 *
 *      typingListener.setConversation(mySelectedConversation);
 *
 * There are two ways of cleaning up all pointers to your input so it can be garbage collected:
 *
 * 1. Destroy the listener:
 *
 *        typingListener.destroy();
 *
 * 2. Remove or replace the input:
 *
 *        typingListener.setInput(null);
 *        typingListener.setInput(newInput);
 *
 * @class  layer.TypingIndicators.TypingListener
 */

var TypingListener = function () {

  /**
   * Create a TypingListener that listens for the user's typing.
   *
   * The TypingListener needs
   * to know what Conversation the user is typing into... but it does not require that parameter during initialization.
   *
   * @method constructor
   * @param  {Object} args
   * @param {string} args.clientId - The ID of the client; used so that the TypingPublisher can access its websocket manager*
   * @param {HTMLElement} [args.input=null] - A Text editor dom node that will have typing indicators
   * @param {Object} [args.conversation=null] - The Conversation Object or Instance that the input will send messages to
   */
  function TypingListener(args) {
    _classCallCheck(this, TypingListener);

    this.clientId = args.clientId;
    this.conversation = args.conversation;
    this.publisher = new TypingPublisher({
      clientId: this.clientId,
      conversation: this.conversation
    });

    this.intervalId = 0;
    this.lastKeyId = 0;

    this._handleKeyPress = this._handleKeyPress.bind(this);
    this._handleKeyDown = this._handleKeyDown.bind(this);
    this.setInput(args.input);
  }

  _createClass(TypingListener, [{
    key: 'destroy',
    value: function destroy() {
      this._removeInput(this.input);
      this.publisher.destroy();
    }

    /**
     * Change the input being tracked by your TypingListener.
     *
     * If you are removing your input from the DOM, you can simply call
     *
     *     typingListener.setInput(null);
     *
     * And all event handlers will be removed, allowing for garbage collection
     * to cleanup your input.
     *
     * You can also call setInput with a newly created input:
     *
     *     var input = document.createElement('input');
     *     typingListener.setInput(input);
     *
     * @method setInput
     * @param {HTMLElement} input - Textarea or text input
     */

  }, {
    key: 'setInput',
    value: function setInput(input) {
      if (input !== this.input) {
        this._removeInput(this.input);
        this.input = input;

        // Use keypress rather than keydown because the user hitting alt-tab to change
        // windows, and other meta keys should not result in typing indicators
        this.input.addEventListener('keypress', this._handleKeyPress);
        this.input.addEventListener('keydown', this._handleKeyDown);
      }
    }

    /**
     * Cleanup and remove all links and callbacks keeping input from being garbage collected.
     *
     * @method _removeInput
     * @private
     * @param {HTMLElement} input - Textarea or text input
     */

  }, {
    key: '_removeInput',
    value: function _removeInput(input) {
      if (input) {
        input.removeEventListener('keypress', this._handleKeyPress);
        input.removeEventListener('keydown', this._handleKeyDown);
        this.input = null;
      }
    }

    /**
     * Change the Conversation; this should set the state of the old Conversation to "finished".
     *
     * Use this when the user has changed Conversations and you want to report on typing to a new
     * Conversation.
     *
     * @method setConversation
     * @param  {Object} conv - The new Conversation Object or Instance
     */

  }, {
    key: 'setConversation',
    value: function setConversation(conv) {
      if (conv !== this.conversation) {
        this.conversation = conv;
        this.publisher.setConversation(conv);
      }
    }

    /**
     * Whenever the key is pressed, send a "started" or "finished" event.
     *
     * @method _handleKeyPress
     * @private
     * @param  {KeyboardEvent} evt
     */

  }, {
    key: '_handleKeyPress',
    value: function _handleKeyPress(evt) {
      var _this = this;

      if (this.lastKeyId) window.clearTimeout(this.lastKeyId);
      this.lastKeyId = window.setTimeout(function () {
        _this.lastKeyId = 0;
        var isEmpty = !_this.input.value;
        _this.send(isEmpty ? FINISHED : STARTED);
      }, 50);
    }

    /**
     * Handles keyboard keys not reported by on by keypress events.
     *
     * These keys can be detected with keyDown event handlers. The ones
     * currently handled here are backspace, delete and enter.
     * We may add more later.
     *
     * @method _handleKeyDown
     * @private
     * @param  {KeyboardEvent} evt
     */

  }, {
    key: '_handleKeyDown',
    value: function _handleKeyDown(evt) {
      if ([8, 46, 13].indexOf(evt.keyCode) !== -1) this._handleKeyPress();
    }

    /**
     * Send the state to the publisher.
     *
     * If your application requires
     * you to directly control the state, you can call this method;
     * however, as long as you use this TypingListener, keyboard
     * events will overwrite any state changes you send.
     *
     * Common use case for this: After a message is sent, you want to clear any typing indicators:
     *
     *      function send() {
     *        message.send();
     *        typingIndicators.send(layer.TypingIndicators.FINISHED);
     *      }
     *
     * @method send
     * @param  {string} state - One of "started", "paused", "finished"
     */

  }, {
    key: 'send',
    value: function send(state) {
      this.publisher.setState(state);
    }
  }]);

  return TypingListener;
}();

module.exports = TypingListener;


},{"./typing-indicators":120,"./typing-publisher":122}],122:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The TypingPublisher's job is:
 *
 *  1. Send state changes to the server
 *  2. Insure that the server is not flooded with repeated state changes of the same value
 *  3. Automatically transition states when no new states or old states are requested.
 *
 * Who is the Typing Publisher for?  Its used by the layer.TypingIndicators.TypingListener; if your using
 * the TypingListener, you don't need this.  If you want to provide your own logic for when to send typing
 * states, then you need the TypingPublisher.
 *
 * Create an instance using:
 *
 *        var publisher = client.createTypingPublisher();
 *
 * To tell the Publisher which Conversation its reporting activity on, use:
 *
 *        publisher.setConversation(mySelectedConversation);
 *
 * To then use the instance:
 *
 *        publisher.setState(layer.TypingIndicators.STARTED);
 *        publisher.setState(layer.TypingIndicators.PAUSED);
 *        publisher.setState(layer.TypingIndicators.FINISHED);
 *
 * Note that the `STARTED` state only lasts for 2.5 seconds, so you
 * must repeatedly call setState for as long as this state should continue.
 * This is typically done by simply calling `setState(STARTED)` every time a user hits
 * a key.
 *
 * A few rules for how the *publisher* works internally:
 *
 *  - it maintains an indicator state for the current conversation
 *  - if app calls  `setState(layer.TypingIndicators.STARTED);` publisher sends the event immediately
 *  - if app calls the same method under _2.5 seconds_ with the same typing indicator state (`started`), publisher waits
 *    for those 2.5 seconds to pass and then publishes the ephemeral event
 *  - if app calls the same methods multiple times within _2.5 seconds_ with the same value,
 *    publisher waits until end of 2.5 second period and sends the state only once.
 *  - if app calls the same method under _2.5 seconds_ with a different typing indicator state (say `paused`),
 *    publisher immediately sends the event
 *  - if 2.5 seconds passes without any events, state transitions from 'started' to 'paused'
 *  - if 2.5 seconds passes without any events, state transitions from 'paused' to 'finished'
 *
 * @class layer.TypingIndicators.TypingPublisher
 * @protected
 */

var INTERVAL = 2500;

var _require = require('./typing-indicators');

var STARTED = _require.STARTED;
var PAUSED = _require.PAUSED;
var FINISHED = _require.FINISHED;

var ClientRegistry = require('../client-registry');

var TypingPublisher = function () {

  /**
   * Create a Typing Publisher.  See layer.Client.createTypingPublisher.
   *
   * The TypingPublisher needs
   * to know what Conversation its publishing changes for...
   * but it does not require that parameter during initialization.
   *
   * @method constructor
   * @param {Object} args
   * @param {string} clientId - The ID for the client from which we will get access to the websocket
   * @param {Object} [conversation=null] - The Conversation Object or Instance that messages are being typed to.
   */
  function TypingPublisher(args) {
    _classCallCheck(this, TypingPublisher);

    this.clientId = args.clientId;
    if (args.conversation) this.conversation = this._getClient().getObject(args.conversation.id);
    this.state = FINISHED;
    this._lastMessageTime = 0;
  }

  /**
   * Set which Conversation we are reporting on state changes for.
   *
   * If this instance managed a previous Conversation,
   * its state is immediately transitioned to "finished".
   *
   * @method setConversation
   * @param  {Object} conv - Conversation Object or Instance
   */


  _createClass(TypingPublisher, [{
    key: 'setConversation',
    value: function setConversation(conv) {
      this.setState(FINISHED);
      this.conversation = conv ? this._getClient().getObject(conv.id) : null;
      this.state = FINISHED;
    }

    /**
     * Sets the state and either sends the state to the server or schedules it to be sent.
     *
     * @method setState
     * @param  {string} state - One of
     * * layer.TypingIndicators.STARTED
     * * layer.TypingIndicators.PAUSED
     * * layer.TypingIndicators.FINISHED
     */

  }, {
    key: 'setState',
    value: function setState(state) {
      // We have a fresh state; whatever our pauseLoop was doing
      // can be canceled... and restarted later.
      if (this._pauseLoopId) {
        clearInterval(this._pauseLoopId);
        this._pauseLoopId = 0;
      }
      if (!this.conversation) return;

      // If its a new state, send it immediately.
      if (this.state !== state) {
        this.state = state;
        this._send(state);
      }

      // No need to resend 'finished' state
      else if (state === FINISHED) {
          return;
        }

        // If its an existing state that hasn't been sent in the
        // last 2.5 seconds, send it immediately.
        else if (Date.now() > this._lastMessageTime + INTERVAL) {
            this._send(state);
          }

          // Else schedule it to be sent.
          else {
              this._scheduleNextMessage(state);
            }

      // Start test to automatically transition if 2.5 seconds without any setState calls
      if (this.state !== FINISHED) this._startPauseLoop();
    }

    /**
     * Start loop to automatically change to next state.
     *
     * Any time we are set to 'started' or 'paused' we should transition
     * to the next state after 2.5 seconds of no setState calls.
     *
     * The 2.5 second setTimeout is canceled/restarted every call to setState()
     *
     * @method _startPauseLoop
     * @private
     */

  }, {
    key: '_startPauseLoop',
    value: function _startPauseLoop() {
      var _this = this;

      if (this._pauseLoopId) return;

      // Note that this interval is canceled every call to setState.
      this._pauseLoopId = window.setInterval(function () {
        if (_this.state === PAUSED) {
          _this.setState(FINISHED);
        } else if (_this.state === STARTED) {
          _this.setState(PAUSED);
        }
      }, INTERVAL);
    }

    /**
     * Schedule the next state refresh message.
     *
     * It should be at least INTERVAL ms after
     * the last state message of the same state
     *
     * @method _scheduleNextMessage
     * @private
     * @param  {string} state - One of
     * * layer.TypingIndicators.STARTED
     * * layer.TypingIndicators.PAUSED
     * * layer.TypingIndicators.FINISHED
     */

  }, {
    key: '_scheduleNextMessage',
    value: function _scheduleNextMessage(state) {
      var _this2 = this;

      if (this._scheduleId) clearTimeout(this._scheduleId);
      var delay = INTERVAL - Math.min(Date.now() - this._lastMessageTime, INTERVAL);
      this._scheduleId = setTimeout(function () {
        _this2._scheduleId = 0;
        // If the state didn't change while waiting...
        if (_this2.state === state) _this2._send(state);
      }, delay);
    }

    /**
     * Send a state change to the server.
     *
     * @method send
     * @private
     * @param  {string} state - One of
     * * layer.TypingIndicators.STARTED
     * * layer.TypingIndicators.PAUSED
     * * layer.TypingIndicators.FINISHED
     */

  }, {
    key: '_send',
    value: function _send(state) {
      if (!this.conversation.isSaved()) return;
      this._lastMessageTime = Date.now();
      var ws = this._getClient().socketManager;
      ws.sendSignal({
        type: 'typing_indicator',
        object: {
          id: this.conversation.id
        },
        data: {
          action: state
        }
      });
    }

    /**
     * Get the Client associated with this layer.Message.
     *
     * Uses the clientId property.
     *
     * @method getClient
     * @return {layer.Client}
     */

  }, {
    key: '_getClient',
    value: function _getClient() {
      return ClientRegistry.get(this.clientId);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      delete this.conversation;
      this.isDestroyed = true;
      clearTimeout(this._scheduleId);
      clearInterval(this._pauseLoopId);
    }
  }]);

  return TypingPublisher;
}();

module.exports = TypingPublisher;


},{"../client-registry":81,"./typing-indicators":120}],123:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class  layer.Websockets.ChangeManager
 * @private
 *
 * This class listens for `change` events from the websocket server,
 * and processes them.
 */
var Utils = require('../client-utils');
var logger = require('../logger');
var Message = require('../models/message');
var Conversation = require('../models/conversation');
var Channel = require('../models/channel');

var WebsocketChangeManager = function () {
  /**
   * Create a new websocket change manager
   *
   *      var websocketChangeManager = new layer.Websockets.ChangeManager({
   *          client: client,
   *          socketManager: client.Websockets.SocketManager
   *      });
   *
   * @method
   * @param  {Object} options
   * @param {layer.Client} client
   * @param {layer.Websockets.SocketManager} socketManager
   * @returns {layer.Websockets.ChangeManager}
   */
  function WebsocketChangeManager(options) {
    _classCallCheck(this, WebsocketChangeManager);

    this.client = options.client;
    options.socketManager.on('message', this._handleChange, this);
  }

  /**
   * Handles a Change packet from the server.
   *
   * @method _handleChange
   * @private
   * @param  {layer.LayerEvent} evt
   */


  _createClass(WebsocketChangeManager, [{
    key: '_handleChange',
    value: function _handleChange(evt) {
      if (evt.data.type === 'change') {
        this._processChange(evt.data.body);
      }
    }

    /**
     * Process changes from a change packet.
     *
     * Called both by _handleChange, and by the requestManager on getting a changes array.
     *
     * @method _processChanage
     * @private
     * @param {Object} msg
     */

  }, {
    key: '_processChange',
    value: function _processChange(msg) {
      switch (msg.operation) {
        case 'create':
          logger.info('Websocket Change Event: Create ' + msg.object.type + ' ' + msg.object.id);
          logger.debug(msg.data);
          this._handleCreate(msg);
          break;
        case 'delete':
          logger.info('Websocket Change Event: Delete ' + msg.object.type + ' ' + msg.object.id);
          logger.debug(msg.data);
          this._handleDelete(msg);
          break;
        case 'update':
          logger.info('Websocket Change Event: Patch ' + msg.object.type + ' ' + msg.object.id + ': ' + msg.data.map(function (op) {
            return op.property;
          }).join(', '));
          logger.debug(msg.data);
          this._handlePatch(msg);
          break;
      }
    }

    /**
     * Process a create object message from the server
     *
     * @method _handleCreate
     * @private
     * @param  {Object} msg
     */

  }, {
    key: '_handleCreate',
    value: function _handleCreate(msg) {
      msg.data.fromWebsocket = true;
      this.client._createObject(msg.data);
    }

    /**
     * Handles delete object messages from the server.
     * All objects that can be deleted from the server should
     * provide a _deleted() method to be called prior to destroy().
     *
     * @method _handleDelete
     * @private
     * @param  {Object} msg
     */

  }, {
    key: '_handleDelete',
    value: function _handleDelete(msg) {
      var entity = this.getObject(msg);
      if (entity) {
        entity._handleWebsocketDelete(msg.data);
      }
    }

    /**
     * On receiving an update/patch message from the server
     * run the LayerParser on the data.
     *
     * @method _handlePatch
     * @private
     * @param  {Object} msg
     */

  }, {
    key: '_handlePatch',
    value: function _handlePatch(msg) {
      // Can only patch a cached object
      var entity = this.getObject(msg);
      if (entity) {
        try {
          entity._inLayerParser = true;
          Utils.layerParse({
            object: entity,
            type: msg.object.type,
            operations: msg.data,
            client: this.client
          });
          entity._inLayerParser = false;
        } catch (err) {
          logger.error('websocket-manager: Failed to handle event', msg.data);
        }
      } else {
        switch (Utils.typeFromID(msg.object.id)) {
          case 'channels':
            if (Channel._loadResourceForPatch(msg.data)) this.client.getObject(msg.object.id, true);
            break;
          case 'conversations':
            if (Conversation._loadResourceForPatch(msg.data)) this.client.getObject(msg.object.id, true);
            break;
          case 'messages':
            if (Message._loadResourceForPatch(msg.data)) this.client.getMessage(msg.object.id, true);
            break;
          case 'announcements':
            break;
        }
      }
    }

    /**
     * Get the object specified by the `object` property of the websocket packet.
     *
     * @method getObject
     * @private
     * @param  {Object} msg
     * @return {layer.Root}
     */

  }, {
    key: 'getObject',
    value: function getObject(msg) {
      return this.client.getObject(msg.object.id);
    }

    /**
     * Not required, but destroy is best practice
     * @method destroy
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.client = null;
    }
  }]);

  return WebsocketChangeManager;
}();

/**
 * The Client that owns this.
 * @type {layer.Client}
 */


WebsocketChangeManager.prototype.client = null;

module.exports = WebsocketChangeManager;


},{"../client-utils":82,"../logger":88,"../models/channel":97,"../models/conversation":101,"../models/message":105}],124:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class  layer.Websockets.RequestManager
 * @private
 *
 * This class allows one to send requests to the websocket server, and provide a callback,
 * And have that callback either called by the correct websocket server response, or
 * be called with a timeout.
 */
var Utils = require('../client-utils');
var logger = require('../logger');
var LayerError = require('../layer-error');

// Wait 15 seconds for a response and then give up
var DELAY_UNTIL_TIMEOUT = 15 * 1000;

var WebsocketRequestManager = function () {
  /**
   * Create a new websocket change manager
   *
   *      var websocketRequestManager = new layer.Websockets.RequestManager({
   *          client: client,
   *          socketManager: client.Websockets.SocketManager
   *      });
   *
   * @method
   * @param  {Object} options
   * @param {layer.Client} client
   * @param {layer.Websockets.SocketManager} socketManager
   * @returns {layer.Websockets.RequestManager}
   */
  function WebsocketRequestManager(options) {
    _classCallCheck(this, WebsocketRequestManager);

    this.client = options.client;
    this.socketManager = options.socketManager;
    this.socketManager.on({
      message: this._handleResponse,
      disconnected: this._reset
    }, this);

    this._requestCallbacks = {};
  }

  _createClass(WebsocketRequestManager, [{
    key: '_reset',
    value: function _reset() {
      this._requestCallbacks = {};
    }

    /**
     * This is an imprecise method; it will cancel ALL requests of a given type.
     *
     * @method cancelOperation
     * @param {String} methodName    `Message.create`, `Event.sync`, etc...
     */

  }, {
    key: 'cancelOperation',
    value: function cancelOperation(methodName) {
      var _this = this;

      Object.keys(this._requestCallbacks).forEach(function (key) {
        var requestConfig = _this._requestCallbacks[key];
        if (requestConfig.method === methodName) delete _this._requestCallbacks[key];
      });
    }

    /**
     * Handle a response to a request.
     *
     * @method _handleResponse
     * @private
     * @param  {layer.LayerEvent} evt
     */

  }, {
    key: '_handleResponse',
    value: function _handleResponse(evt) {
      if (evt.data.type === 'response') {
        var msg = evt.data.body;
        var requestId = msg.request_id;
        logger.debug('Websocket response ' + requestId + ' ' + (msg.success ? 'Successful' : 'Failed'));

        if (requestId && this._requestCallbacks[requestId]) {
          this._processResponse(requestId, evt);
        }
      }
    }

    /**
     * Process a response to a request; used by _handleResponse.
     *
     * Refactored out of _handleResponse so that unit tests can easily
     * use it to trigger completion of a request.
     *
     * @method _processResponse
     * @private
     * @param {String} requestId
     * @param {Object} evt   Data from the server
     */

  }, {
    key: '_processResponse',
    value: function _processResponse(requestId, evt) {
      var request = this._requestCallbacks[requestId];
      var msg = evt.data.body;
      var data = (msg.success ? msg.data : new LayerError(msg.data)) || {};

      if (msg.success) {
        if (request.isChangesArray) {
          this._handleChangesArray(data.changes);
        }
        if ('batch' in data) {
          request.batchTotal = data.batch.count;
          request.batchIndex = data.batch.index;
          if (request.isChangesArray) {
            request.results = request.results.concat(data.changes);
          } else if ('results' in data && Array.isArray(data.results)) {
            request.results = request.results.concat(data.results);
          }
          if (data.batch.index < data.batch.count - 1) return;
        }
      }
      request.callback({
        success: msg.success,
        fullData: 'batch' in data ? request.results : evt.data,
        data: data
      });
      delete this._requestCallbacks[requestId];
    }

    /**
     * Any request that contains an array of changes should deliver each change
     * to the socketChangeManager.
     *
     * @method _handleChangesArray
     * @private
     * @param {Object[]} changes   "create", "update", and "delete" requests from server.
     */

  }, {
    key: '_handleChangesArray',
    value: function _handleChangesArray(changes) {
      var _this2 = this;

      changes.forEach(function (change) {
        return _this2.client.socketChangeManager._processChange(change);
      });
    }

    /**
     * Shortcut for sending a request; builds in handling for callbacks
     *
     *    manager.sendRequest({
     *      data: {
     *        operation: "delete",
     *        object: {id: "layer:///conversations/uuid"},
     *        data: {deletion_mode: "all_participants"}
     *      },
     *      callback: function(result) {
     *        alert(result.success ? "Yay" : "Boo");
     *      },
     *      isChangesArray: false
     *    });
     *
     * @method sendRequest
     * @param  {Object} options
     * @param  {Object} otions.data                     Data to send to the server
     * @param  {Function} [options.callback=null]       Handler for success/failure callback
     * @param  {Boolean} [options.isChangesArray=false] Response contains a changes array that can be fed directly to change-manager.
     * @returns the request callback object if there is one; primarily for use in testing.
     */

  }, {
    key: 'sendRequest',
    value: function sendRequest(_ref) {
      var data = _ref.data;
      var callback = _ref.callback;
      var _ref$isChangesArray = _ref.isChangesArray;
      var isChangesArray = _ref$isChangesArray === undefined ? false : _ref$isChangesArray;

      if (!this._isOpen()) {
        return !callback ? undefined : callback(new LayerError({
          success: false,
          data: { id: 'not_connected', code: 0, message: 'WebSocket not connected' }
        }));
      }
      var body = Utils.clone(data);
      body.request_id = 'r' + this._nextRequestId++;
      logger.debug('Request ' + body.request_id + ' is sending');
      if (callback) {
        this._requestCallbacks[body.request_id] = {
          request_id: body.request_id,
          date: Date.now(),
          callback: callback,
          isChangesArray: isChangesArray,
          method: data.method,
          batchIndex: -1,
          batchTotal: -1,
          results: []
        };
      }

      this.socketManager.send({
        type: 'request',
        body: body
      });
      this._scheduleCallbackCleanup();
      if (body.request_id) return this._requestCallbacks[body.request_id];
    }

    /**
     * Flags a request as having failed if no response within 2 minutes
     *
     * @method _scheduleCallbackCleanup
     * @private
     */

  }, {
    key: '_scheduleCallbackCleanup',
    value: function _scheduleCallbackCleanup() {
      if (!this._callbackCleanupId) {
        this._callbackCleanupId = setTimeout(this._runCallbackCleanup.bind(this), DELAY_UNTIL_TIMEOUT + 50);
      }
    }

    /**
     * Calls callback with an error.
     *
     * NOTE: Because we call requests that expect responses serially instead of in parallel,
     * currently there should only ever be a single entry in _requestCallbacks.  This may change in the future.
     *
     * @method _runCallbackCleanup
     * @private
     */

  }, {
    key: '_runCallbackCleanup',
    value: function _runCallbackCleanup() {
      var _this3 = this;

      this._callbackCleanupId = 0;
      // If the websocket is closed, ignore all callbacks.  The Sync Manager will reissue these requests as soon as it gets
      // a 'connected' event... they have not failed.  May need to rethink this for cases where third parties are directly
      // calling the websocket manager bypassing the sync manager.
      if (this.isDestroyed || !this._isOpen()) return;
      var count = 0;
      var now = Date.now();
      Object.keys(this._requestCallbacks).forEach(function (requestId) {
        var callbackConfig = _this3._requestCallbacks[requestId];
        // If the request hasn't expired, we'll need to reschedule callback cleanup; else if its expired...
        if (callbackConfig && now < callbackConfig.date + DELAY_UNTIL_TIMEOUT) {
          count++;
        }

        // If there has been no data from the server, there's probably a problem with the websocket; reconnect.
        else if (now > _this3.socketManager._lastDataFromServerTimestamp + DELAY_UNTIL_TIMEOUT) {
            _this3.socketManager._reconnect(false);
            _this3._scheduleCallbackCleanup();
          } else {
            // The request isn't responding and the socket is good; fail the request.
            _this3._timeoutRequest(requestId);
          }
      });
      if (count) this._scheduleCallbackCleanup();
    }
  }, {
    key: '_timeoutRequest',
    value: function _timeoutRequest(requestId) {
      try {
        logger.warn('Websocket request timeout');
        this._requestCallbacks[requestId].callback({
          success: false,
          data: new LayerError({
            id: 'request_timeout',
            message: 'The server is not responding. We know how much that sucks.',
            url: 'https:/developer.layer.com/docs/websdk',
            code: 0,
            status: 408,
            httpStatus: 408
          })
        });
      } catch (err) {
        // Do nothing
      }
      delete this._requestCallbacks[requestId];
    }
  }, {
    key: '_isOpen',
    value: function _isOpen() {
      return this.socketManager._isOpen();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.isDestroyed = true;
      if (this._callbackCleanupId) clearTimeout(this._callbackCleanupId);
      this._requestCallbacks = null;
    }
  }]);

  return WebsocketRequestManager;
}();

WebsocketRequestManager.prototype._nextRequestId = 1;

/**
 * The Client that owns this.
 * @type {layer.Client}
 */
WebsocketRequestManager.prototype.client = null;

WebsocketRequestManager.prototype._requestCallbacks = null;

WebsocketRequestManager.prototype._callbackCleanupId = 0;

WebsocketRequestManager.prototype.socketManager = null;

module.exports = WebsocketRequestManager;


},{"../client-utils":82,"../layer-error":86,"../logger":88}],125:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This component manages
 *
 * 1. recieving websocket events
 * 2. Processing them
 * 3. Triggering events on completing them
 * 4. Sending them
 *
 * Applications typically do not interact with this component, but may subscribe
 * to the `message` event if they want richer event information than is available
 * through the layer.Client class.
 *
 * @class  layer.Websockets.SocketManager
 * @extends layer.Root
 * @private
 */
var Root = require('../root');
var Utils = require('../client-utils');
var logger = require('../logger');
var LayerError = require('../layer-error');

var _require = require('../const');

var WEBSOCKET_PROTOCOL = _require.WEBSOCKET_PROTOCOL;

var SocketManager = function (_Root) {
  _inherits(SocketManager, _Root);

  /**
   * Create a new websocket manager
   *
   *      var socketManager = new layer.Websockets.SocketManager({
   *          client: client,
   *      });
   *
   * @method
   * @param  {Object} options
   * @param {layer.Client} client
   * @return {layer.Websockets.SocketManager}
   */
  function SocketManager(options) {
    _classCallCheck(this, SocketManager);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SocketManager).call(this, options));

    if (!_this.client) throw new Error('SocketManager requires a client');

    // Insure that on/off methods don't need to call bind, therefore making it easy
    // to add/remove functions as event listeners.
    _this._onMessage = _this._onMessage.bind(_this);
    _this._onOpen = _this._onOpen.bind(_this);
    _this._onSocketClose = _this._onSocketClose.bind(_this);
    _this._onError = _this._onError.bind(_this);

    // If the client is authenticated, start it up.
    if (_this.client.isAuthenticated && _this.client.onlineManager.isOnline) {
      _this.connect();
    }

    _this.client.on('online', _this._onlineStateChange, _this);

    // Any time the Client triggers a ready event we need to reconnect.
    _this.client.on('authenticated', _this.connect, _this);

    _this._lastTimestamp = Date.now();
    return _this;
  }

  /**
   * Call this when we want to reset all websocket state; this would be done after a lengthy period
   * of being disconnected.  This prevents Event.replay from being called on reconnecting.
   *
   * @method _reset
   * @private
   */


  _createClass(SocketManager, [{
    key: '_reset',
    value: function _reset() {
      this._lastTimestamp = 0;
      this._lastDataFromServerTimestamp = 0;
      this._lastCounter = null;
      this._hasCounter = false;

      this._needsReplayFrom = null;
    }

    /**
     * Event handler is triggered any time the client's online state changes.
     * If going online we need to reconnect (i.e. will close any existing websocket connections and then open a new connection)
     * If going offline, close the websocket as its no longer useful/relevant.
     * @method _onlineStateChange
     * @private
     * @param {layer.LayerEvent} evt
     */

  }, {
    key: '_onlineStateChange',
    value: function _onlineStateChange(evt) {
      if (!this.client.isAuthenticated) return;
      if (evt.isOnline) {
        this._reconnect(evt.reset);
      } else {
        this.close();
      }
    }

    /**
     * Reconnect to the server, optionally resetting all data if needed.
     * @method _reconnect
     * @private
     * @param {boolean} reset
     */

  }, {
    key: '_reconnect',
    value: function _reconnect(reset) {
      // The sync manager will reissue any requests once it receives a 'connect' event from the websocket manager.
      // There is no need to have an error callback at this time.
      // Note that calls that come from sources other than the sync manager may suffer from this.
      // Once the websocket implements retry rather than the sync manager, we may need to enable it
      // to trigger a callback after sufficient time.  Just delete all callbacks.
      this.close();
      if (reset) this._reset();
      this.connect();
    }

    /**
     * Connect to the websocket server
     *
     * @method connect
     * @param  {layer.SyncEvent} evt - Ignored parameter
     */

  }, {
    key: 'connect',
    value: function connect(evt) {
      if (this.client.isDestroyed || !this.client.isOnline) return;
      if (this._isOpen()) return this._reconnect();

      this._closing = false;

      this._lastCounter = -1;

      // Get the URL and connect to it
      var url = this.client.websocketUrl + '/?session_token=' + this.client.sessionToken;

      // Load up our websocket component or shim
      /* istanbul ignore next */
      var WS = typeof WebSocket === 'undefined' ? require('websocket').w3cwebsocket : WebSocket;

      this._socket = new WS(url, WEBSOCKET_PROTOCOL);

      // If its the shim, set the event hanlers
      /* istanbul ignore if */
      if (typeof WebSocket === 'undefined') {
        this._socket.onmessage = this._onMessage;
        this._socket.onclose = this._onSocketClose;
        this._socket.onopen = this._onOpen;
        this._socket.onerror = this._onError;
      }

      // If its a real websocket, add the event handlers
      else {
          this._socket.addEventListener('message', this._onMessage);
          this._socket.addEventListener('close', this._onSocketClose);
          this._socket.addEventListener('open', this._onOpen);
          this._socket.addEventListener('error', this._onError);
        }

      // Trigger a failure if it takes >= 5 seconds to establish a connection
      this._connectionFailedId = setTimeout(this._connectionFailed.bind(this), 5000);
    }

    /**
     * Clears the scheduled call to _connectionFailed that is used to insure the websocket does not get stuck
     * in CONNECTING state. This call is used after the call has completed or failed.
     *
     * @method _clearConnectionFailed
     * @private
     */

  }, {
    key: '_clearConnectionFailed',
    value: function _clearConnectionFailed() {
      if (this._connectionFailedId) {
        clearTimeout(this._connectionFailedId);
        this._connectionFailedId = 0;
      }
    }

    /**
     * Called after 5 seconds of entering CONNECTING state without getting an error or a connection.
     * Calls _onError which will cause this attempt to be stopped and another connection attempt to be scheduled.
     *
     * @method _connectionFailed
     * @private
     */

  }, {
    key: '_connectionFailed',
    value: function _connectionFailed() {
      this._connectionFailedId = 0;
      var msg = 'Websocket failed to connect to server';
      logger.warn(msg);

      // TODO: At this time there is little information on what happens when closing a websocket connection that is stuck in
      // readyState=CONNECTING.  Does it throw an error?  Does it call the onClose or onError event handlers?
      // Remove all event handlers so that calling close won't trigger any calls.
      try {
        this.isOpen = false;
        this._removeSocketEvents();
        if (this._socket) {
          this._socket.close();
          this._socket = null;
        }
      } catch (e) {}
      // No-op


      // Now we can call our error handler.
      this._onError(new Error(msg));
    }

    /**
     * The websocket connection is reporting that its now open.
     *
     * @method _onOpen
     * @private
     */

  }, {
    key: '_onOpen',
    value: function _onOpen() {
      this._clearConnectionFailed();
      if (this._isOpen()) {
        this._lostConnectionCount = 0;
        this.isOpen = true;
        this.trigger('connected');
        logger.debug('Websocket Connected');
        if (this._hasCounter && this._lastTimestamp) {
          this.resync(this._lastTimestamp);
        } else {
          this._enablePresence();
          this._reschedulePing();
        }
      }
    }

    /**
     * Tests to see if the websocket connection is open.  Use the isOpen property
     * for external tests.
     * @method _isOpen
     * @private
     * @returns {Boolean}
     */

  }, {
    key: '_isOpen',
    value: function _isOpen() {
      if (!this._socket) return false;
      /* istanbul ignore if */
      if (typeof WebSocket === 'undefined') return true;
      return this._socket && this._socket.readyState === WebSocket.OPEN;
    }

    /**
     * If not isOpen, presumably failed to connect
     * Any other error can be ignored... if the connection has
     * failed, onClose will handle it.
     *
     * @method _onError
     * @private
     * @param  {Error} err - Websocket error
     */

  }, {
    key: '_onError',
    value: function _onError(err) {
      if (this._closing) return;
      this._clearConnectionFailed();
      logger.debug('Websocket Error causing websocket to close', err);
      if (!this.isOpen) {
        this._removeSocketEvents();
        this._lostConnectionCount++;
        this._scheduleReconnect();
      } else {
        this._onSocketClose();
        this._socket.close();
        this._socket = null;
      }
    }

    /**
     * Shortcut method for sending a signal
     *
     *    manager.sendSignal({
            'type': 'typing_indicator',
            'object': {
              'id': this.conversation.id
            },
            'data': {
              'action': state
            }
          });
     *
     * @method sendSignal
     * @param  {Object} body - Signal body
     */

  }, {
    key: 'sendSignal',
    value: function sendSignal(body) {
      if (this._isOpen()) {
        this._socket.send(JSON.stringify({
          type: 'signal',
          body: body
        }));
      }
    }

    /**
     * Shortcut to sending a Counter.read request
     *
     * @method getCounter
     * @param  {Function} callback
     * @param {boolean} callback.success
     * @param {number} callback.lastCounter
     * @param {number} callback.newCounter
     */

  }, {
    key: 'getCounter',
    value: function getCounter(_callback) {
      var _this2 = this;

      var tooSoon = Date.now() - this._lastGetCounterRequest < 1000;
      if (tooSoon) {
        if (!this._lastGetCounterId) {
          this._lastGetCounterId = setTimeout(function () {
            _this2._lastGetCounterId = 0;
            _this2.getCounter(_callback);
          }, Date.now() - this._lastGetCounterRequest - 1000);
        }
        return;
      }
      this._lastGetCounterRequest = Date.now();
      if (this._lastGetCounterId) {
        clearTimeout(this._lastGetCounterId);
        this._lastGetCounterId = 0;
      }

      logger.debug('Websocket request: getCounter');
      this.client.socketRequestManager.sendRequest({
        data: {
          method: 'Counter.read'
        },
        callback: function callback(result) {
          logger.debug('Websocket response: getCounter ' + result.data.counter);
          if (_callback) {
            if (result.success) {
              _callback(true, result.data.counter, result.fullData.counter);
            } else {
              _callback(false);
            }
          }
        },
        isChangesArray: false
      });
    }

    /**
     * Replays all missed change packets since the specified timestamp
     *
     * @method resync
     * @param  {string|number}   timestamp - Iso formatted date string; if number will be transformed into formatted date string.
     * @param  {Function} [callback] - Optional callback for completion
     */

  }, {
    key: 'resync',
    value: function resync(timestamp, callback) {
      var _this3 = this;

      if (!timestamp) throw new Error(LayerError.dictionary.valueNotSupported);
      if (typeof timestamp === 'number') timestamp = new Date(timestamp).toISOString();

      // Cancel any prior operation; presumably we lost connection and they're dead anyways,
      // but the callback triggering on these could be disruptive.
      this.client.socketRequestManager.cancelOperation('Event.replay');
      this.client.socketRequestManager.cancelOperation('Presence.sync');
      this._replayEvents(timestamp, function () {
        _this3._enablePresence(timestamp, function () {
          _this3.trigger('synced');
          if (callback) callback();
        });
      });
    }

    /**
     * Replays all missed change packets since the specified timestamp
     *
     * @method _replayEvents
     * @private
     * @param  {string|number}   timestamp - Iso formatted date string; if number will be transformed into formatted date string.
     * @param  {Function} [callback] - Optional callback for completion
     */

  }, {
    key: '_replayEvents',
    value: function _replayEvents(timestamp, _callback2) {
      var _this4 = this;

      // If we are simply unable to replay because we're disconnected, capture the _needsReplayFrom
      if (!this._isOpen() && !this._needsReplayFrom) {
        logger.debug('Websocket request: _replayEvents updating _needsReplayFrom');
        this._needsReplayFrom = timestamp;
      } else {
        logger.info('Websocket request: _replayEvents');
        this.client.socketRequestManager.sendRequest({
          data: {
            method: 'Event.replay',
            data: {
              from_timestamp: timestamp
            }
          },
          callback: function callback(result) {
            return _this4._replayEventsComplete(timestamp, _callback2, result.success);
          },
          isChangesArray: false
        });
      }
    }

    /**
     * Callback for handling completion of replay.
     *
     * @method _replayEventsComplete
     * @private
     * @param  {Date}     timestamp
     * @param  {Function} callback
     * @param  {Boolean}   success
     */

  }, {
    key: '_replayEventsComplete',
    value: function _replayEventsComplete(timestamp, callback, success) {
      var _this5 = this;

      if (success) {
        this._replayRetryCount = 0;

        // If replay was completed, and no other requests for replay, then we're done.
        if (!this._needsReplayFrom) {
          logger.info('Websocket replay complete');
          if (callback) callback();
        }

        // If replayEvents was called during a replay, then replay
        // from the given timestamp.  If request failed, then we need to retry from _lastTimestamp
        else if (this._needsReplayFrom) {
            logger.info('Websocket replay partially complete');
            var t = this._needsReplayFrom;
            this._needsReplayFrom = null;
            this._replayEvents(t);
          }
      }

      // We never got a done event; but either got an error from the server or the request timed out.
      // Use exponential backoff incremented integers that getExponentialBackoffSeconds mapping to roughly
      // 0.4 seconds - 12.8 seconds, and then stops retrying.
      else if (this._replayRetryCount < 8) {
          var maxDelay = 20;
          var delay = Utils.getExponentialBackoffSeconds(maxDelay, Math.min(15, this._replayRetryCount + 2));
          logger.info('Websocket replay retry in ' + delay + ' seconds');
          setTimeout(function () {
            return _this5._replayEvents(timestamp);
          }, delay * 1000);
          this._replayRetryCount++;
        } else {
          logger.error('Websocket Event.replay has failed');
        }
    }

    /**
     * Resubscribe to presence and replay missed presence changes.
     *
     * @method _enablePresence
     * @private
     * @param  {Date}     timestamp
     * @param  {Function} callback
     */

  }, {
    key: '_enablePresence',
    value: function _enablePresence(timestamp, callback) {
      this.client.socketRequestManager.sendRequest({
        data: {
          method: 'Presence.subscribe'
        },
        callback: null,
        isChangesArray: false
      });

      if (this.client.isPresenceEnabled) {
        this.client.socketRequestManager.sendRequest({
          data: {
            method: 'Presence.update',
            data: [{ operation: 'set', property: 'status', value: 'auto' }]
          },
          callback: null,
          isChangesArray: false
        });
      }

      if (timestamp) {
        this.syncPresence(timestamp, callback);
      } else if (callback) {
        callback({ success: true });
      }
    }

    /**
     * Synchronize all presence data or catch up on missed presence data.
     *
     * Typically this is called by layer.Websockets.SocketManager._enablePresence automatically,
     * but there may be occasions where an app wants to directly trigger this action.
     *
     * @method syncPresence
     * @param {String} timestamp    `Date.toISOString()` formatted string, returns all presence changes since that timestamp.  Returns all followed presence
     *       if no timestamp is provided.
     * @param {Function} [callback]   Function to call when sync is completed.
     */

  }, {
    key: 'syncPresence',
    value: function syncPresence(timestamp, callback) {
      if (timestamp) {
        // Return value for use in unit tests
        return this.client.socketRequestManager.sendRequest({
          data: {
            method: 'Presence.sync',
            data: {
              since: timestamp
            }
          },
          isChangesArray: true,
          callback: callback
        });
      }
    }

    /**
     * Handles a new websocket packet from the server
     *
     * @method _onMessage
     * @private
     * @param  {Object} evt - Message from the server
     */

  }, {
    key: '_onMessage',
    value: function _onMessage(evt) {
      this._lostConnectionCount = 0;
      try {
        var msg = JSON.parse(evt.data);
        var skippedCounter = this._lastCounter + 1 !== msg.counter;
        this._hasCounter = true;
        this._lastCounter = msg.counter;
        this._lastDataFromServerTimestamp = Date.now();

        // If we've missed a counter, replay to get; note that we had to update _lastCounter
        // for replayEvents to work correctly.
        if (skippedCounter) {
          this.resync(this._lastTimestamp);
        } else {
          this._lastTimestamp = new Date(msg.timestamp).getTime();
        }

        this.trigger('message', {
          data: msg
        });

        this._reschedulePing();
      } catch (err) {
        logger.error('Layer-Websocket: Failed to handle websocket message: ' + err + '\n', evt.data);
      }
    }

    /**
     * Reschedule a ping request which helps us verify that the connection is still alive,
     * and that we haven't missed any events.
     *
     * @method _reschedulePing
     * @private
     */

  }, {
    key: '_reschedulePing',
    value: function _reschedulePing() {
      if (this._nextPingId) {
        clearTimeout(this._nextPingId);
      }
      this._nextPingId = setTimeout(this._ping.bind(this), this.pingFrequency);
    }

    /**
     * Send a counter request to the server to verify that we are still connected and
     * have not missed any events.
     *
     * @method _ping
     * @private
     */

  }, {
    key: '_ping',
    value: function _ping() {
      logger.debug('Websocket ping');
      this._nextPingId = 0;
      if (this._isOpen()) {
        // NOTE: onMessage will already have called reschedulePing, but if there was no response, then the error handler would NOT have called it.
        this.getCounter(this._reschedulePing.bind(this));
      }
    }

    /**
     * Close the websocket.
     *
     * @method close
     */

  }, {
    key: 'close',
    value: function close() {
      logger.debug('Websocket close requested');
      this._closing = true;
      this.isOpen = false;
      if (this._socket) {
        // Close all event handlers and set socket to null
        // without waiting for browser event to call
        // _onSocketClose as the next command after close
        // might require creating a new socket
        this._onSocketClose();
        this._socket.close();
        this._socket = null;
      }
    }

    /**
     * Send a packet across the websocket
     * @method send
     * @param {Object} obj
     */

  }, {
    key: 'send',
    value: function send(obj) {
      this._socket.send(JSON.stringify(obj));
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.close();
      if (this._nextPingId) clearTimeout(this._nextPingId);
      _get(Object.getPrototypeOf(SocketManager.prototype), 'destroy', this).call(this);
    }

    /**
     * If the socket has closed (or if the close method forces it closed)
     * Remove all event handlers and if appropriate, schedule a retry.
     *
     * @method _onSocketClose
     * @private
     */

  }, {
    key: '_onSocketClose',
    value: function _onSocketClose() {
      logger.debug('Websocket closed');
      this.isOpen = false;
      if (!this._closing) {
        this._scheduleReconnect();
      }

      this._removeSocketEvents();
      this.trigger('disconnected');
    }

    /**
     * Removes all event handlers on the current socket.
     *
     * @method _removeSocketEvents
     * @private
     */

  }, {
    key: '_removeSocketEvents',
    value: function _removeSocketEvents() {
      /* istanbul ignore if */
      if (typeof WebSocket !== 'undefined' && this._socket) {
        this._socket.removeEventListener('message', this._onMessage);
        this._socket.removeEventListener('close', this._onSocketClose);
        this._socket.removeEventListener('open', this._onOpen);
        this._socket.removeEventListener('error', this._onError);
      } else if (this._socket) {
        this._socket.onmessage = null;
        this._socket.onclose = null;
        this._socket.onopen = null;
        this._socket.onerror = null;
      }
    }

    /**
     * Schedule an attempt to reconnect to the server.  If the onlineManager
     * declares us to be offline, don't bother reconnecting.  A reconnect
     * attempt will be triggered as soon as the online manager reports we are online again.
     *
     * Note that the duration of our delay can not excede the onlineManager's ping frequency
     * or it will declare us to be offline while we attempt a reconnect.
     *
     * @method _scheduleReconnect
     * @private
     */

  }, {
    key: '_scheduleReconnect',
    value: function _scheduleReconnect() {
      var _this6 = this;

      if (this.isDestroyed || !this.client.isOnline) return;

      var maxDelay = (this.client.onlineManager.pingFrequency - 1000) / 1000;
      var delay = Utils.getExponentialBackoffSeconds(maxDelay, Math.min(15, this._lostConnectionCount));
      logger.debug('Websocket Reconnect in ' + delay + ' seconds');
      if (!this._reconnectId) {
        this._reconnectId = setTimeout(function () {
          _this6._reconnectId = 0;
          _this6._validateSessionBeforeReconnect();
        }, delay * 1000);
      }
    }

    /**
     * Before the scheduled reconnect can call `connect()` validate that we didn't lose the websocket
     * due to loss of authentication.
     *
     * @method _validateSessionBeforeReconnect
     * @private
     */

  }, {
    key: '_validateSessionBeforeReconnect',
    value: function _validateSessionBeforeReconnect() {
      var _this7 = this;

      if (this.isDestroyed || !this.client.isOnline) return;

      var maxDelay = 30 * 1000; // maximum delay of 30 seconds per ping
      var diff = Date.now() - this._lastValidateSessionRequest - maxDelay;
      if (diff < 0) {
        // This is identical to whats in _scheduleReconnect and could be cleaner
        if (!this._reconnectId) {
          this._reconnectId = setTimeout(function () {
            _this7._reconnectId = 0;
            _this7._validateSessionBeforeReconnect();
          }, Math.abs(diff) + 1000);
        }
      } else {
        this._lastValidateSessionRequest = Date.now();
        this.client.xhr({
          url: '/?action=validateConnectionForWebsocket&client=' + this.client.constructor.version,
          method: 'GET',
          sync: false
        }, function (result) {
          if (result.success) _this7.connect();
          // if not successful, the this.client.xhr will handle reauthentication
        });
      }
    }
  }]);

  return SocketManager;
}(Root);

/**
 * Is the websocket connection currently open?
 * @type {Boolean}
 */


SocketManager.prototype.isOpen = false;

/**
 * setTimeout ID for calling connect()
 * @private
 * @type {Number}
 */
SocketManager.prototype._reconnectId = 0;

/**
 * setTimeout ID for calling _connectionFailed()
 * @private
 * @type {Number}
 */
SocketManager.prototype._connectionFailedId = 0;

SocketManager.prototype._lastTimestamp = 0;
SocketManager.prototype._lastDataFromServerTimestamp = 0;
SocketManager.prototype._lastCounter = null;
SocketManager.prototype._hasCounter = false;

SocketManager.prototype._needsReplayFrom = null;

SocketManager.prototype._replayRetryCount = 0;

SocketManager.prototype._lastGetCounterRequest = 0;
SocketManager.prototype._lastGetCounterId = 0;

/**
 * Time in miliseconds since the last call to _validateSessionBeforeReconnect
 * @type {Number}
 */
SocketManager.prototype._lastValidateSessionRequest = 0;

/**
 * Frequency with which the websocket checks to see if any websocket notifications
 * have been missed.
 * @type {Number}
 */
SocketManager.prototype.pingFrequency = 30000;

/**
 * The Client that owns this.
 * @type {layer.Client}
 */
SocketManager.prototype.client = null;

/**
 * The Socket Connection instance
 * @type {Websocket}
 */
SocketManager.prototype._socket = null;

/**
 * Is the websocket connection being closed by a call to close()?
 * If so, we can ignore any errors that signal the socket as closing.
 * @type {Boolean}
 */
SocketManager.prototype._closing = false;

/**
 * Number of failed attempts to reconnect.
 * @type {Number}
 */
SocketManager.prototype._lostConnectionCount = 0;

SocketManager._supportedEvents = [
/**
 * A data packet has been received from the server.
 * @event message
 * @param {layer.LayerEvent} layerEvent
 * @param {Object} layerEvent.data - The data that was received from the server
 */
'message',

/**
 * The websocket is now connected.
 * @event connected
 * @protected
 */
'connected',

/**
 * The websocket is no longer connected
 * @event disconnected
 * @protected
 */
'disconnected',

/**
 * Websocket events were missed; we are resyncing with the server
 * @event replay-begun
 */
'syncing',

/**
 * Websocket events were missed; we resynced with the server and are now done
 * @event replay-begun
 */
'synced'].concat(Root._supportedEvents);
Root.initClass.apply(SocketManager, [SocketManager, 'SocketManager']);
module.exports = SocketManager;


},{"../client-utils":82,"../const":84,"../layer-error":86,"../logger":88,"../root":116,"websocket":10}],126:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

/**
 * Basic XHR Library with some notions hardcoded in
 * of what the Layer server expects/returns.
 *
    layer.xhr({
      url: 'http://my.com/mydata',
      data: {hey: 'ho', there: 'folk'},
      method: 'GET',
      format: 'json',
      headers: {'fred': 'Joe'},
      timeout: 50000
    }, function(result) {
      if (!result.success) {
        errorHandler(result.data, result.headers, result.status);
      } else {
        successHandler(result.data, result.headers, result.xhr);
      }
    });
 *
 * @class layer.xhr
 * @private
 */

/**
 * Send a Request.
 *
 * @method  xhr
 * @param {Object} options
 * @param {string} options.url
 * @param {Mixed} [options.data=null]
 * @param {string} [options.format=''] - set to 'json' to get result parsed as json (in case there is no obvious Content-Type in the response)
 * @param {Object} [options.headers={}] - Name value pairs for  headers and their values
 * @param {number} [options.timeout=0] - When does the request expire/timeout in miliseconds.
 * @param {Function} callback
 * @param {Object} callback.result
 * @param {number} callback.result.status - http status code
 * @param {boolean} callback.result.success - true if it was a successful response
 * @param {XMLHttpRequest} callback.result.xhr - The XHR object used for the request
 * @param {Object} callback.result.data -  The parsed response body
 *
 * TODO:
 *
 * 1. Make this a subclass of Root and make it a singleton so it can inherit a proper event system
 * 2. Result should be a layer.ServerResponse instance
 * 3. Should only access link headers if requested; annoying having it throw errors every other time.
 */

// Don't set xhr to window.XMLHttpRequest as it will bypass jasmine's
// ajax library
var Xhr = typeof window === 'undefined' ? require('xhr2') : null;

function parseLinkHeaders(linkHeader) {
  if (!linkHeader) return {};

  // Split parts by comma
  var parts = linkHeader.split(',');
  var links = {};

  // Parse each part into a named link
  parts.forEach(function (part) {
    var section = part.split(';');
    if (section.length !== 2) return;
    var url = section[0].replace(/<(.*)>/, '$1').trim();
    var name = section[1].replace(/rel='?(.*)'?/, '$1').trim();
    links[name] = url;
  });

  return links;
}

module.exports = function (request, callback) {
  var req = Xhr ? new Xhr() : new XMLHttpRequest();
  var method = (request.method || 'GET').toUpperCase();

  var onload = function onload() {
    var headers = {
      'content-type': this.getResponseHeader('content-type')
    };

    var result = {
      status: this.status,
      success: this.status && this.status < 300,
      xhr: this
    };
    var isJSON = String(headers['content-type']).split(/;/)[0].match(/^application\/json/) || request.format === 'json';

    if (this.responseType === 'blob' || this.responseType === 'arraybuffer') {
      if (this.status === 0) {
        result.data = new Error('Connection Failed');
      } else {
        // Damnit, this.response is a function if using jasmine test framework.
        result.data = typeof this.response === 'function' ? this.responseText : this.response;
      }
    } else {
      if (isJSON && this.responseText) {
        try {
          result.data = JSON.parse(this.responseText);
        } catch (err) {
          result.data = {
            code: 999,
            message: 'Invalid JSON from server',
            response: this.responseText
          };
          result.status = 999;
        }
      } else {
        result.data = this.responseText;
      }

      module.exports.trigger({
        target: this,
        status: !this.responseText && !this.status ? 'connection:error' : 'connection:success'
      });

      if (!this.responseText && !this.status) {
        result.status = 408;
        result.data = {
          id: 'request_timeout',
          message: 'The server is not responding please try again in a few minutes',
          url: 'https://docs.layer.com/reference/client_api/errors',
          code: 0,
          status: 408,
          httpStatus: 408
        };
      } else if (this.status === 404 && _typeof(result.data) !== 'object') {
        result.data = {
          id: 'operation_not_found',
          message: 'Endpoint ' + (request.method || 'GET') + ' ' + request.url + ' does not exist',
          status: this.status,
          httpStatus: 404,
          code: 106,
          url: 'https://docs.layer.com/reference/client_api/errors'
        };
      } else if (typeof result.data === 'string' && this.status >= 400) {
        result.data = {
          id: 'unknown_error',
          message: result.data,
          status: this.status,
          httpStatus: this.status,
          code: 0,
          url: 'https://www.google.com/search?q=doh!'
        };
      }
    }

    if (request.headers && (request.headers.accept || '').match(/application\/vnd.layer\+json/)) {
      var links = this.getResponseHeader('link');
      if (links) result.Links = parseLinkHeaders(links);
    }
    result.xhr = this;

    if (callback) callback(result);
  };

  req.onload = onload;

  // UNTESTED!!!
  req.onerror = req.ontimeout = onload;

  // Replace all headers in arbitrary case with all lower case
  // for easy matching.
  var headersList = Object.keys(request.headers || {});
  var headers = {};
  headersList.forEach(function (header) {
    if (header.toLowerCase() === 'content-type') {
      headers['content-type'] = request.headers[header];
    } else {
      headers[header.toLowerCase()] = request.headers[header];
    }
  });
  request.headers = headers;

  var data = '';
  if (request.data) {
    if (typeof Blob !== 'undefined' && request.data instanceof Blob) {
      data = request.data;
    } else if (request.headers && (String(request.headers['content-type']).match(/^application\/json/) || String(request.headers['content-type']) === 'application/vnd.layer-patch+json')) {
      data = typeof request.data === 'string' ? request.data : JSON.stringify(request.data);
    } else if (request.data && _typeof(request.data) === 'object') {
      Object.keys(request.data).forEach(function (name) {
        if (data) data += '&';
        data += name + '=' + request.data[name];
      });
    } else {
      data = request.data; // Some form of raw string/data
    }
  }
  if (data) {
    if (method === 'GET') {
      request.url += '?' + data;
    }
  }

  req.open(method, request.url, true);
  if (request.timeout) req.timeout = request.timeout;
  if (request.withCredentials) req.withCredentials = true;
  if (request.responseType) req.responseType = request.responseType;

  if (request.headers) {
    Object.keys(request.headers).forEach(function (headerName) {
      return req.setRequestHeader(headerName, request.headers[headerName]);
    });
  }

  try {
    if (method === 'GET') {
      req.send();
    } else {
      req.send(data);
    }
  } catch (e) {
    // do nothing
  }
};

var listeners = [];
module.exports.addConnectionListener = function (func) {
  return listeners.push(func);
};

module.exports.trigger = function (evt) {
  listeners.forEach(function (func) {
    return func(evt);
  });
};


},{"xhr2":10}],127:[function(require,module,exports){
/**
 * Standalone extraction of Backbone.Events, no external dependency required.
 * Degrades nicely when Backone/underscore are already available in the current
 * global context.
 *
 * Note that docs suggest to use underscore's `_.extend()` method to add Events
 * support to some given object. A `mixin()` method has been added to the Events
 * prototype to avoid using underscore for that sole purpose:
 *
 *     var myEventEmitter = BackboneEvents.mixin({});
 *
 * Or for a function constructor:
 *
 *     function MyConstructor(){}
 *     MyConstructor.prototype.foo = function(){}
 *     BackboneEvents.mixin(MyConstructor.prototype);
 *
 * (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * (c) 2013 Nicolas Perriault
 */
/* global exports:true, define, module */
(function() {
  var root = this,
      nativeForEach = Array.prototype.forEach,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      slice = Array.prototype.slice,
      idCounter = 0;

  // Returns a partial implementation matching the minimal API subset required
  // by Backbone.Events
  function miniscore() {
    return {
      keys: Object.keys || function (obj) {
        if (typeof obj !== "object" && typeof obj !== "function" || obj === null) {
          throw new TypeError("keys() called on a non-object");
        }
        var key, keys = [];
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            keys[keys.length] = key;
          }
        }
        return keys;
      },

      uniqueId: function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      },

      has: function(obj, key) {
        return hasOwnProperty.call(obj, key);
      },

      each: function(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (var i = 0, l = obj.length; i < l; i++) {
            iterator.call(context, obj[i], i, obj);
          }
        } else {
          for (var key in obj) {
            if (this.has(obj, key)) {
              iterator.call(context, obj[key], key, obj);
            }
          }
        }
      },

      once: function(func) {
        var ran = false, memo;
        return function() {
          if (ran) return memo;
          ran = true;
          memo = func.apply(this, arguments);
          func = null;
          return memo;
        };
      }
    };
  }

  var _ = miniscore(), Events;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Mixin utility
  Events.mixin = function(proto) {
    var exports = ['on', 'once', 'off', 'trigger', 'stopListening', 'listenTo',
                   'listenToOnce', 'bind', 'unbind'];
    _.each(exports, function(name) {
      proto[name] = this[name];
    }, this);
    return proto;
  };

  // Export Events as BackboneEvents depending on current context
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Events;
    }
    exports.BackboneEvents = Events;
  }else if (typeof define === "function"  && typeof define.amd == "object") {
    define(function() {
      return Events;
    });
  } else {
    root.BackboneEvents = Events;
  }
})(this);

},{}],128:[function(require,module,exports){
/**
 * The layer.js.LayerPatchParser method will parse
 *
 * @method
 * @param {Boolean}   [camelCase=false]             Set the camel cased version of the name of the input object
 * @param {Object}    [propertyNameMap]             Maps property names in the operation to property names in the local object schema
 * @param {Object}    [changeCallbacks]             Callback made any time an object is changed
 * @param {Object}    [abortCallbacks]              Callback made to verify a change is permitted
 * @param {Function}  [doesObjectMatchIdCallback]   Callback returns boolean to indicate if a given object matches an ID.
 * @return {Boolean}                                Returns true if all operations completed successfully, false if some returned errors
 */

(function() {
  var opHandlers = {
    'set': setProp,
    'delete': deleteProp,
    'add': addProp,
    'remove': removeProp
  };

  function Parser(options) {
    this.camelCase = options.camelCase;
    this.propertyNameMap = options.propertyNameMap;
    this.changeCallbacks = options.changeCallbacks;
    this.abortCallbacks = options.abortCallbacks;
    this.getObjectCallback = options.getObjectCallback;
    this.createObjectCallback = options.createObjectCallback;
    this.doesObjectMatchIdCallback = options.doesObjectMatchIdCallback || function(id, obj) {
      return obj.id == id;
    };
    this.returnIds = options.returnIds;
    return this;
  };

  if (typeof module !== 'undefined') {
    module.exports = Parser;
  } else {
    window.LayerPatchParser = Parser;
  }

  Parser.prototype.parse = function(options) {
    var changes = {};
    options.operations.forEach(function(op) {
      var propertyDef = getPropertyDef.apply(this, [op.property, options, changes, op])
      opHandlers[op.operation].call(this,
        propertyDef,
        getValue.apply(this, [op, options]),
        op, options, changes);
    }, this);

    reportChanges.apply(this, [changes, options.object, options.type]);
  };

  function reportChanges(changes, updateObject, objectType) {
    if (this.changeCallbacks && objectType && this.changeCallbacks[objectType]) {
      Object.keys(changes).forEach(function(key) {
        if (this.changeCallbacks[objectType].all) {
          this.changeCallbacks[objectType].all(updateObject, updateObject[key], changes[key].before, changes[key].paths);
        }
        else if (this.changeCallbacks[objectType][key]) {
          this.changeCallbacks[objectType][key](updateObject, updateObject[key], changes[key].before, changes[key].paths);
        }
      }, this);
    }
  }

  function getPropertyDef(property, options, changes, operation) {
    var obj = options.object;
    var temporarySeparator = String.fromCharCode(145);
    property = property.replace(/\\\./g, temporarySeparator);
    property = property.replace(/\\(.)/g, '$1');
    var parts = property.split(/\./);
    var r = new RegExp(temporarySeparator, 'g')
    parts = parts.map(function(part) {
      return part.replace(r, '.');
    });
    if (this.camelCase) {
      parts[0] = parts[0].replace(/[-_]./g, function(str) {
        return str[1].toUpperCase();
      });
    }
    if (this.propertyNameMap) {
      var typeDef = this.propertyNameMap[options.type];
      parts[0] = (typeDef && typeDef[parts[0]]) || parts[0];
    }

    trackChanges.apply(this, [{
      baseName: parts[0],
      fullPath: property,
      object: options.object,
      options: options,
      changes: changes,
      operation: operation
    }]);

    var curObj = obj;
    for (var i = 0; i < parts.length-1; i++) {
      var part = parts[i];
      if (part in curObj) {
        curObj = curObj[part];
        if (curObj === null || typeof curObj !== 'object') throw new Error('Can not access property \'' + property + '\'');
      } else {
        curObj[part] = {};
        curObj = curObj[part];
      }
    }

    return {
      pointer: curObj,
      lastName: parts[parts.length-1],
      baseName: parts[0],
      fullPath: property,
      abortHandler: this.abortCallbacks && this.abortCallbacks[options.type] && (this.abortCallbacks[options.type].all || this.abortCallbacks[options.type][parts[0]])
    };
  }

  function getValue(op, options) {
    if (op.id) {
      if (!this.getObjectCallback) throw new Error('Must provide getObjectCallback in constructor to use ids');
      var result = this.getObjectCallback(op.id);
      if (!result && op.value) {
        result = this.createObjectCallback ? this.createObjectCallback(op.id, op.value) : op.value;
      }
      if (result) return result;
      if (this.returnIds) return op.id;
      return null;
    } else {
      return op.value;
    }
  }

  function cloneObject(obj) {
    if (Array.isArray(obj)) {
      return obj.map(function(item) {
        return cloneObject(item);
      });
    } else if (obj instanceof Date) {
      return new Date(obj);
    } else if (obj && typeof obj === 'object') {
      var keys = Object.keys(obj).filter(function(keyName) {
        return keyName.indexOf('_') !== 0;
      });
      var newObj = {};
      keys.forEach(function(keyName) {
        newObj[keyName] = cloneObject(obj[keyName]);
      });
      return newObj;
    } else {
      return obj;
    }
  }

  function trackChanges(options) {
    if (!options.changes[options.baseName]) {
      var initialValue = options.object[options.baseName];
      if ((options.operation === 'set' || options.operation === 'delete') && 'id' in options.operation && initialValue) {
        initialValue = initialValue.id;
      }
      var change = options.changes[options.baseName] = {paths: []};
      change.before = (initialValue && typeof initialValue === 'object') ? cloneObject(initialValue) : initialValue;
    }
    var paths = options.changes[options.baseName].paths;
    if (paths.indexOf(options.fullPath) === -1) {
      paths.push(options.fullPath);
    }
  }

  function setProp(propertyDef, value, op, options, changes) {
    if (propertyDef.abortHandler) {
      if (propertyDef.abortHandler(propertyDef.fullPath, 'set', value)) return;
    }
    propertyDef.pointer[propertyDef.lastName] = value;

  }

  function deleteProp(propertyDef, value, op, options, changes) {
    if (propertyDef.abortHandler) {
      if (propertyDef.abortHandler(propertyDef.fullPath, 'delete', value)) return;
    }
    delete propertyDef.pointer[propertyDef.lastName];
  }

  function addProp(propertyDef, value, op, options, changes) {
    if (propertyDef.abortHandler) {
      if (propertyDef.abortHandler(propertyDef.fullPath, 'add', value)) return;
    }
    var obj;
    if (propertyDef.lastName in propertyDef.pointer) {
      obj = propertyDef.pointer[propertyDef.lastName];
    } else {
      obj = propertyDef.pointer[propertyDef.lastName] = [];
    }
    if (!Array.isArray(obj)) throw new Error('The add operation requires an array or new structure to add to.');
    if (Array.isArray(value)) throw new Error('The add operation will not add arrays to sets.');
    if (!op.id) {
      if (value && typeof value === 'object') throw new Error('The add operation will not add objects to sets.');
      if (obj.indexOf(value) === -1) obj.push(value);
    } else {
      for (var i = 0; i < obj.length; i++) {
        if (this.doesObjectMatchIdCallback(op.id, obj[i])) return;
      }
      obj.push(value);
    }
  }

  function removeProp(propertyDef, value, op, options, changes) {
    if (propertyDef.abortHandler) {
      if (propertyDef.abortHandler(propertyDef.fullPath, 'remove', value)) return;
    }
    var obj;
    if (propertyDef.lastName in propertyDef.pointer) {
      obj = propertyDef.pointer[propertyDef.lastName];
    } else {
      obj = propertyDef.pointer[propertyDef.lastName] = [];
    }
    if (!Array.isArray(obj)) throw new Error('The remove operation requires an array or new structure to remove from.');

    if (!op.id) {
      if (Array.isArray(value)) throw new Error('The remove operation will not remove arrays from sets.');
      if (value && typeof value === 'object') throw new Error('The remove operation will not remove objects from sets.');

      var index = obj.indexOf(value);
      if (index !== -1) obj.splice(index, 1);
    } else {
      for (var i = 0; i < obj.length; i++) {
        if (this.doesObjectMatchIdCallback(op.id, obj[i])) {
          obj.splice(i, 1);
          break;
        }
      }
    }
  }
})();

},{}],129:[function(require,module,exports){
(function (global){

var rng;

if (global.crypto && crypto.getRandomValues) {
  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
  // Moderately fast, high quality
  var _rnds8 = new Uint8Array(16);
  rng = function whatwgRNG() {
    crypto.getRandomValues(_rnds8);
    return _rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var  _rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  };
}

module.exports = rng;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],130:[function(require,module,exports){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required
var _rng = require('./rng');

// Maps for number <-> hex string conversion
var _byteToHex = [];
var _hexToByte = {};
for (var i = 0; i < 256; i++) {
  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
  _hexToByte[_byteToHex[i]] = i;
}

// **`parse()` - Parse a UUID into it's component bytes**
function parse(s, buf, offset) {
  var i = (buf && offset) || 0, ii = 0;

  buf = buf || [];
  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
    if (ii < 16) { // Don't overflow!
      buf[i + ii++] = _hexToByte[oct];
    }
  });

  // Zero out remaining bytes if string was short
  while (ii < 16) {
    buf[i + ii++] = 0;
  }

  return buf;
}

// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
function unparse(buf, offset) {
  var i = offset || 0, bth = _byteToHex;
  return  bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = _rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; n++) {
    b[i + n] = node[n];
  }

  return buf ? buf : unparse(b);
}

// **`v4()` - Generate random UUID**

// See https://github.com/broofa/node-uuid for API details
function v4(options, buf, offset) {
  // Deprecated - 'format' argument, as supported in v1.2
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || _rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || unparse(rnds);
}

// Export public API
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
uuid.parse = parse;
uuid.unparse = unparse;

module.exports = uuid;

},{"./rng":129}]},{},[8])(8)
});